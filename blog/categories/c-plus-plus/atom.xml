<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c++ | Yebangyu's Blog]]></title>
  <link href="http://www.yebangyu.org/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://www.yebangyu.org/"/>
  <updated>2016-04-23T10:16:38+08:00</updated>
  <id>http://www.yebangyu.org/</id>
  <author>
    <name><![CDATA[Yebangyu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[String Literal In C++]]></title>
    <link href="http://www.yebangyu.org/blog/2016/04/10/stringliteralincpp/"/>
    <updated>2016-04-10T22:05:21+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/04/10/stringliteralincpp</id>
    <content type="html"><![CDATA[<p>最近被一个很基本的知识点给咬伤，虽然之前知道这个问题，但是写代码的时候不小心还是容易犯错。简单记录一下。</p>

<h2 id="section">提出问题</h2>

<p>之前，代码里拥有如下数组：</p>

<p><code>c++
const char *COLORS[3] = {"red",
                         "black",
                         "green"
                        };
</code></p>

<p>现在需要以追加的形式，添加一个yellow的颜色。粗心之下，我写成了：</p>

<!--more-->

<p><code>c++
const char *COLORS[4] = {"red",
                         "black",
                         "green"
                         "yellow"
                        };
</code></p>

<p>在某处代码，我使用了COLORS[3]，类似于</p>

<p><code>cout&lt;&lt;COLORS[3]&lt;&lt;endl;</code></p>

<p>程序执行后，就崩溃了。</p>

<h2 id="section-1">分析问题</h2>

<p>问题出在，在追加的代码中的第4行，漏掉了一个逗号！！！正确的形式应该是：</p>

<p><code>c++
const char *COLORS[4] = {"red",
                         "black",
                         "green", //这里应该有个逗号！！！
                         "yellow"
                        };
</code></p>

<p>在没有逗号下，编译器将”green”和”yellow”当做一个字符串，也就是”greenyellow”，因此，COLORS[2]其实是”greenyellow”，而COLORS[3]是未显式初始化的，为NULL。因此使用COLORS[3]程序崩溃。</p>

<h2 id="section-2">解决问题</h2>

<p>上面已经解决了问题。这里小小补充下:</p>

<p>在C++中，如下几种形式结果是一样的，表示的是同一个字符串”hello, world” ：</p>

<p><code>c++
"hello, world"
</code></p>

<p><code>c++
"hello, "
"world"
</code></p>

<p><code>c++
"hello, \
world"
</code></p>

<p><code>c++
"hello, "  "w"  "orld"
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C99中的柔性数组]]></title>
    <link href="http://www.yebangyu.org/blog/2016/03/25/fuckthefever/"/>
    <updated>2016-03-25T12:00:34+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/03/25/fuckthefever</id>
    <content type="html"><![CDATA[<p>柔性数组是C99引入的feature。</p>

<p><code>c++
struct Data
{
  int i;
  int a[0];
};
</code></p>

<p>其中柔性数组a处于结构体的末尾，并且声明的大小为0。</p>

<!--more-->

<p>那么它有什么性质呢？</p>

<p>1，首先，a不占用结构体空间。它只是一个占位符而已。因此</p>

<p>sizeof(Data) = sizeof(int) （这里的int是那个变量i）</p>

<p>2，我们可以利用a来分配动态内存：</p>

<p><code>c++
Data *p = (Data*) malloc(sizeof(Data) + 10 * sizeof(int))
</code></p>

<p>这样，p就包含了10个int型元素构成的数组。</p>

<p>3，有些人说，为什么我们不这样呢？</p>

<p><code>c++
struct Data
{
  int i;
  int *a;
};
Data *p = (Data*) malloc(sizeof(Data));
p-&gt;a = (int*) malloc(10 * sizeof(int));
</code></p>

<p>这样子不是挺好的么？是挺好的，但是这样结构体大小就得翻倍了，因为这下a不是占位符而是实实在在的指针变量了。</p>

<p>这还算小事。大事呢？这就是我们第三点要扯的：如果改成这样后，结构体成员i和数组a中的(首个)元素，地址将几乎肯定不是挨着的！！！这可能会带来很多问题，包括cache unfriendly等。</p>

<p>而如果使用柔性数组，我们可以简单做个实验发现：</p>

<p><code>c++
#include&lt;iostream&gt;
using namespace std;
struct Data
{
  int i;
  int a[0];
};
int main()
{
  Data *p = (Data*)malloc(sizeof(Data) + 100 * sizeof(int));
  cout&lt;&lt;&amp;(p-&gt;i)&lt;&lt;endl;
  cout&lt;&lt;&amp;(p-&gt;a[0])&lt;&lt;endl;
  cout&lt;&lt;sizeof(Data)&lt;&lt;endl;
  return 0;
}
</code>
在ubuntu 14.04 64位系统＋gcc 4.8下编译运行后，程序输出：</p>

<pre><code>0x8a9010
0x8a9014
4
</code></pre>

<p>不额外占用空间、实现变长结构体、连续地址。能同时做到这三点的，除了柔性数组，不知还能有谁？不过这玩意，个人意见能少用尽量少用，能不用尽量不用，毕竟可能有移植性问题。</p>

<p>柔性数组的一个很常见的应用是跳表(Skip List)。由于跳表中不同的节点拥有不尽相同的高度,每个节点所包含的后继指针数量也不尽相同,因此此时柔性数组的合理使用可以最大利用内存空间.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编写高质量代码(下)]]></title>
    <link href="http://www.yebangyu.org/blog/2016/02/24/writeelegantcodes/"/>
    <updated>2016-02-24T22:26:44+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/02/24/writeelegantcodes</id>
    <content type="html"><![CDATA[<p><a href="http://www.yebangyu.org/blog/2015/11/06/how-to-write-elegant-cpp-codes/">上回</a>我们从微观角度，以一个实际的例子，从正确、高效、易读等特性着手，介绍了如何编写高质量的代码。这次，我们从宏观出发，从软件开发流程入手，着重介绍其中的几个方面，包括代码规范、Code Review、测试等。</p>

<p>如果说<a href="http://www.yebangyu.org/blog/2015/11/06/how-to-write-elegant-cpp-codes/">上回</a>的内容注重个人编码，那么本文将偏向团队开发。</p>

<h2 id="section">代码规范</h2>

<p>团队的代码规范，一般由领导和大佬们制定后，大家统一实行。这里面有几个问题：</p>

<h3 id="section-1">真的需要代码规范吗？</h3>

<p>言下之意，制定和执行代码规范是否浪费时间？</p>

<!--more-->

<p>答案是：It depends。如果项目很庞大、代码质量要求很高，那么，制定和执行代码规范所花费的时间，将大大少于后期因为不规范开发带来的种种调试和维护成本。如果是小打小闹的代码，就无所谓了。</p>

<h3 id="section-2">代码规范的制定为什么这么难？</h3>

<p>原因众多，其中一个很重要的部分是团队每个人的口味和观点不尽相同。就代码风格而言，有人喜欢对内置类型变量i使用i++，有人坚持认为应该使用++i不管i是不是复杂类型。因此，制定代码规范需要在讨论之后最后拍板决定，这里面甚至需要独裁！是的，独裁！</p>

<h3 id="section-3">代码规范制定需要注意什么事项？</h3>

<p>如果代码规范限制太松，那么等于没有规范；如果太严，大大影响开发效率。这里面的尺度，需要根据项目需要、团队成员特点全面考量，进行取舍。</p>

<p>需要注意的是，没有任何一种代码规范是完美的。例如，在C++中，如果启用异常，那么代码的流程将会被各种异常处理中断，各种try catch throw让代码很不美观；如果禁用异常，也就是在开发的过程中不能使用异常特性，那么团队成员可能因为长期没有接触这项语言feature而造成知识和技能短板。</p>

<h3 id="section-4">代码风格举例</h3>

<p>举两个我认为比较重要、比较新鲜、比较有趣的代码风格。</p>

<p>1，使用引用需要判空吗？</p>

<p><code>c++
void f(int &amp;p);
void g(int *p);
</code></p>

<p>我们都知道，在g中，使用*p前需要对p是否为NULL进行判断，那么f呢？如果质量非常关键、代码安全非常重要的场景，那么实际上，也是需要的。因为调用者可能这样：
<code>c++
int *q = NULL;
//......
f(*q);
</code>
因此，需要在f里增加<code>if(NULL == &amp;p)</code>的判断。</p>

<p>2，级联if else语句。</p>

<p>首先看一个我个人认为不好的代码风格：</p>

<p><code>c++
int f(int a, int b)
{
  if (a &gt;= 1) {
    if (b &gt;= 1) {
      if (a &gt;= b) {
        //do sth
      } else {
        //error1
      }
    } else {
      //error2
    }
  } else {
    //error3
  }
}
</code>
这个函数的核心在于do sth部分。其实我们可以改写为级联if－else形式，如下：</p>

<p><code>c++
int f(int a, int b)
{
  if (a &lt; 1) {
    //error3
  } else if (b &lt; 1) {
    //error2
  } else if (a &lt; b) {
    //error1
  } else {
    //so, a&gt;=1 &amp;&amp; b&gt;=1 &amp;&amp; a&gt;=b
    //do sth
  }
}
</code>
是不是优美多了？前面只做一些错误处理、前期准备、参数检查等，最后的else分支做实实在在的功能性事情。</p>

<h2 id="code-review">Code Review</h2>

<h3 id="code-review-1">什么是Code Review？</h3>

<p>很多人把它翻译为代码审查，我觉得太政治味了。程序员尤其是新手写完代码后，可能会有风格问题（比如不符合团队的代码规范）、安全性问题(比如忘记指针判空)、优雅性问题(比如大量冗余代码)、正确性问题（比如算法设计错误），那么在发布代码到公共库之前，提交给师兄或者mentor，让他帮你review一下代码，并提出可能的问题和建议，让你好好修改。这样的过程，就叫做Code Review。</p>

<h3 id="section-5">我的天呐，那这不是很占用时间？</h3>

<p>是的。一个写代码，一个看代码，看代码的时间可能并不比全新写一份代码少。那么，这又是何必呢？</p>

<p>主要的原因有：</p>

<p>1，review确实占用了开发时间，然而开发，或者说写代码，其实只占很少的时间比例。很多时间花在debug、调试、写文档、需求分析、设计算法、维护等等上。</p>

<p>2，代码质量非常重要，这点时间投入是值得的。与其后期苦逼追bug，不如前期多投入点时间和人力。</p>

<p>3，培养新人，让新手更快成长。</p>

<h3 id="code-review-2">如何更好的执行Code Review</h3>

<p>这里给几点建议：</p>

<p>1，不走过场。走过场，还不如不要这个流程。</p>

<p>2，作为Reviewer，看不懂代码就把作者拉过来，当面询问，不要不懂装懂，也不要爱面子不好意思问。</p>

<p>3，作为Coder，心里要有感激之情。真的。不要得了便宜还卖乖，感恩reviewer，感激reviewer对自己的进步和成长所做出的贡献，所花费的心血。中国人里狼心狗肺、忘恩负义、不懂感恩的人还算少吗？</p>

<p>4，作为Coder，给Reviewer Review之前，请先做单元测试并确保通过，并自己尝试先整体看一遍自己本次提交的代码。注意，不要给别人提还没调试通过的代码，这是非常不尊重别人的表现。</p>

<h2 id="section-6">质量保证</h2>

<p>1，测试不是专属QA的活儿，对自己写的代码提供质量保证，是程序员的职责。QA要负责的，是系统的质量，不是模块的质量。</p>

<p>2，测试，需要意识，需要坚持。我发现C++程序员、前端程序员的测试意识或者说质量意识最强；数据科学家或者数据工程师的质量意识最差，很多人甚至不写测试用例。当然，这不怪他们，毕竟，有时候代码里有个bug，准确率和召回率会更高。</p>

<p>3，测试用例的编写和设计需要保证一定的代码覆盖率，力求让每个分支和流程的代码都走到，然后分析运行结果是否是符合期望的，不要只考虑正确路径上的那些分支。</p>

<p>4，测试用例的编写和设计力求全面，考虑到方方面面。以非常经典的二分搜索为例：</p>

<p>int binary_search(int *p, int n, int target, int &amp;idx);</p>

<p>binary_search函数返回值为0表示成功执行，输出参数idx返回target在有序数组p中(第一次出现)的位置，－1表示不存在。</p>

<p>那么测试用例至少应该涵盖：</p>

<ul>
  <li>
    <p>p为NULL的情况</p>
  </li>
  <li>
    <p>数组大小n分别为负数、0、1、2时情况</p>
  </li>
  <li>
    <p>数组p不是有序数组的情况</p>
  </li>
  <li>
    <p>target在数组中出现0次、1次、n次的情况</p>
  </li>
</ul>

<p>你是否都考虑到了呢？</p>

<p>4，有时候，自己书写测试用例显得刀耕火种，现在已经有很多辅助的工具，读者可以自行google一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++函数对象(function object)的应用]]></title>
    <link href="http://www.yebangyu.org/blog/2016/02/20/object-function-in-cpp/"/>
    <updated>2016-02-20T23:30:53+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/02/20/object-function-in-cpp</id>
    <content type="html"><![CDATA[<p>假如我们实现了这样的一个单向链表：
<code>c++
class LinkedListNode
{
  int data_;
  LinkedListNode *next_;
};
class LinkedList
{
  public:
    void insert(LinkedListNode* &amp;p);
    void del(LinkedListNode *p);
  private:
    LinkedListNode *head_;
};
</code>
<!--more--></p>

<p>其中insert将p插入到head_为头指针的链表中，而p对应的内存由外面分配好，调用的时候类似于这样：</p>

<p><code>c++
LinkedList list;
LinkedListNode *p = new LinkedListNode(2, NULL);
list.insert(p);
</code></p>

<p>其中，p可能是通过new得到，也可能是malloc出来。好，问题来了：</p>

<p>这个类的del函数应该如何实现呢？如果节点是new出来的，我们得delete；如果是malloc出来的，我们得使用配套的free。否则，行为就是undefined。而且，用户还可能实现了自己的定制的内存分配回收例程。</p>

<p>我们并不知道该内存是如何分配得到的。这就是问题所在。</p>

<p>解决方法是让用户将正确的、对应的、适配的资源释放例程传递进来，然而delete是expression，free是函数，更悲剧的是不同用户实现的资源回收函数原型不尽相同。如何做呢？</p>

<p>函数对象是解决这个问题的利器。我们可以这样：</p>

<p><code>c++
template&lt;typename CallBack&gt;
class LinkedList
{
  public:
    void insert(LinkedListNode* &amp;p);
    void del(LinkedListNode *p);
  private:
    LinkedListNode *head_;
};
</code></p>

<p>在del中：</p>

<p><code>c++
void del(LinkedListNode *p)
{
  //...
  LinkedListNode *prev = get_prev(p);
  prev-&gt;next_ = p-&gt;next_;
  CallBack cb;
  cb(p);//调用用户提供的资源回收例程
}
</code></p>

<p>用户需要实现自己的CallBack类的operator()成员函数。如下所示：</p>

<p><code>c++
class MyReclaimRoutine
{
  public:
    void operator() (LinkedListNode *p)
    {
      delete p; //free(p) ? my_release_func(p) ? all up to you!
    }
};
</code></p>

<p>然后就万事大吉了：</p>

<p><code>c++
LinkedList&lt;MyReclaimRoutine&gt; list;
LinkedListNode *p = new LinkedListNode(2, NULL);
list.insert(p);
list.del(p);//ok! delete p will be called
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下C++程序计时方法]]></title>
    <link href="http://www.yebangyu.org/blog/2016/01/07/timingcprograminlinux/"/>
    <updated>2016-01-07T23:02:14+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/01/07/timingcprograminlinux</id>
    <content type="html"><![CDATA[<p>最近简单学习了下<strong>Linux</strong>下<strong>C++</strong>程序计时的一些函数和方法，总结如下。没啥<strong>insight</strong>了。</p>

<p>方法一：</p>

<p>如果是想统计某个程序的运行时间，那么可以使用</p>

<pre><code>time ./a.out
</code></pre>

<!--more-->

<p>方法二：</p>

<p>如果是想对某个函数或者语句进行计时，那么有别的方法。比如说，<code>gettimeofday</code>函数。直接贴示例代码:</p>

<p><code>c++
#include &lt;sys/time.h&gt;
void f()
{
  //...
}
int main()
{
  struct timeval t1, t2;
  gettimeofday(&amp;t1, NULL);
  f();
  gettimeofday(&amp;t2, NULL);
  //那么函数f运行所花的时间为
  //deltaT = (t2.tv_sec-t1.tv_sec) * 1000000 + t2.tv_usec-t1.tv_usec 微秒
  return 0;
}
</code></p>

<p>不难看出，<code>gettimeofday</code>只能精确到微秒；如果想精确到纳秒呢？</p>

<p>方法三：</p>

<p><code>c++
#include &lt;time.h&gt;
void f()
{
  //...
}
int main()
{
  timespec t1, t2;
  clock_gettime(CLOCK_MONOTONIC, &amp;t1);
  f();
  clock_gettime(CLOCK_MONOTONIC, &amp;t2);
  //那么f所花时间为
  //deltaT = (t2.tv_sec - t1.tv_sec) * 10^9 + t2.tv_nsec - t1.tv_nsec 纳秒
  return 0;
}
</code></p>

<p>这里说的都是<strong>wall clock</strong>，如果想获得<strong>cpu</strong>执行时间，以及了解<code>clock_gettime</code>参数的解释和可能的取值，可以<strong>man</strong>一下。</p>
]]></content>
  </entry>
  
</feed>
