<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Yebangyu's Blog]]></title>
  <link href="http://www.yebangyu.org/atom.xml" rel="self"/>
  <link href="http://www.yebangyu.org/"/>
  <updated>2016-05-08T11:57:54+08:00</updated>
  <id>http://www.yebangyu.org/</id>
  <author>
    <name><![CDATA[Yebangyu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Treap：一种高效的高级数据结构]]></title>
    <link href="http://www.yebangyu.org/blog/2016/05/07/treappkskiplist/"/>
    <updated>2016-05-07T10:00:12+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/05/07/treappkskiplist</id>
    <content type="html"><![CDATA[<h2 id="section">写在最前</h2>

<p><a href="https://github.com/yebangyu/Yedis">Yedis</a>是一款高性能的nosql数据库，旨在能在某些方面替代Redis。它由不著名码农、秦汉史历史学家、本站站长Yebangyu同学在业余时间独立开发完成。</p>

<p>Github请访问<a href="https://github.com/yebangyu/Yedis">这里</a> ，Python客户端请点击<a href="https://github.com/yebangyu/Yedis/blob/master/src/client/yedis_client.py">这里</a></p>

<h2 id="treap">Treap</h2>

<p>Yedis也同样支持rank功能，但是所使用的数据结构是Treap(Redis使用的是Skip List)。这两种都是概率性的高级数据结构，具体性能依赖于随机数的选择。</p>

<p>那么，什么是Treap呢？</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/TreapAlphaKey.svg/440px-TreapAlphaKey.svg.png" alt="Treap" /></p>

<p>(图片来源于WikiMedia)</p>

<p>简单说来，Treap是这样的树：Treap中的每个节点至少包含key和优先级两个字段，其中key满足搜索树性质，优先级满足堆序性。如上图所示，数字是优先级字段，字母是key字段。其中优先级构成了一个大根堆。</p>

<p>也就是说，在Treap中，key组成了一个二叉搜索树，优先级组成了一个堆。所谓Treap = Tree + Heap。</p>

<!--more-->

<p>插入一个节点时，随机生成一个优先级。这时候可能堆序性被破坏，而这可以通过旋转来恢复。由于只可能有左右单旋转两种情形，因此它的代码编写比AVL树、Red-Black Tree要简单的多，并且可以证明旋转的期望次数小于2。</p>

<p>在Treap上的删除、插入、查找的期望时间复杂度都是O($lgn$)。</p>

<h2 id="treap-pk-skiplist">Treap PK SkipList</h2>

<h3 id="treap-1">Treap实现</h3>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
<span class="line-number">85</span>
<span class="line-number">86</span>
<span class="line-number">87</span>
<span class="line-number">88</span>
<span class="line-number">89</span>
<span class="line-number">90</span>
<span class="line-number">91</span>
<span class="line-number">92</span>
<span class="line-number">93</span>
<span class="line-number">94</span>
<span class="line-number">95</span>
<span class="line-number">96</span>
<span class="line-number">97</span>
<span class="line-number">98</span>
<span class="line-number">99</span>
<span class="line-number">100</span>
<span class="line-number">101</span>
<span class="line-number">102</span>
<span class="line-number">103</span>
<span class="line-number">104</span>
<span class="line-number">105</span>
<span class="line-number">106</span>
<span class="line-number">107</span>
<span class="line-number">108</span>
<span class="line-number">109</span>
<span class="line-number">110</span>
<span class="line-number">111</span>
<span class="line-number">112</span>
<span class="line-number">113</span>
<span class="line-number">114</span>
<span class="line-number">115</span>
<span class="line-number">116</span>
<span class="line-number">117</span>
<span class="line-number">118</span>
<span class="line-number">119</span>
<span class="line-number">120</span>
<span class="line-number">121</span>
<span class="line-number">122</span>
<span class="line-number">123</span>
<span class="line-number">124</span>
<span class="line-number">125</span>
<span class="line-number">126</span>
<span class="line-number">127</span>
<span class="line-number">128</span>
<span class="line-number">129</span>
<span class="line-number">130</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cm">/*</span>
</span><span class="line"><span class="cm"> * treap.h</span>
</span><span class="line"><span class="cm">*/</span>
</span><span class="line"><span class="cp">#ifndef YEDIS_TREAP_H_</span>
</span><span class="line"><span class="cp">#define YEDIS_TREAP_H_</span>
</span><span class="line"><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;time.h&gt;</span>
</span><span class="line"><span class="cp">#define YEDIS_INT32_MAX 2147483647</span>
</span><span class="line"><span class="cp">#define nullptr 0</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">YedisTreapNode</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">key</span><span class="p">;</span><span class="c1">//binary search tree</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
</span><span class="line">  <span class="n">YedisTreapNode</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
</span><span class="line">  <span class="n">YedisTreapNode</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">priority</span><span class="p">;</span><span class="c1">//max heap</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="k">class</span> <span class="nc">YedisTreap</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">init</span><span class="p">();</span>
</span><span class="line">  <span class="n">YedisTreapNode</span> <span class="o">*</span><span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">key</span><span class="p">);</span>
</span><span class="line">  <span class="kt">int</span> <span class="nf">insert</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
</span><span class="line"><span class="k">private</span><span class="o">:</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">insert_</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span><span class="p">,</span><span class="n">YedisTreapNode</span> <span class="o">*&amp;</span><span class="n">treap</span><span class="p">);</span>
</span><span class="line">  <span class="n">YedisTreapNode</span> <span class="o">*</span><span class="nf">left_rotation_</span><span class="p">(</span><span class="n">YedisTreapNode</span> <span class="o">*</span><span class="n">k1</span><span class="p">,</span> <span class="n">YedisTreapNode</span> <span class="o">*</span><span class="n">k2</span><span class="p">);</span>
</span><span class="line">  <span class="n">YedisTreapNode</span> <span class="o">*</span><span class="nf">right_rotation_</span><span class="p">(</span><span class="n">YedisTreapNode</span> <span class="o">*</span><span class="n">k1</span><span class="p">,</span> <span class="n">YedisTreapNode</span> <span class="o">*</span><span class="n">k2</span><span class="p">);</span>
</span><span class="line"><span class="k">private</span><span class="o">:</span>
</span><span class="line">  <span class="n">YedisTreapNode</span> <span class="o">*</span><span class="n">root_</span><span class="p">;</span>
</span><span class="line">  <span class="n">YedisTreapNode</span> <span class="o">*</span><span class="n">sentinel_</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="cp">#define INSERT(subtree1, substree2) \</span>
</span><span class="line"><span class="cp">   ret = insert_(key, value, treap-&gt;subtree1); \</span>
</span><span class="line"><span class="cp">   if (!ret &amp;&amp; treap-&gt;subtree1-&gt;priority &gt; treap-&gt;priority) { \</span>
</span><span class="line"><span class="cp">     treap = substree2##_rotation_(treap, treap-&gt;subtree1); \</span>
</span><span class="line"><span class="cp">   }</span>
</span><span class="line">
</span><span class="line"> <span class="kt">int</span> <span class="n">YedisTreap</span><span class="o">::</span><span class="n">init</span><span class="p">()</span>
</span><span class="line"> <span class="p">{</span>
</span><span class="line">   <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">   <span class="n">sentinel_</span> <span class="o">=</span> <span class="n">root_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span><span class="line">   <span class="n">YedisTreapNode</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span><span class="line">   <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">YedisTreapNode</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">YedisTreapNode</span><span class="p">)))))</span> <span class="p">{</span>
</span><span class="line">     <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line">   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">     <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">     <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">     <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span><span class="line">     <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">YEDIS_INT32_MAX</span><span class="p">;</span>
</span><span class="line">     <span class="n">sentinel_</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class="line">   <span class="p">}</span>
</span><span class="line">   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"> <span class="p">}</span>
</span><span class="line"> <span class="kt">int</span> <span class="n">YedisTreap</span><span class="o">::</span><span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
</span><span class="line"> <span class="p">{</span>
</span><span class="line">   <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">   <span class="k">if</span> <span class="p">(</span><span class="k">nullptr</span> <span class="o">==</span> <span class="n">sentinel_</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">     <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>
</span><span class="line">   <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">nullptr</span> <span class="o">==</span> <span class="n">root_</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">     <span class="n">YedisTreapNode</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">YedisTreapNode</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">YedisTreapNode</span><span class="p">)));</span>
</span><span class="line">     <span class="k">if</span> <span class="p">(</span><span class="k">nullptr</span> <span class="o">==</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">       <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line">     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">       <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
</span><span class="line">       <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span><span class="line">       <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span><span class="line">       <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
</span><span class="line">       <span class="n">sentinel_</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class="line">       <span class="n">root_</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class="line">     <span class="p">}</span>
</span><span class="line">   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">     <span class="n">ret</span> <span class="o">=</span> <span class="n">insert_</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">root_</span><span class="p">);</span>
</span><span class="line">   <span class="p">}</span>
</span><span class="line">   <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line"> <span class="p">}</span>
</span><span class="line"> <span class="kt">int</span> <span class="n">YedisTreap</span><span class="o">::</span><span class="n">insert_</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="n">YedisTreapNode</span> <span class="o">*&amp;</span><span class="n">treap</span><span class="p">)</span>
</span><span class="line"> <span class="p">{</span>
</span><span class="line">   <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">   <span class="k">if</span> <span class="p">(</span><span class="k">nullptr</span> <span class="o">==</span> <span class="n">treap</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">     <span class="k">if</span> <span class="p">(</span><span class="k">nullptr</span> <span class="o">==</span> <span class="p">(</span><span class="n">treap</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">YedisTreapNode</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">YedisTreapNode</span><span class="p">)))))</span> <span class="p">{</span>
</span><span class="line">       <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line">     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">       <span class="n">treap</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
</span><span class="line">       <span class="n">treap</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span><span class="line">       <span class="n">treap</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">treap</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span><span class="line">       <span class="n">srand</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
</span><span class="line">       <span class="n">treap</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">rand</span><span class="p">();</span>
</span><span class="line">     <span class="p">}</span>
</span><span class="line">   <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">     <span class="n">INSERT</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
</span><span class="line">   <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">     <span class="n">INSERT</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
</span><span class="line">   <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">     <span class="n">INSERT</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span><span class="c1">//duplicate elements</span>
</span><span class="line">   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">     <span class="n">INSERT</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span><span class="c1">//duplicate elements</span>
</span><span class="line">   <span class="p">}</span>
</span><span class="line">   <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line"> <span class="p">}</span>
</span><span class="line"> <span class="n">YedisTreapNode</span> <span class="o">*</span><span class="n">YedisTreap</span><span class="o">::</span><span class="n">left_rotation_</span><span class="p">(</span><span class="n">YedisTreapNode</span> <span class="o">*</span><span class="n">k1</span><span class="p">,</span> <span class="n">YedisTreapNode</span> <span class="o">*</span><span class="n">k2</span><span class="p">)</span>
</span><span class="line"> <span class="p">{</span>
</span><span class="line">   <span class="n">k1</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">k2</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
</span><span class="line">   <span class="n">k2</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">k1</span><span class="p">;</span>
</span><span class="line">   <span class="k">return</span> <span class="n">k2</span><span class="p">;</span>
</span><span class="line"> <span class="p">}</span>
</span><span class="line"> <span class="n">YedisTreapNode</span> <span class="o">*</span><span class="n">YedisTreap</span><span class="o">::</span><span class="n">right_rotation_</span><span class="p">(</span><span class="n">YedisTreapNode</span> <span class="o">*</span><span class="n">k1</span><span class="p">,</span> <span class="n">YedisTreapNode</span> <span class="o">*</span><span class="n">k2</span><span class="p">)</span>
</span><span class="line"> <span class="p">{</span>
</span><span class="line">   <span class="n">k1</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">k2</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
</span><span class="line">   <span class="n">k2</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">k1</span><span class="p">;</span>
</span><span class="line">   <span class="k">return</span> <span class="n">k2</span><span class="p">;</span>
</span><span class="line"> <span class="p">}</span>
</span><span class="line"> <span class="n">YedisTreapNode</span> <span class="o">*</span><span class="n">YedisTreap</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">key</span><span class="p">)</span>
</span><span class="line"> <span class="p">{</span>
</span><span class="line">   <span class="n">YedisTreapNode</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">root_</span><span class="p">;</span>
</span><span class="line">   <span class="k">while</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">     <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">       <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
</span><span class="line">     <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">       <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
</span><span class="line">     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">       <span class="k">break</span><span class="p">;</span>
</span><span class="line">     <span class="p">}</span>
</span><span class="line">   <span class="p">}</span>
</span><span class="line">   <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class="line"> <span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="cp">#endif </span><span class="cm">/* YEDIS_TREAP_H_ */</span><span class="cp"></span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>说明：</p>

<p>1，96-100行处理重复key的情形，为了不让某棵子树过分倾斜，我们选择根据priority的奇偶性来决定把重复key插入到哪棵子树。</p>

<p>2，通过设置一个具有最大优先级的sentinel节点，来简化处理和判断。</p>

<p>3，显然，递归地实现Treap比较方便和容易。</p>

<h3 id="section-1">测试程序</h3>

<p>本次PK的对象Skip List的代码，来自我的朋友<a href="http://weibo.com/fullofbull">我的上铺叫路遥</a>之前写的一个<a href="https://github.com/begeekmyfriend/skiplist/blob/master/skiplist.h">实现</a></p>

<p>测试程序则是在他之前写的<a href="https://github.com/begeekmyfriend/skiplist/blob/master/skiplist_test.c">文件</a>的基础上稍作修改。(主要是修改为更准确的计时方式)。</p>

<p>测试数据则是随机打乱的10,000,000个元素。</p>

<p>对于Treap的测试程序如下：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cm">/*</span>
</span><span class="line"><span class="cm"> * test_treap.cpp</span>
</span><span class="line"><span class="cm">*/</span>
</span><span class="line"><span class="cp">#include &quot;treap.h&quot;</span>
</span><span class="line"><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;time.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;iostream&gt;</span>
</span><span class="line"><span class="cp">#include &lt;vector&gt;</span>
</span><span class="line"><span class="cp">#include &lt;algorithm&gt;</span>
</span><span class="line"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class="line"><span class="cp">#define N 10000000</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span><span class="line">  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class="line">  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;generating data for test...&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">tmp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="c1">//通过random_shuffle打乱数据</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="n">random_shuffle</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">tmp</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span><span class="line">  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;generating data for test successfully...&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">  <span class="n">YedisTreap</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">YedisTreap</span><span class="p">();</span>
</span><span class="line">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">();</span>
</span><span class="line">  <span class="n">timespec</span> <span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">;</span>
</span><span class="line">  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;starting to insert data to treap&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t1</span><span class="p">);</span>
</span><span class="line">  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">p</span><span class="o">-&gt;</span><span class="n">insert</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t2</span><span class="p">);</span>
</span><span class="line">  <span class="kt">long</span> <span class="kt">long</span> <span class="n">cost1</span> <span class="o">=</span> <span class="p">(</span><span class="n">t2</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">t1</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000000000</span> <span class="o">+</span> <span class="n">t2</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="n">t1</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
</span><span class="line">  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Insertion takes &quot;</span><span class="o">&lt;&lt;</span><span class="n">cost1</span><span class="o">&lt;&lt;</span><span class="s">&quot;ns&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;starting to search data in treap&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t1</span><span class="p">);</span>
</span><span class="line">  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">YedisTreapNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;so bad&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t2</span><span class="p">);</span>
</span><span class="line">  <span class="kt">long</span> <span class="kt">long</span> <span class="n">cost2</span> <span class="o">=</span> <span class="p">(</span><span class="n">t2</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">t1</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000000000</span> <span class="o">+</span> <span class="n">t2</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="n">t1</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
</span><span class="line">  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Searching takes &quot;</span><span class="o">&lt;&lt;</span><span class="n">cost2</span><span class="o">&lt;&lt;</span><span class="s">&quot;ns&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>Skip List的测试程序如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cm">/*</span>
</span><span class="line"><span class="cm"> * test_skiplist.cpp</span>
</span><span class="line"><span class="cm">*/</span>
</span><span class="line"><span class="cp">#include&lt;stdio.h&gt;</span>
</span><span class="line"><span class="cp">#include&lt;stdlib.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;time.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;iostream&gt;</span>
</span><span class="line"><span class="cp">#include &lt;vector&gt;</span>
</span><span class="line"><span class="cp">#include &lt;algorithm&gt;</span>
</span><span class="line"><span class="cp">#include &quot;skiplist.h&quot;</span>
</span><span class="line"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class="line"><span class="cp">#define N 10000000</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span><span class="line">  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class="line">  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;generating data for test...&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">tmp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="n">random_shuffle</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">tmp</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span><span class="line">  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;generating data for test successfully...&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">  <span class="k">struct</span> <span class="n">skiplist</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">skiplist_new</span><span class="p">();</span>
</span><span class="line">  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;starting to insert data to skip list&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">  <span class="n">timespec</span> <span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">;</span>
</span><span class="line">  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t1</span><span class="p">);</span>
</span><span class="line">  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">skiplist_insert</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t2</span><span class="p">);</span>
</span><span class="line">  <span class="kt">long</span> <span class="kt">long</span> <span class="n">cost1</span> <span class="o">=</span> <span class="p">(</span><span class="n">t2</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">t1</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000000000</span> <span class="o">+</span> <span class="n">t2</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="n">t1</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
</span><span class="line">  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Insertion takes &quot;</span><span class="o">&lt;&lt;</span><span class="n">cost1</span><span class="o">&lt;&lt;</span><span class="s">&quot;ns&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;starting to search data in skip list&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t1</span><span class="p">);</span>
</span><span class="line">  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">skipnode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">skiplist_search</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;so bad&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t2</span><span class="p">);</span>
</span><span class="line">  <span class="kt">long</span> <span class="kt">long</span> <span class="n">cost2</span> <span class="o">=</span> <span class="p">(</span><span class="n">t2</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">t1</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000000000</span> <span class="o">+</span> <span class="n">t2</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="n">t1</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
</span><span class="line">  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Searching takes &quot;</span><span class="o">&lt;&lt;</span><span class="n">cost2</span><span class="o">&lt;&lt;</span><span class="s">&quot;ns&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">  <span class="n">skiplist_delete</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>编译链接这两个测试程序时，请记得加<code>-lrt</code>选项。</p>

<h3 id="section-2">测试结果</h3>

<p>测试环境是Ubuntu 14.04 64位系统 + 16GB内存 + gcc4.8</p>

<p>未开启优化：</p>

<p>SkipList：插入，27783017437ns = 27s，查找，30369272721ns = 30s</p>

<p>Treap：插入，36651505605ns = 36s，查找，15831823811ns = 15s</p>

<p>开启O3优化后：</p>

<p>SkipList：插入，25877643715ns = 25s，查找，28741237934ns = 28s</p>

<p>Treap：插入，35317025584ns = 35s，查找，14883111063ns = 14s</p>

<p>可以看出在查找上，Treap的性能确实是可圈可点的。</p>

<h2 id="further-thinking">Further Thinking</h2>

<p>1，为什么Treap的查找会这么高效？</p>

<p>针对本次测试数据，对find函数进行统计分析，发现查找的平均深度是29，而lg(10000000） = 23.2。也就是说本次测试时平均深度是$1.26lgn$。BTW，根据分析，AVL树的最大深度不会超过$1.44lgn$，对于Red-Black Tree，这个值大概在$2lg(n+1)$。</p>

<p>2，如何优化Treap的插入性能？</p>

<p>可能可以实施的点包括优化随机数生成程序、将递归改为非递归实现、优化分支预测等。具体怎么做？无从下手？建议您阅读我的<a href="http://www.yebangyu.org/blog/2016/04/22/optimization/">这篇</a>博客。</p>

<h2 id="section-3">参考文献</h2>

<p>1，Mark Allen Weiss的《Data Structures &amp; Algorithm Analysis in C++》中介绍了Treap，这也是我第一次接触和知道Treap的地方。</p>

<p>2，《Introduction to Algorithms》中在某个章节里，以习题的形式介绍了Treap。</p>

<p>3，之前陈利人童鞋在微博上推荐了某大学的某学生写的Treap资料，他们都说好。我没看，也没兴趣。</p>

<p>4，<a href="http://www.cepis.org/upgrade/files/full-2004-V.pdf">A Disquisition on The Performance Behaviour of Binary Search Tree Data Structures</a> 这篇论文对常见的平衡树进行了全面的实验性分析，强烈推荐。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[论汉武帝独尊儒术]]></title>
    <link href="http://www.yebangyu.org/blog/2016/05/01/hanwudi/"/>
    <updated>2016-05-01T12:27:57+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/05/01/hanwudi</id>
    <content type="html"><![CDATA[<p>汉武帝为什么独尊儒术？</p>

<p>在讨论这个问题前，先让我们回忆一个非常基本的常识，还是不厌其烦的交待两个人物的关系：汉武帝和窦太后。窦太后是汉文帝的老婆，汉景帝的妈妈，汉武帝的奶奶。</p>

<p><img src="http://www.art-child.com/uploads/allimg/160322/352-16032211321SN.jpg" alt="窦太后" /></p>

<p>汉武帝为什么独尊儒术呢？大家都说，这是因为汉武帝推崇并认可儒家学说。然而，以我个人的浅见，汉武帝其实并不是多么喜欢儒家思想，也不懂儒家学说。</p>

<!--more-->

<p>试看他做的这么多事情，有哪一件是按照儒家学说来做的？建造的宫殿非常奢侈，对外连年发动战争，其实都是和儒家思想背道而驰的。</p>

<p>那么他为什么独尊儒术呢？我的看法是有三个原因：1，对窦太后的报复。2，社会形势所使然。3，儒家学说满足了他的某种需求。</p>

<p>先说第一点。</p>

<p>我们知道，窦太后是汉武帝的奶奶，汉景帝的老妈。我们知道，自从西周封建后，皇位继承使用的是嫡长子制度。然而，景帝时，窦太后就三番五次要汉景帝死后传位给她的小儿子、汉景帝的弟弟、梁孝王刘武。这种思想不能说是奇葩，然而在封建社会也是让人大吃一惊的。所幸后面发生了一系列的事情，汉武帝才当上了皇帝。这当然很不容易，因为汉武帝本身不是嫡长子，甚至不是皇后所生。</p>

<p>汉武帝上台后，窦太后辅政。说来也是有意思，汉景帝为什么在临死的时候会让他的老妈辅政呢？这里面的原因其实很复杂。我们知道西汉初年是采用一种虚君实相的制度：皇帝只作为国家元首，而实事都是宰相做的。在西汉，宰相不仅重要，而且很有实权，这其实是很危险的，汉景帝估计是考虑到了这个问题。</p>

<p>外戚就一定安全吗？也不是。然而当时的人对这个还没有深刻的认识。有人说，不是吧，吕后不就是一个活生生的教训吗？然而，当时的人只会认为是吕后不好，而不是外戚的制度不好。</p>

<p>窦太后是笃信黄老的人。我们知道，在西汉初年，国家的政治意识形态是道家思想（注意，是道家，不是道教。这两者风马牛不相及）。这也是有社会背景和根据的。刘邦打下天下时，因为多年的战争，百姓苦逼，生产力低下，当务之急就是发展和生产。因此道家的无为思想就很合适了。所谓<code>治大国者，若烹小鲜</code>，就是这个时期的人的普遍思想。</p>

<p>汉武帝没有选择窦太后推崇的道家思想，也没有选择法家思想。然而，他实际上是表面儒家、实际法家。这个后面会再说。</p>

<p>所以你不难理解为什么汉武帝临死前居然杀了汉昭帝的亲生母亲，大概是对外戚干政深恶痛绝了，然而却立了霍光、金日磾等四位辅政大臣。这其实也是不好的，别以为霍光真的是和伊尹一样，这个我们也以后再说。</p>

<p>现在说第二个原因，社会形势所使然。</p>

<p>上文说过，西汉初年，国家的意识形态是道家，这是和社会形势和背景相关的。那么到了中汉呢？发展到了一定的程度，再继续用道家思想，恐怕不灵了吧？这时候就要改革，而论到改革，自然是儒家思想最擅长了。所以说，这也是当然社会形势和背景所使然。不以人的意志为转移的。</p>

<p>当时儒家和道家的争论已经很普遍，说明很多人已经开化。有一次，汉景帝召开一次会议，讨论汤武革命问题。所谓汤武革命，就是商汤灭掉夏桀，周武王灭掉殷纣王。都是因为君主暴虐无道，臣子替天行道灭了主子。</p>

<p>言外之意，当君主无道时，作为臣子，是否可以干掉他呢？</p>

<p>讨论会上，大家的观点不一。道家人物认为不对，君就是君，臣就是臣，君主再无道，臣子也不能干掉主子。这是造反。</p>

<p>但是儒家人物就认为这是合法。儒家代表人物辕固认为，按照这个逻辑，难道汉高祖刘邦灭了秦王朝也是不对的？</p>

<p>这就让人两难了。不过这里似乎有一个问题：儒家不是强调奴性吗，奇怪，这里它怎么会支持君主无道时臣子可以反抗呢？这还是儒家思想吗？</p>

<p>其实很多人对儒家思想了解和认识不够，总以为儒家思想是为统治者服务的，让老百姓和大臣做牛做马，甚至做走狗。然而，实际上并不是这样。诸位不是读过《孟子》吗？《孟子》里说，<code>民为贵，社稷次之，君为轻</code>。其实就是强调民权的。更进一步，《孟子》里说，<code>君之视臣如土芥，则臣视君如寇仇</code>。<code>寇仇，何服之有？</code>，其实上，就是承认了当君无道时，臣子其实是没有尽忠的义务的，是有自卫的权利的。</p>

<p>说的远了。也就是说，从这次的辩论会来说，儒家思想已经在当时渐渐抬头（虽然后来辕固差点被窦太后给喂（野）猪了）。加上当时的社会背景，自然儒家思想被重用，也是非常自然而然的事了。历史潮流，岂人事哉？</p>

<p>第三点，就是儒家思想满足了汉武帝的某种需求。什么需求？汉武帝是一个非常讲究排场和形式主义的人。而我们知道，儒家是出自礼官的，孔子就是推崇周公所创立的礼乐文化制度的，制礼作乐，这个是儒家擅长的。因此，汉武帝看重儒家。然而前面说过，汉武帝并不是真正的推崇和了解儒家思想，他care的是改正朔、易服色之类的礼仪制度，对于董仲舒提出的“限田”等策略都没有采纳。</p>

<p><img src="http://blogfile.ifeng.com/uploadfiles/blog_attachment/1107/13/1298913_2fae634cbac0898d770552633ccfb518.jpg" alt="汉武帝" /></p>

<p>汉武帝表面尊儒，实际上实行的是法家的那一套。我有几个朋友，对先秦诸子思想存在误读，非常深的误解，以为法家就是好的，儒家就是奴性、统治者服务。然而实际上并不是。所谓法家思想，是对老百姓采取高压统治，是很push的，老百姓是受苦的。试看武帝之前并没有什么起义，而武帝之后起义较多就可以得知。</p>

<p>最好的制度，我个人认为，应该是汉宣帝（刘病已）采取的<code>霸王道杂之</code>的方法。霸，也就是法家。王，也就是儒家。意思是，对官僚阶级，采用法家，施加督责，对百姓，采取儒家制度，仁爱制度。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction To Performance Optimization]]></title>
    <link href="http://www.yebangyu.org/blog/2016/04/22/optimization/"/>
    <updated>2016-04-22T23:13:13+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/04/22/optimization</id>
    <content type="html"><![CDATA[<h2 id="section">写在最前</h2>

<p>本文针对<strong>C++</strong>和<strong>linux</strong>环境，但是思想和方法，却对其他语言和环境同样适用。很可供参考的。</p>

<h2 id="section-1">优化前</h2>

<p>1，确定优化是必须要做的。</p>

<p>如果程序已经跑的足够快了，内存使用也足够省了，那么完全没有优化的必要。什么是足够呢？能够满足当前的业务和需求。因此，如果不是绝对必要，不要优化。</p>

<p>这是因为虽然优化不是万恶之源，但是优化可能会带来问题。为了提升一点点性能就得绞尽脑汁、辗转反侧；它可能让之前只需要一两行逻辑很清晰的代码，变成很难理解的高度优化的实现。优化很多时候某种程度上让代码可读性和可维护性变差。</p>

<p>2，确定该做的优化都做了</p>

<!--more-->

<p>有两个方法可以免费地、快速地提高效率：</p>

<p>第一个是使用<strong>release</strong>模式。如果您的程序在<strong>debug</strong>模式下表现不佳，那么可以尝试使用<strong>release</strong>模式进行编译链接。一般说来，这也是发布程序的默认模式。</p>

<p>第二是开启编译器优化。例如<strong>g++</strong>就提供了多个级别的优化选项，一般使用<strong>O2</strong>。</p>

<p>3，确定做了优化前的准备工作</p>

<p>最重要的一点是对程序的性能进行详细分析，找出瓶颈段<strong>（hot spot</strong>）。这很重要，否则，可能导致在错误的方向上越走越远。例如一个程序由函数<strong>f</strong>和<strong>g</strong>构成，<strong>f</strong>花费了<strong>2s</strong>，<strong>g</strong>花费了<strong>100ns</strong>，那您把<strong>g</strong>从<strong>100ns</strong>优化为<strong>20ns</strong>，对系统又有什么帮助呢？<strong>f</strong>才是大头啊。</p>

<p>因此，这里就会有三个问题：</p>

<p>第一，如何定位程序瓶颈段？</p>

<p>要是有一个工具，能够告诉我系统模块的开销比例，那就太好了。有这样的工具吗？有的。<strong>Linux</strong>下的<strong>perf</strong>就是。<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-perf1/">这里</a>是对<strong>perf</strong>非常好的<strong>tutorial</strong>，强烈建议初学者阅读。简单说来，一条命令即可：</p>

<pre><code>sudo perf record -g ./yourprograme
</code></pre>

<p>第二，我想给我的程序的某个函数计时，应该怎么做？</p>

<p>有很多方法，强烈建议您阅读我的<a href="http://www.yebangyu.org/blog/2016/01/07/timingcprograminlinux/">这篇</a>博客，很可供参考。我个人比较喜欢用<strong>timespec</strong>，原因是：知道它的人不多；它可以精确到纳秒；它不受系统时钟的影响（<strong>gettimeofday</strong>显然会，因为它就是读取系统时钟嘛）。</p>

<p>第三，优化后，函数变快了，系统变快了多少？</p>

<p>哦，回忆一下我们本科计算机体系结构里的<strong>Amdahl</strong>定律。如果您没学过这个定律，或者早已还给老师，那么<a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">这里</a>的内容可能对您有帮助。</p>

<h2 id="section-2">优化中</h2>

<p>一旦确定要优化，并且定位了瓶颈段，那么就是想尽一切办法进行加速了。个人总结的一些比较有效的思路和方法：</p>

<p>0，<strong>cache friendly access pattern</strong></p>

<p>尽可能利用<strong>cache</strong>，编写<strong>cache friendly</strong>代码。例子，比如说非常著名的二维数组按行按列访问问题。</p>

<p>1，算法和数据结构层面</p>

<p>使用合适的、高效的数据结构和算法，往往能带来很大的提升。不过，前提是，您需要对您的需求进行认真分析。<strong>find、search、insert、successor、del、min、max</strong>这些操作，哪些是您期望需要非常高效的？哪些操作是您业务里经常出现的？</p>

<p>您需要对以下数据结构和算法有所了解：</p>

<p>哈希表：<strong>O(1)</strong>期望查找时间让它常常成为除了数组之外的首选，尤其是当查找非常关键时。只知道<strong>Separate Chaining</strong>和<strong>Open Addressing</strong>？那您<strong>out</strong>了。建议您阅读我的<a href="http://www.yebangyu.org/blog/2015/12/19/cuckoo-hashing/">这篇</a>讲解<strong>cuckoo hashing</strong>的博客。</p>

<p>跳表：说到<strong>O(lgn)</strong>的<strong>insert、find、del</strong>，很多人想到二叉搜索树，由于非平衡的二叉搜索树有退化为<strong>O(n)</strong>的风险，因此很多场景需要平衡树。<strong>B</strong>树？红黑树？太<strong>heavy</strong>了。有时候，您需要跳表，真的，很需要。它足够简单，而且很多时候就能满足您的需求。除此之外，<strong>Treap</strong>也是一种随机的数据结构，我实现的大规模分布式数据库<a href="https://github.com/yebangyu/Yedis">Yedis</a>里就有提供相应的实现，以后会放出。</p>

<p><strong>Sunday</strong>算法：字符串匹配里，<strong>KMP</strong>算法是大名鼎鼎了。谁让<strong>Knuth</strong>是大佬呢？可是，您是否知道<strong>Sunday</strong>算法？<strong>Sunday</strong>算法什么时候会比<strong>KMP</strong>高效而且高效地多？</p>

<p><strong>string.h</strong>里提供的算法：包括<strong>memcmp、memcpy、memmem</strong>（我第一次知道<strong>memmem</strong>是从我的主管杨志丰先生那儿）等。当您想手工实现这些函数，正在写一大堆<strong>while</strong>循环时，请优先选择这些库函数。</p>

<p>排序算法：快速排序，非常常见、常用。那么，如何编写一个高效的快速排序？建议您阅读我的<a href="http://www.yebangyu.org/blog/2016/03/09/quicksort/">这篇</a>博客。</p>

<p>2，将小但是频繁调用的函数内联。注意，<strong>gcc</strong>有提供强制内联的<strong>feature</strong>，也就是<code>__attribute__((always_inline))</code></p>

<p>3，为分支预测适当加上<strong>likely</strong>或者<strong>unlikely</strong>。请注意，<strong>if</strong>语句并不可怕，可怕的是分支预测失败。这正和锁并不可怕一样，因为加锁和释放锁其实很快，可怕的是锁冲突。所以，您需要了解这两组宏：</p>

<pre><code>#define  likely(x)        __builtin_expect(!!(x), 1) 
#define  unlikely(x)      __builtin_expect(!!(x), 0) 
</code></pre>

<p>4，消除<strong>if</strong>语句。比如说如下代码：</p>

<pre><code>if (a &gt; 0 ) b += 2; else b+= 1;
</code></pre>

<p>那么可以消除为<code>b += 1 + (a &gt; 0);</code></p>

<p>5，查表法。将反复使用的、不大的、静态的数据事先计算好，存在表格里，需要的时候，直接去查，避免计算。</p>

<p>6，避免重复计算。很多计算只需要执行一次，比如说非常著名的</p>

<pre><code>for (int i = 0; i &lt; strlen(a); i++) do sth;
</code></pre>

<p>其中<code>strlen(a)</code>可以事先计算好，用一个变量存放即可。</p>

<p>还有很多很多。就看您的知识面和经验了。</p>

<p>有一个错误的想法，很值得在这里说。很多资料上写着：用移位代替乘除法。因此很多人的代码里充斥着大量的<code>&gt;&gt;1</code> 以及 <code>&lt;&lt;1</code>，美其名曰性能优化。</p>

<p>事实上，现在的编译器很聪明了，一点都不傻，不信您可以直接写<code>a / 2</code> 然后看看开启<strong>-O2</strong>选项后的汇编代码。结果会让您赞叹的。上面的左移一位、右移一位没有任何必要。</p>

<p>正常情况下，请按照逻辑需要直接写代码。现代编译器真的已经很牛逼了。因此，您应该重点关注算法、<strong>Cache</strong>、分支预测等层面。</p>

<h2 id="section-3">优化后</h2>

<p>优化后，请记得再次对您的程序进行<strong>profiling</strong>，确保优化是有效的。</p>

<p>别偏听偏信，别坚信<strong>KMP</strong>一定比暴力算法快，别盲信教科书、博客、资料里的说法，别跪舔大佬！请实际测试！测试！！再测试！！！</p>

<p>一切以您的环境、以您的系统、以您的测试为准。没有权威。</p>

<h2 id="section-4">参考资料</h2>

<p>专门针对<strong>C++</strong>和<strong>Linux</strong>的优化的书，不多。但是有一些零碎的、七七八八的资料，编程珠玑啊，深入理解计算机系统啊，还有过几个月会出的<strong>optimized c++</strong>啊等等。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[String Literal In C++]]></title>
    <link href="http://www.yebangyu.org/blog/2016/04/10/stringliteralincpp/"/>
    <updated>2016-04-10T22:05:21+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/04/10/stringliteralincpp</id>
    <content type="html"><![CDATA[<p>最近被一个很基本的知识点给咬伤，虽然之前知道这个问题，但是写代码的时候不小心还是容易犯错。简单记录一下。</p>

<h2 id="section">提出问题</h2>

<p>之前，代码里拥有如下数组：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">COLORS</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;red&quot;</span><span class="p">,</span>
</span><span class="line">                         <span class="s">&quot;black&quot;</span><span class="p">,</span>
</span><span class="line">                         <span class="s">&quot;green&quot;</span>
</span><span class="line">                        <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>现在需要以追加的形式，添加一个yellow的颜色。粗心之下，我写成了：</p>

<!--more-->

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">COLORS</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;red&quot;</span><span class="p">,</span>
</span><span class="line">                         <span class="s">&quot;black&quot;</span><span class="p">,</span>
</span><span class="line">                         <span class="s">&quot;green&quot;</span>
</span><span class="line">                         <span class="s">&quot;yellow&quot;</span>
</span><span class="line">                        <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在某处代码，我使用了COLORS[3]，类似于</p>

<p><code>cout&lt;&lt;COLORS[3]&lt;&lt;endl;</code></p>

<p>程序执行后，就崩溃了。</p>

<h2 id="section-1">分析问题</h2>

<p>问题出在，在追加的代码中的第4行，漏掉了一个逗号！！！正确的形式应该是：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">COLORS</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;red&quot;</span><span class="p">,</span>
</span><span class="line">                         <span class="s">&quot;black&quot;</span><span class="p">,</span>
</span><span class="line">                         <span class="s">&quot;green&quot;</span><span class="p">,</span> <span class="c1">//这里应该有个逗号！！！</span>
</span><span class="line">                         <span class="s">&quot;yellow&quot;</span>
</span><span class="line">                        <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在没有逗号下，编译器将”green”和”yellow”当做一个字符串，也就是”greenyellow”，因此，COLORS[2]其实是”greenyellow”，而COLORS[3]是未显式初始化的，为NULL。因此使用COLORS[3]程序崩溃。</p>

<h2 id="section-2">解决问题</h2>

<p>上面已经解决了问题。这里小小补充下:</p>

<p>在C++中，如下几种形式结果是一样的，表示的是同一个字符串”hello, world” ：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="s">&quot;hello, world&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="s">&quot;hello, &quot;</span>
</span><span class="line"><span class="s">&quot;world&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="s">&quot;hello, \</span>
</span><span class="line"><span class="s">world&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="s">&quot;hello, &quot;</span>  <span class="s">&quot;w&quot;</span>  <span class="s">&quot;orld&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Yedis源码解析之itoa实现]]></title>
    <link href="http://www.yebangyu.org/blog/2016/04/04/itoa-in-yedis/"/>
    <updated>2016-04-04T12:37:06+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/04/04/itoa-in-yedis</id>
    <content type="html"><![CDATA[<h2 id="section">写在最前</h2>

<p><a href="https://github.com/yebangyu/Yedis">Yedis</a>是一款高性能的nosql数据库，旨在能在某些方面替代Redis。它由不著名码农、秦汉史历史学家、本站站长Yebangyu同学在业余时间独立开发完成。</p>

<p>Github请访问<a href="https://github.com/yebangyu/Yedis">这里</a> ，Python客户端请点击<a href="https://github.com/yebangyu/Yedis/blob/master/src/client/yedis_client.py">这里</a></p>

<h2 id="section-1">提出问题</h2>

<p>如何用C/C++实现正确的、可移植的、高效的、对所有整数都work的itoa函数？</p>

<p>原型如下</p>

<p><code>int itoa(char *buffer, int64_t value);</code></p>

<p>将value转为字符串后存在buffer中，返回字符串的长度。</p>

<!--more-->

<h2 id="section-2">分析问题</h2>

<p>这还不容易么？很容易写出这样的代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">int</span> <span class="nf">itoa</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">value</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int64_t</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span><span class="line">  <span class="k">do</span> <span class="p">{</span>
</span><span class="line">    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">+</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
</span><span class="line">    <span class="n">tmp</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class="line">    <span class="o">++</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
</span><span class="line">  <span class="k">if</span><span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="n">p</span> <span class="o">-</span> <span class="n">buffer</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这个实现，有什么问题？问题是显而易见的：当value为负数时，在第6行，例如value = -123，如果tmp % 10 = -3，而-3 + ‘0’并不是期望的结果。</p>

<p>有些人说，这还不容易吗？把负数都搞成正数，用它的绝对值来计算，不就行了吗？于是很容易写出这样的代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">int</span> <span class="nf">itoa</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">value</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int64_t</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="nl">value</span> <span class="p">:</span> <span class="n">value</span><span class="p">;</span>
</span><span class="line">  <span class="k">do</span> <span class="p">{</span>
</span><span class="line">    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">+</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
</span><span class="line">    <span class="n">tmp</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class="line">    <span class="o">++</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
</span><span class="line">  <span class="k">if</span><span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="n">p</span> <span class="o">-</span> <span class="n">buffer</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>还是有问题，注意第4行。回忆一下本科时候所学的计算机组成原理，我们知道，对于有符号整数，它的最大值和最小值是不对称的，绝对值差1。其中，64位有符号整数的范围为[-9223372036854775808, 9223372036854775807]</p>

<p>因此，在第4行，如果value是INT64_MIN，对它求绝对值-value的结果其实已经超出了64位有符号整数可以表示的范围，这里已经溢出了！！！</p>

<p>哦哦，这好办，对INT64_MIN单独处理行不行？</p>

<p>行，但是代码会非常不优雅了。</p>

<p>Matthew Wilson大神的Efficient Integer to String Conversions文章里，使用如下的trick，来处理这些问题。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">int</span> <span class="nf">itoa</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">value</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">digits</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;9&#39;</span><span class="p">,</span><span class="sc">&#39;8&#39;</span><span class="p">,</span><span class="sc">&#39;7&#39;</span><span class="p">,</span><span class="sc">&#39;6&#39;</span><span class="p">,</span><span class="sc">&#39;5&#39;</span><span class="p">,</span><span class="sc">&#39;4&#39;</span><span class="p">,</span><span class="sc">&#39;3&#39;</span><span class="p">,</span><span class="sc">&#39;2&#39;</span><span class="p">,</span><span class="sc">&#39;1&#39;</span><span class="p">,</span><span class="sc">&#39;0&#39;</span><span class="p">,</span><span class="sc">&#39;1&#39;</span><span class="p">,</span><span class="sc">&#39;2&#39;</span><span class="p">,</span><span class="sc">&#39;3&#39;</span><span class="p">,</span><span class="sc">&#39;4&#39;</span><span class="p">,</span><span class="sc">&#39;5&#39;</span><span class="p">,</span><span class="sc">&#39;6&#39;</span><span class="p">,</span><span class="sc">&#39;7&#39;</span><span class="p">,</span><span class="sc">&#39;8&#39;</span><span class="p">,</span><span class="sc">&#39;9&#39;</span><span class="p">};</span>
</span><span class="line">  <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">zero</span> <span class="o">=</span> <span class="n">digits</span> <span class="o">+</span> <span class="mi">9</span><span class="p">;</span>
</span><span class="line">  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int64_t</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span><span class="line">  <span class="k">do</span> <span class="p">{</span>
</span><span class="line">    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">zero</span><span class="p">[</span><span class="n">tmp</span> <span class="o">%</span> <span class="mi">10</span><span class="p">];</span><span class="c1">//下标可能是负数</span>
</span><span class="line">    <span class="n">tmp</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class="line">    <span class="o">++</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
</span><span class="line">  <span class="k">if</span><span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="n">p</span> <span class="o">-</span> <span class="n">buffer</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这下没问题了吧？有。</p>

<p>问题出在第8、9行。</p>

<p>举个例子，请问，-123 / 10结果是多少？-123 % 10 呢？</p>

<p>因为<code>-123 = (-12) * 10 + (-3)</code> 因此<code>-123 / 10 = -12</code>，同时<code>-123 % 10 = -3</code></p>

<p>但是！</p>

<p>因为<code>-123 =(-13) * 10 + 7</code> 因此<code>-123 / 10 = -13</code>，同时<code>-123 % 10 = 7</code></p>

<p>两种可能的结果？事实上，C++98和C++03标准并没有对被除数和除数不都为正数时的情形进行明确的说明，第8、9行的结果是未定义的，是很不可移植的。</p>

<p>如果在某个具体的实现下，<code>-123 / 10 = -13</code>，并且 <code>-123 % 10 = 7</code> ，那么以上代码结果不对。</p>

<h2 id="section-3">解决问题</h2>

<p>Yedis中实现了itoa，代码在<code>src/server/yedis_order.cpp</code></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">YEDIS_MUST_INLINE</span> <span class="kt">int64_t</span> <span class="nf">int2char</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">value</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">remainder_offset</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="sc">&#39;9&#39;</span><span class="p">,</span> <span class="sc">&#39;8&#39;</span><span class="p">,</span> <span class="sc">&#39;7&#39;</span><span class="p">,</span> <span class="sc">&#39;6&#39;</span><span class="p">,</span> <span class="sc">&#39;5&#39;</span><span class="p">,</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="sc">&#39;3&#39;</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span> <span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="sc">&#39;3&#39;</span><span class="p">,</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="sc">&#39;5&#39;</span><span class="p">,</span> <span class="sc">&#39;6&#39;</span><span class="p">,</span> <span class="sc">&#39;7&#39;</span><span class="p">,</span> <span class="sc">&#39;8&#39;</span><span class="p">,</span> <span class="sc">&#39;9&#39;</span> <span class="p">},</span><span class="c1">//正数</span>
</span><span class="line">
</span><span class="line">                                                <span class="p">{</span> <span class="sc">&#39;9&#39;</span><span class="p">,</span> <span class="sc">&#39;8&#39;</span><span class="p">,</span> <span class="sc">&#39;7&#39;</span><span class="p">,</span> <span class="sc">&#39;6&#39;</span><span class="p">,</span> <span class="sc">&#39;5&#39;</span><span class="p">,</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="sc">&#39;3&#39;</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span> <span class="sc">&#39;9&#39;</span><span class="p">,</span> <span class="sc">&#39;8&#39;</span><span class="p">,</span> <span class="sc">&#39;7&#39;</span><span class="p">,</span> <span class="sc">&#39;6&#39;</span><span class="p">,</span> <span class="sc">&#39;5&#39;</span><span class="p">,</span> <span class="sc">&#39;4&#39;</span><span class="p">,</span> <span class="sc">&#39;3&#39;</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="sc">&#39;1&#39;</span> <span class="p">}</span> <span class="p">};</span><span class="c1">//负数</span>
</span><span class="line">
</span><span class="line">  <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">quotient_offset</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span><span class="c1">//正数</span>
</span><span class="line">
</span><span class="line">                                               <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="p">}</span> <span class="p">};</span><span class="c1">//负数								  </span>
</span><span class="line">  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int64_t</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line">  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">digit</span> <span class="o">=</span> <span class="n">remainder_offset</span><span class="p">[</span><span class="n">flag</span><span class="p">]</span> <span class="o">+</span> <span class="mi">9</span><span class="p">;</span>
</span><span class="line">  <span class="k">const</span> <span class="kt">bool</span> <span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="n">quotient_offset</span><span class="p">[</span><span class="n">flag</span><span class="p">]</span> <span class="o">+</span> <span class="mi">9</span><span class="p">;</span>
</span><span class="line">  <span class="k">do</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
</span><span class="line">    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">digit</span><span class="p">[</span><span class="n">remainder</span><span class="p">];</span>
</span><span class="line">    <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">/</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="n">remainder</span><span class="p">];</span>
</span><span class="line">    <span class="o">++</span><span class="n">p</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
</span><span class="line">  <span class="k">if</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="n">p</span> <span class="o">-</span> <span class="n">buffer</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>通过两个二维数组，很巧妙、完美的解决了这个问题。它对于[INT64_MIN, INT64_MAX]中的任何一个数都是正确的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Yedis: A High Performance Nosql]]></title>
    <link href="http://www.yebangyu.org/blog/2016/03/31/yedis01/"/>
    <updated>2016-03-31T23:53:16+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/03/31/yedis01</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/yebangyu/Yedis">Yedis</a>是一款高性能的nosql数据库，旨在能在某些方面替代Redis。它由不著名码农、秦汉史历史学家、本站站长Yebangyu同学在业余时间独立开发完成。</p>

<p>Github请访问<a href="https://github.com/yebangyu/Yedis">这里</a> ，很烂的一个Python客户端请点击<a href="https://github.com/yebangyu/Yedis/blob/master/src/client/yedis_client.py">这里</a>。</p>

<p>Yedis名称由来：Yedis = Yebangyu + Redis</p>

<h2 id="section">动机</h2>

<p>开发Yedis的主要原因是想通过这个项目，进一步提高和熟悉C++服务器端开发相关的技术和知识。</p>

<h2 id="section-1">特性</h2>

<p>换句话说，它和Redis相比有什么不同？</p>

<!--more-->

<p>目标：Redis有的，Yedis都有。Redis没有的，但是很实用的，Yedis也有，比如说Cuckoo Hashing Map等。再比如说Treap，这玩意其实用来实现倒排索引非常高效，细节请参考Sigir2013的论文。</p>

<p>但是不打算兼容它，API和协议也和它不同。</p>

<h2 id="section-2">进度</h2>

<p>目前已经支持</p>

<blockquote>
  <ul>
    <li>Standard Bloom Filter</li>
    <li>Trie</li>
    <li>切换数据库</li>
  </ul>
</blockquote>

<p>还有很多工作要做，包括但是不局限于：</p>

<h3 id="bug-">Bug 修复</h3>

<p>毕竟，稳定和正确是第一位的。</p>

<h3 id="section-3">数据结构</h3>

<blockquote>
  <ul>
    <li>List</li>
    <li>HashMap</li>
    <li>Priority Queue</li>
    <li>Skip List</li>
    <li>Treap</li>
    <li>Kd tree</li>
    <li>Cuckoo Hashing Map</li>
    <li>d-left hashing based Couting Bloom Filter</li>
  </ul>
</blockquote>

<h3 id="section-4">性能优化</h3>

<p>超过或者达到Redis。</p>

<h3 id="section-5">分布式</h3>

<p>单机的内存数据库意义不大。</p>

<h2 id="section-6">截图</h2>

<h3 id="server">server</h3>

<p><img src="http://7xnljs.com1.z0.glb.clouddn.com/server.png" alt="server" /></p>

<h3 id="client">client</h3>

<p><img src="http://7xnljs.com1.z0.glb.clouddn.com/client.png" alt="client" /></p>

<p>不过，Yedis是写着玩的，别太当真。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C99中的柔性数组]]></title>
    <link href="http://www.yebangyu.org/blog/2016/03/25/fuckthefever/"/>
    <updated>2016-03-25T12:00:34+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/03/25/fuckthefever</id>
    <content type="html"><![CDATA[<p>柔性数组是C99引入的feature。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">struct</span> <span class="n">Data</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>其中柔性数组a处于结构体的末尾，并且声明的大小为0。</p>

<!--more-->

<p>那么它有什么性质呢？</p>

<p>1，首先，a不占用结构体空间。它只是一个占位符而已。因此</p>

<p>sizeof(Data) = sizeof(int) （这里的int是那个变量i）</p>

<p>2，我们可以利用a来分配动态内存：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">Data</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">Data</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Data</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这样，p就包含了10个int型元素构成的数组。</p>

<p>3，有些人说，为什么我们不这样呢？</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">struct</span> <span class="n">Data</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="n">Data</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">Data</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Data</span><span class="p">));</span>
</span><span class="line"><span class="n">p</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这样子不是挺好的么？是挺好的，但是这样结构体大小就得翻倍了，因为这下a不是占位符而是实实在在的指针变量了。</p>

<p>这还算小事。大事呢？这就是我们第三点要扯的：如果改成这样后，结构体成员i和数组a中的(首个)元素，地址将几乎肯定不是挨着的！！！这可能会带来很多问题，包括cache unfriendly等。</p>

<p>而如果使用柔性数组，我们可以简单做个实验发现：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include&lt;iostream&gt;</span>
</span><span class="line"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class="line"><span class="k">struct</span> <span class="n">Data</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">Data</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">Data</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Data</span><span class="p">)</span> <span class="o">+</span> <span class="mi">100</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span><span class="line">  <span class="n">cout</span><span class="o">&lt;&lt;&amp;</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">  <span class="n">cout</span><span class="o">&lt;&lt;&amp;</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Data</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>在ubuntu 14.04 64位系统＋gcc 4.8下编译运行后，程序输出：</p>

<pre><code>0x8a9010
0x8a9014
4
</code></pre>

<p>不额外占用空间、实现变长结构体、连续地址。能同时做到这三点的，除了柔性数组，不知还能有谁？不过这玩意，个人意见能少用尽量少用，能不用尽量不用，毕竟可能有移植性问题。</p>

<p>柔性数组的一个很常见的应用是跳表(Skip List)。由于跳表中不同的节点拥有不尽相同的高度,每个节点所包含的后继指针数量也不尽相同,因此此时柔性数组的合理使用可以最大利用内存空间.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入解析快速排序(Quick Sort)]]></title>
    <link href="http://www.yebangyu.org/blog/2016/03/09/quicksort/"/>
    <updated>2016-03-09T22:34:14+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/03/09/quicksort</id>
    <content type="html"><![CDATA[<p>本文将对快速排序进行深入的分析和介绍。通过学习本文，您将</p>

<blockquote>
  <ul>
    <li>秒杀快速排序面试</li>
    <li>掌握高效实现快排</li>
    <li>加深范型编程意识</li>
  </ul>
</blockquote>

<h2 id="section">八卦花絮</h2>

<p>快速排序是由图灵奖获得者、计算机语言设计大佬C. A. R. Hoare在他26岁时提出的。说起C. A. R. Hoare老爷爷，可能很多人的第一印象就是快速排序，但是快排仅仅是他人生中非常小的成就而已。例如，他在1978年提出的Communicating Sequential Processes(CSP)理论，则深深的影响了并行程序设计，Go语言中的Goroutine就是这种典范。</p>

<!--more-->

<h2 id="section-1">基本思想</h2>

<p>快速排序的思想非常简单：对于一个数组S，我们选择一个元素，称为pivot。将数组S中小于等于pivot的元素放在S的左边，大于等于pivot的元素放在S的右边。左右两部分分别记为S1和S2，然后我们递归的按上述方式对S1、S2进行排序。</p>

<p>具体说来，我们维护两个指针，采用两边扫描。从左到右扫描，当遇到一个元素大于等于pivot时，暂停。从右到左扫描，当遇到一个小于等于pivot元素时，暂停。然后交换这两个元素。继续扫描，直到两个指针相遇或者交叉。</p>

<p>从直观上看，每次递归处理的两个子数组S1、S2的大小最好是相等或者接近的，这样所花费的时间最少。</p>

<h2 id="section-2">实现细节</h2>

<p>说起来容易，做起来难了。要想正确实现快速排序非常不容易，很容易犯错。简单的修改就可能导致程序死循环或者结果错误。如果你一度感到很难在几分钟内实现一个正确的快速排序，说明你是正常人。那些五分钟内就能把快速排序写对的，几乎都是背代码。</p>

<p>我在实现以下代码时，就反复调试了十几分钟。而且，我会告诉你曾经JDK的某个版本实现中都存在bug么？</p>

<p>在给出完整代码之前，我们来考虑几个非常重要的问题。</p>

<h3 id="pivot">如何选择pivot？</h3>

<p>至少有几种显而易见的方法：</p>

<p>尝试1:选择数组中的第一个元素。成本低，但是当输入数组已经有序时，将导致O($n^2$)的复杂度。例如S={1,2,3,4,5,6,7,8,9}，如果选择第一个元素也就是1作为pivot，那么S1={1}, S2={2,3,4,5,6,7,8,9}，两个子数组非常的不平衡。当递归对S2排序时，选择2也就是S2中第一个元素作为pivot排序时，又会将S2分成两个极其不平衡的子数组。经过简单分析可知，此时算法复杂度为O($n^2$)。因此这不是一个理想、健壮的方法。</p>

<p>尝试2:随机选择一个。这种方法一般都能很好work，但是随机子程序可能非常昂贵，这可能拖慢整个程序。</p>

<p>尝试3:取中位数。取中位数可以保证S的两个子数组是等大小的（或者相差1），但是计算中位数可不是一个轻轻松松的活儿，将会严重拖慢算法速度。</p>

<p>尝试4:三数取中。尝试3方法太昂贵，我们可以稍微改变下：取数组第一个元素、最后一个元素、中间元素这三个元素的中位数。</p>

<h3 id="section-3">遇到相等的元素怎么办？</h3>

<p>左右扫描，如果遇到和pivot相等的元素怎么办？是暂停扫描还是继续扫描？</p>

<p>首先，两个方向采取的策略应该是一样的，也就是要么都暂停（然后交换），要么都继续扫描。否则将导致两个子数组不平衡。</p>

<p>其次，为了更好分析这个问题，我们不妨考虑所有元素都相同的情形。如果我们遇到和pivot相等的时候不停止，那么从左到右扫描时，两指针将相遇，此次过程结束。结果呢？什么都没做，却得到了两个大小极其不均衡的数组。算法时间复杂度为O($n^2$)。如果我们选择遇到相等元素时停止扫描，然后交换，那么虽然看上去交换的次数变多了，但是我们将得到大小相等（或者差1）的两个子数组。算法的时间复杂度为O($nlgn$)。</p>

<p>因此，遇到和pivot相等的元素时候我们都暂停扫描，交换元素后继续，直到指针相遇或者交叉。</p>

<h3 id="section-4">小数组怎么处理？</h3>

<p>随着不断的递归，待排序的子数组大小越来越小，所含元素越来越少。当子数组所含元素较少（比如说，20个）时，由于它们已经基本有序，我们改变策略，对它们改用插入排序。这也方便了三数取中策略的实现，否则我们在三数取中的时候还得特殊考虑子数组有0个、1个、2个元素的情形。当子数组多大时我们转换排序方法呢？这个最优值就依赖于体系结构了。为了找到你系统中它的最优值，请多测试！测试！测试！</p>

<h2 id="section-5">完整实现</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
<span class="line-number">85</span>
<span class="line-number">86</span>
<span class="line-number">87</span>
<span class="line-number">88</span>
<span class="line-number">89</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#define INLINE __attribute__((always_inline))</span>
</span><span class="line"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class="line"><span class="k">class</span> <span class="nc">MyCompareOperator</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="n">INLINE</span> <span class="kt">bool</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">;}</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">CompareOperator</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">threshold</span> <span class="o">=</span> <span class="mi">20</span><span class="o">&gt;</span>
</span><span class="line"><span class="k">class</span> <span class="nc">YedisSort</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="k">static</span> <span class="kt">void</span> <span class="n">sort</span><span class="p">(</span><span class="n">T</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">size</span><span class="p">);</span>
</span><span class="line"><span class="k">private</span><span class="o">:</span>
</span><span class="line">  <span class="k">static</span> <span class="kt">void</span> <span class="n">sort_</span><span class="p">(</span><span class="n">T</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">right</span><span class="p">,</span> <span class="k">const</span> <span class="n">CompareOperator</span> <span class="o">&amp;</span><span class="n">co</span><span class="p">);</span>
</span><span class="line">  <span class="k">static</span> <span class="kt">void</span> <span class="nf">insertion_sort</span><span class="p">(</span><span class="n">T</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">right</span><span class="p">,</span> <span class="k">const</span> <span class="n">CompareOperator</span> <span class="o">&amp;</span><span class="n">co</span><span class="p">);</span>
</span><span class="line">  <span class="k">static</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">get_pivot</span><span class="p">(</span><span class="n">T</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">right</span><span class="p">,</span> <span class="k">const</span> <span class="n">CompareOperator</span> <span class="o">&amp;</span><span class="n">co</span><span class="p">);</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">CompareOperator</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">threshold</span><span class="o">&gt;</span>
</span><span class="line"><span class="n">INLINE</span> <span class="kt">void</span> <span class="n">YedisSort</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">CompareOperator</span><span class="p">,</span> <span class="n">threshold</span><span class="o">&gt;::</span><span class="n">sort</span><span class="p">(</span><span class="n">T</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">size</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">CompareOperator</span> <span class="n">co</span><span class="p">;</span>
</span><span class="line">  <span class="n">sort_</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">co</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">CompareOperator</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">threshold</span><span class="o">&gt;</span>
</span><span class="line"><span class="kt">void</span> <span class="n">YedisSort</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">CompareOperator</span><span class="p">,</span> <span class="n">threshold</span><span class="o">&gt;::</span><span class="n">sort_</span><span class="p">(</span><span class="n">T</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">right</span><span class="p">,</span> <span class="k">const</span> <span class="n">CompareOperator</span> <span class="o">&amp;</span><span class="n">co</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">if</span><span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">get_pivot</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">co</span><span class="p">);</span>
</span><span class="line">    <span class="kt">int64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int64_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="k">do</span>
</span><span class="line">      <span class="p">{</span>
</span><span class="line">        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
</span><span class="line">      <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="n">co</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pivot</span><span class="p">));</span>
</span><span class="line">      <span class="k">do</span>
</span><span class="line">      <span class="p">{</span>
</span><span class="line">        <span class="o">--</span><span class="n">j</span><span class="p">;</span>
</span><span class="line">      <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="n">co</span><span class="p">(</span><span class="n">pivot</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]));</span>
</span><span class="line">      <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span><span class="line">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">        <span class="k">break</span><span class="p">;</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span><span class="c1">//restore pivot</span>
</span><span class="line">    <span class="n">sort_</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">co</span><span class="p">);</span>
</span><span class="line">    <span class="n">sort_</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">co</span><span class="p">);</span>
</span><span class="line">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">    <span class="n">insertion_sort</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">co</span><span class="p">);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">CompareOperator</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">threshold</span><span class="o">&gt;</span>
</span><span class="line"><span class="n">INLINE</span> <span class="kt">void</span> <span class="n">YedisSort</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">CompareOperator</span><span class="p">,</span> <span class="n">threshold</span><span class="o">&gt;::</span><span class="n">insertion_sort</span><span class="p">(</span><span class="n">T</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">right</span><span class="p">,</span> <span class="k">const</span> <span class="n">CompareOperator</span> <span class="o">&amp;</span><span class="n">co</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">int64_t</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int64_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">  <span class="k">for</span> <span class="p">(</span><span class="kt">int64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">//insert data[i]. data[left to i-1] are ordered already</span>
</span><span class="line">    <span class="kt">int64_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="n">T</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="n">j</span> <span class="o">&gt;-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">co</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span> <span class="p">{</span>
</span><span class="line">      <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span><span class="line">      <span class="n">j</span><span class="o">--</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">CompareOperator</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">threshold</span><span class="o">&gt;</span>
</span><span class="line"><span class="n">INLINE</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">YedisSort</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">CompareOperator</span><span class="p">,</span> <span class="n">threshold</span><span class="o">&gt;::</span><span class="n">get_pivot</span><span class="p">(</span><span class="n">T</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">right</span><span class="p">,</span> <span class="k">const</span> <span class="n">CompareOperator</span> <span class="o">&amp;</span><span class="n">co</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">int64_t</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="n">co</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">mid</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">left</span><span class="p">]))</span> <span class="p">{</span>
</span><span class="line">    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">mid</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">left</span><span class="p">]);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="n">co</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">right</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">mid</span><span class="p">]))</span> <span class="p">{</span>
</span><span class="line">    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">mid</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">right</span><span class="p">]);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="n">co</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">mid</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">left</span><span class="p">]))</span> <span class="p">{</span>
</span><span class="line">    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">mid</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">left</span><span class="p">]);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="c1">//Store pivot there to facilitate bound processing in sort_</span>
</span><span class="line">  <span class="c1">//data[right - 1] &lt;= data[right]</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">mid</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
</span><span class="line">  <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>我们把以上实现的快速排序称为YedisSort。是的，90行不到。</p>

<h2 id="section-6">测试结果</h2>

<p>测试程序已经放到了github上，可以从<a href="https://github.com/yebangyu/Yedis/blob/master/src/bad/test.cpp">这里</a>下载。</p>

<p>我们pk的对象包括STL中的sort，以及C语言里大名鼎鼎的qsort。</p>

<p>我们的平台是Ubuntu 64位系统 + gcc 4.8</p>

<p>测试结果：</p>

<p>1000W个随机打乱的32位无符号整数</p>

<p>开启O2优化（单位：秒）：</p>

<p>sort: 1.06</p>

<p>YedisSort: 1.20</p>

<p>qsort: 2.08</p>

<p>未开启O2优化（单位：秒）：</p>

<p>sort: 3.29</p>

<p>YedisSort: 2.93</p>

<p>qsort: 2.91</p>

<p>1000W个相同的整数</p>

<p>开启O2优化（单位：秒）：</p>

<p>sort: 0.23</p>

<p>YedisSort: 0.27</p>

<p>qsort: 0.59</p>

<p>未开启O2优化（单位：秒）：</p>

<p>sort: 2.60</p>

<p>YedisSort: 1.56</p>

<p>qsort: 0.76</p>

<p>什么结论？</p>

<p>没开优化，那么所需时间 qsort &lt; YedisSort &lt; sort</p>

<p>开了优化，那么所需时间 sort &lt; YedisSort &lt; qsort</p>

<p>为什么sort可以这么叼？据说它综合了插入排序、快速排序和堆排序。这让我想起了推荐和广告比赛里，有些队伍利用Ensemble Learning没节操地堆了几百个model。。。</p>

<h2 id="further-thinking">Further Thinking</h2>

<p>1，64行的 <code>while(j &gt;-1 &amp;&amp; co(tmp, data[j]))</code> 能否改为 <code>while(j &gt;-1 &amp;&amp; !co(data[j], tmp))</code> ？ 同理，36和40行能否作相应的改动？</p>

<p>2，30-46行能否改为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">int64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="kt">int64_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line"><span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">  <span class="k">while</span><span class="p">(</span><span class="n">co</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pivot</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">while</span><span class="p">(</span><span class="n">co</span><span class="p">(</span><span class="n">pivot</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span> <span class="p">{</span>
</span><span class="line">    <span class="o">--</span><span class="n">j</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span><span class="line">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">    <span class="k">break</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>深入分析这样的case，将会对编写正确的快速排序的困难性有更深的体会，虽然我们已经有循环不变式这个强大的工具。</p>

<p>3，快速排序所需的栈空间是多少？能否进一步优化？</p>

<p>4，YedisSort的时间复杂度是多少？O($n^2$)还是O($nlgn$)？如果是前者，那么，什么情况下是二次的？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Peterson算法实现spin lock]]></title>
    <link href="http://www.yebangyu.org/blog/2016/03/04/petersonalgorithm/"/>
    <updated>2016-03-04T22:26:51+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/03/04/petersonalgorithm</id>
    <content type="html"><![CDATA[<p>对spin lock和mutex不熟悉的朋友，可以看<a href="http://www.yebangyu.org/blog/2016/01/24/spinlock-and-mutex/">上篇</a>博客。</p>

<h2 id="section">提出问题</h2>

<p>如何仅仅通过load和store实现spin lock呢？</p>

<p>本文只考虑、只针对只有两个线程的情形。假设这两个线程的id分别为0和1。编程环境为X86体系结构 + Intel CPU + gcc</p>

<!--more-->

<h2 id="section-1">分析问题</h2>

<h3 id="section-2">尝试一：仅使用一个变量</h3>

<p>仅使用一个bool类型变量flag，线程i申请锁时，查看flag是否为1-i，如果不是，说明另外一个线程没有在临界区，申请成功，并把flag的值设置为i。</p>

<p>这种方法的问题在于，检查flag是否为1-i，以及设置flag为i这两步不是原子的，无法仅仅通过load和store来原子实现。（需要CAS等类似的原子操作）</p>

<h3 id="section-3">尝试二：使用两个变量</h3>

<p>根据前面的分析，我们可以使用两个bool变量flag[0]和flag[1]。线程i申请锁时，先把flag[i]设置为true，表示自己试图进入临界区，然后查看flag[1-i]是否为true，如果是，说明另一个线程在临界区，于是spin。</p>

<p>这个方法的问题在于可能发生这样的问题：</p>

<p>线程0把flag[0]设置为true，这时候还没开始检查flag[1]，此时线程1把flag[1]设置为true。</p>

<p>接下去，每个线程都发现对方的flag为true，而实际上两个都没在临界区中，却谁都没法拿到锁，发生starvation现象。</p>

<h3 id="section-4">尝试三：使用三个变量</h3>

<p>在尝试二的基础上，再增加一个变量turn，表示谁先将自己的flag设置为true（仅仅通过那两个flag是没法区分的，想想看，是不是这样的）。因此这个变量可以用来裁决谁取得进入临界区的权利。</p>

<h2 id="section-5">解决问题</h2>

<p>以上尝试三所描述的方法，就是大名鼎鼎的peterson算法的雏形了。简单实现如下（注意，本文的平台是x86体系结构 + Intel CPU + gcc）：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">class</span> <span class="nc">PetersonSpinLock</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">public</span><span class="o">:</span>
</span><span class="line">    <span class="n">PetersonSpinLock</span><span class="p">()</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">      <span class="n">flags_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">      <span class="n">flags_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">      <span class="n">turn_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span><span class="c1">//initial value does not matter</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="kt">bool</span> <span class="n">lock</span><span class="p">(</span><span class="kt">int</span> <span class="n">thread_id</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">      <span class="kt">int</span> <span class="n">other</span> <span class="o">=</span> <span class="o">!</span><span class="n">thread_id</span><span class="p">;</span>
</span><span class="line">      <span class="n">flags_</span><span class="p">[</span><span class="n">thread_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span><span class="line">      <span class="n">COMPILER_BARRIER</span><span class="p">();</span>
</span><span class="line">      <span class="n">turn_</span> <span class="o">=</span> <span class="n">thread_id</span><span class="p">;</span>
</span><span class="line">      <span class="n">CPU_BARRIER</span><span class="p">();</span><span class="c1">// essential</span>
</span><span class="line">      <span class="k">while</span><span class="p">(</span><span class="n">flags_</span><span class="p">[</span><span class="n">other</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">turn_</span> <span class="o">==</span> <span class="n">thread_id</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">CPU_RELAX</span><span class="p">();</span><span class="c1">//spin</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">      <span class="c1">//get lock successfully</span>
</span><span class="line">      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="kt">bool</span> <span class="n">unlock</span><span class="p">(</span><span class="kt">int</span> <span class="n">thread_id</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">      <span class="n">flags_</span><span class="p">[</span><span class="n">thread_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="k">private</span><span class="o">:</span>
</span><span class="line">    <span class="k">volatile</span> <span class="kt">bool</span> <span class="n">flags_</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span><span class="line">    <span class="k">volatile</span> <span class="kt">bool</span> <span class="n">turn_</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>以下是对peterson算法的思考和讨论。在看我的分析之前，请自己尝试思考以下问题：（温馨提示：在C/C++中，if条件判断是短路求值的。也就是说对于if(A &amp;&amp; B)，一旦知道A是false，那么B将不用evaluate了）</p>

<blockquote>
  <ul>
    <li>peterson算法如何防止starvation的发生？</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>peterson算法如何防止两个线程同时进入临界区？</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>代码13行和15行能否调换执行顺序？</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>代码15行能否改为<code>turn_ = !thread_id</code> ？</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>16行的cpu 级别的memory barrier是否必要？</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>实现（针对两个线程的）peterson算法所需最少空间为多少？</li>
  </ul>
</blockquote>

<p>思考了没？下面我们来分析讨论一下：</p>

<h3 id="petersonstarvation">peterson算法如何防止starvation的发生？</h3>

<p>假设某时刻两个线程都在spin，也就是17行中while的条件对两个线程都成立，也就是说：</p>

<p>flag_[0] == true 并且 trun_ == 0 并且 flag_[1] == true 并且turn_ == 1</p>

<p>但是turn_只能有一个值，矛盾。</p>

<h3 id="peterson">peterson算法如何防止两个线程同时进入临界区？</h3>

<p>如果两者同时进入临界区，说明17行中的while判断对两个线程都为false，也就是说</p>

<p>flag_[1] == false 或者 turn _ == 1</p>

<p>同时</p>

<p>flag_[0] == false 或者 turn_ == 0</p>

<p>因此只有四种情形：</p>

<p>flag_[1] == false  &amp;&amp; flag_[0] == false  与13行矛盾</p>

<p>flag_[1] == false  &amp;&amp; turn_ == 0  与13行矛盾</p>

<p>turn_ == 1 &amp;&amp; flag_[0] == false 与13行矛盾</p>

<p>turn _ == 1 &amp;&amp; turn _ == 0 不可能发生</p>

<p>而一旦例如说，线程0，进入临界区后，线程1会因为turn_的值而spin，直到线程0通过unlock将flag_[0]设置为false。</p>

<p>因此，13、15两行的顺序很重要。是这样的吗？接着往下看。</p>

<h3 id="section-6">代码13行和15行能否调换执行顺序？</h3>

<p>不可以，否则可能发生两个线程同时进入临界区。</p>

<p>考虑以下情形：</p>

<p>线程0执行turn_ = 0</p>

<p>线程1执行turn_ = 1</p>

<p>线程1执行flag_[1] = true</p>

<p>线程1执行17行的判断，因为flag_[0]为false，所以线程1进入临界区。</p>

<p>线程0执行flag_[0] = true</p>

<p>线程0执行17行判断，此时turn_等于1，所以线程0也进入临界区。</p>

<p>因此13行和15行执行顺序不可以交换；而这两个都是store操作，在X86 Intel CPU下，cpu不会乱序执行它们，因此只需要在14行增加一个compiler级别的memory barrier，防止编译器乱序即可。</p>

<h3 id="turn--threadid">代码15行能否改为<code>turn_ = !thread_id</code></h3>

<p>可以。只是如果15行改为<code>turn_ = !thread_id</code>，那么17行需要将<code>turn_ == thread_id</code>也改为<code>turn_ == !thread_id</code>。也就是说turn_的初始值是什么并不重要，turn_设置成什么值也不太重要，重要的是通过turn_能区分出谁先尝试申请锁。</p>

<h3 id="cpu-memory-barrier">16行的cpu 级别的Memory Barrier是否必要？</h3>

<p>非常必要。否则17行对flags_[other]的读取（判断）操作可能和15行发生乱序（写读乱序。而13、15属于写写，是不会被CPU乱序执行的，不用加cpu 级别的memory barrier），最后可能导致两个线程同时进入临界区。这点，请读者务必自己亲自分析。非常重要！</p>

<p>不加Memory Barrier，乱序后，考虑以下情形：</p>

<p>线程0判断flag_[1]，发现为false（此时线程1还没开始调用lock函数，flag_[1]还是它的初始值false），进入临界区。</p>

<p>线程1判断flag_[0]，发现为true</p>

<p>线程1执行<code>turn_ = 1</code></p>

<p>线程0执行<code>turn_ = 0</code></p>

<p>线程1执行17行判断，此时turn_等于0，所以线程1也进入临界区。</p>

<h3 id="peterson-1">实现（针对两个线程的）peterson算法所需最少空间为多少？</h3>

<p>3个bit足矣。两个flag_两个bit，turn_也只需要1个bit。</p>

<h2 id="section-7">附录：</h2>

<p>在X86下，<code>CPU_BARRIER</code>和<code>CPU_RELAX</code>以及<code>COMPILER_BARRIER</code>可以用gcc内置feature，通过宏来实现：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#define CPU_BARRIER() __sync_synchronize()</span>
</span><span class="line"><span class="cp">#define COMPILER_BARRIER() __asm__ __volatile__(&quot;&quot; : : : &quot;memory&quot;)</span>
</span><span class="line"><span class="cp">#define CPU_RELAX() __asm__ __volatile__(&quot;pause&quot;: : :&quot;memory&quot;)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>18行不用CPU_RELAX而是简单的一个分号行吗？可以的。不过加了CPU_RELAX可以提高性能、节能减排。</p>

<h2 id="section-8">致谢</h2>

<p>本文发出后，微博网友@finalpatch 指出应在代码的29、30行加上volatile。非常感谢。</p>

<p>本文发出后，微博网友@linyvxiang 指出了文中的两处笔误。非常感谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编写高质量代码(下)]]></title>
    <link href="http://www.yebangyu.org/blog/2016/02/24/writeelegantcodes/"/>
    <updated>2016-02-24T22:26:44+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/02/24/writeelegantcodes</id>
    <content type="html"><![CDATA[<p><a href="http://www.yebangyu.org/blog/2015/11/06/how-to-write-elegant-cpp-codes/">上回</a>我们从微观角度，以一个实际的例子，从正确、高效、易读等特性着手，介绍了如何编写高质量的代码。这次，我们从宏观出发，从软件开发流程入手，着重介绍其中的几个方面，包括代码规范、Code Review、测试等。</p>

<p>如果说<a href="http://www.yebangyu.org/blog/2015/11/06/how-to-write-elegant-cpp-codes/">上回</a>的内容注重个人编码，那么本文将偏向团队开发。</p>

<h2 id="section">代码规范</h2>

<p>团队的代码规范，一般由领导和大佬们制定后，大家统一实行。这里面有几个问题：</p>

<h3 id="section-1">真的需要代码规范吗？</h3>

<p>言下之意，制定和执行代码规范是否浪费时间？</p>

<!--more-->

<p>答案是：It depends。如果项目很庞大、代码质量要求很高，那么，制定和执行代码规范所花费的时间，将大大少于后期因为不规范开发带来的种种调试和维护成本。如果是小打小闹的代码，就无所谓了。</p>

<h3 id="section-2">代码规范的制定为什么这么难？</h3>

<p>原因众多，其中一个很重要的部分是团队每个人的口味和观点不尽相同。就代码风格而言，有人喜欢对内置类型变量i使用i++，有人坚持认为应该使用++i不管i是不是复杂类型。因此，制定代码规范需要在讨论之后最后拍板决定，这里面甚至需要独裁！是的，独裁！</p>

<h3 id="section-3">代码规范制定需要注意什么事项？</h3>

<p>如果代码规范限制太松，那么等于没有规范；如果太严，大大影响开发效率。这里面的尺度，需要根据项目需要、团队成员特点全面考量，进行取舍。</p>

<p>需要注意的是，没有任何一种代码规范是完美的。例如，在C++中，如果启用异常，那么代码的流程将会被各种异常处理中断，各种try catch throw让代码很不美观；如果禁用异常，也就是在开发的过程中不能使用异常特性，那么团队成员可能因为长期没有接触这项语言feature而造成知识和技能短板。</p>

<h3 id="section-4">代码风格举例</h3>

<p>举两个我认为比较重要、比较新鲜、比较有趣的代码风格。</p>

<p>1，使用引用需要判空吗？</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们都知道，在g中，使用*p前需要对p是否为NULL进行判断，那么f呢？如果质量非常关键、代码安全非常重要的场景，那么实际上，也是需要的。因为调用者可能这样：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="c1">//......</span>
</span><span class="line"><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>因此，需要在f里增加<code>if(NULL == &amp;p)</code>的判断。</p>

<p>2，级联if else语句。</p>

<p>首先看一个我个人认为不好的代码风格：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="c1">//do sth</span>
</span><span class="line">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">        <span class="c1">//error1</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">      <span class="c1">//error2</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">//error3</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这个函数的核心在于do sth部分。其实我们可以改写为级联if－else形式，如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">//error3</span>
</span><span class="line">  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">//error2</span>
</span><span class="line">  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">//error1</span>
</span><span class="line">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">//so, a&gt;=1 &amp;&amp; b&gt;=1 &amp;&amp; a&gt;=b</span>
</span><span class="line">    <span class="c1">//do sth</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>是不是优美多了？前面只做一些错误处理、前期准备、参数检查等，最后的else分支做实实在在的功能性事情。</p>

<h2 id="code-review">Code Review</h2>

<h3 id="code-review-1">什么是Code Review？</h3>

<p>很多人把它翻译为代码审查，我觉得太政治味了。程序员尤其是新手写完代码后，可能会有风格问题（比如不符合团队的代码规范）、安全性问题(比如忘记指针判空)、优雅性问题(比如大量冗余代码)、正确性问题（比如算法设计错误），那么在发布代码到公共库之前，提交给师兄或者mentor，让他帮你review一下代码，并提出可能的问题和建议，让你好好修改。这样的过程，就叫做Code Review。</p>

<h3 id="section-5">我的天呐，那这不是很占用时间？</h3>

<p>是的。一个写代码，一个看代码，看代码的时间可能并不比全新写一份代码少。那么，这又是何必呢？</p>

<p>主要的原因有：</p>

<p>1，review确实占用了开发时间，然而开发，或者说写代码，其实只占很少的时间比例。很多时间花在debug、调试、写文档、需求分析、设计算法、维护等等上。</p>

<p>2，代码质量非常重要，这点时间投入是值得的。与其后期苦逼追bug，不如前期多投入点时间和人力。</p>

<p>3，培养新人，让新手更快成长。</p>

<h3 id="code-review-2">如何更好的执行Code Review</h3>

<p>这里给几点建议：</p>

<p>1，不走过场。走过场，还不如不要这个流程。</p>

<p>2，作为Reviewer，看不懂代码就把作者拉过来，当面询问，不要不懂装懂，也不要爱面子不好意思问。</p>

<p>3，作为Coder，心里要有感激之情。真的。不要得了便宜还卖乖，感恩reviewer，感激reviewer对自己的进步和成长所做出的贡献，所花费的心血。中国人里狼心狗肺、忘恩负义、不懂感恩的人还算少吗？</p>

<p>4，作为Coder，给Reviewer Review之前，请先做单元测试并确保通过，并自己尝试先整体看一遍自己本次提交的代码。注意，不要给别人提还没调试通过的代码，这是非常不尊重别人的表现。</p>

<h2 id="section-6">质量保证</h2>

<p>1，测试不是专属QA的活儿，对自己写的代码提供质量保证，是程序员的职责。QA要负责的，是系统的质量，不是模块的质量。</p>

<p>2，测试，需要意识，需要坚持。我发现C++程序员、前端程序员的测试意识或者说质量意识最强；数据科学家或者数据工程师的质量意识最差，很多人甚至不写测试用例。当然，这不怪他们，毕竟，有时候代码里有个bug，准确率和召回率会更高。</p>

<p>3，测试用例的编写和设计需要保证一定的代码覆盖率，力求让每个分支和流程的代码都走到，然后分析运行结果是否是符合期望的，不要只考虑正确路径上的那些分支。</p>

<p>4，测试用例的编写和设计力求全面，考虑到方方面面。以非常经典的二分搜索为例：</p>

<p>int binary_search(int *p, int n, int target, int &amp;idx);</p>

<p>binary_search函数返回值为0表示成功执行，输出参数idx返回target在有序数组p中(第一次出现)的位置，－1表示不存在。</p>

<p>那么测试用例至少应该涵盖：</p>

<ul>
  <li>
    <p>p为NULL的情况</p>
  </li>
  <li>
    <p>数组大小n分别为负数、0、1、2时情况</p>
  </li>
  <li>
    <p>数组p不是有序数组的情况</p>
  </li>
  <li>
    <p>target在数组中出现0次、1次、n次的情况</p>
  </li>
</ul>

<p>你是否都考虑到了呢？</p>

<p>4，有时候，自己书写测试用例显得刀耕火种，现在已经有很多辅助的工具，读者可以自行google一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++函数对象(function object)的应用]]></title>
    <link href="http://www.yebangyu.org/blog/2016/02/20/object-function-in-cpp/"/>
    <updated>2016-02-20T23:30:53+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/02/20/object-function-in-cpp</id>
    <content type="html"><![CDATA[<p>假如我们实现了这样的一个单向链表：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">class</span> <span class="nc">LinkedListNode</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">data_</span><span class="p">;</span>
</span><span class="line">  <span class="n">LinkedListNode</span> <span class="o">*</span><span class="n">next_</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="k">class</span> <span class="nc">LinkedList</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">public</span><span class="o">:</span>
</span><span class="line">    <span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="n">LinkedListNode</span><span class="o">*</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
</span><span class="line">    <span class="kt">void</span> <span class="nf">del</span><span class="p">(</span><span class="n">LinkedListNode</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span><span class="line">  <span class="k">private</span><span class="o">:</span>
</span><span class="line">    <span class="n">LinkedListNode</span> <span class="o">*</span><span class="n">head_</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<!--more-->

<p>其中insert将p插入到head_为头指针的链表中，而p对应的内存由外面分配好，调用的时候类似于这样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">LinkedList</span> <span class="n">list</span><span class="p">;</span>
</span><span class="line"><span class="n">LinkedListNode</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedListNode</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line"><span class="n">list</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>其中，p可能是通过new得到，也可能是malloc出来。好，问题来了：</p>

<p>这个类的del函数应该如何实现呢？如果节点是new出来的，我们得delete；如果是malloc出来的，我们得使用配套的free。否则，行为就是undefined。而且，用户还可能实现了自己的定制的内存分配回收例程。</p>

<p>我们并不知道该内存是如何分配得到的。这就是问题所在。</p>

<p>解决方法是让用户将正确的、对应的、适配的资源释放例程传递进来，然而delete是expression，free是函数，更悲剧的是不同用户实现的资源回收函数原型不尽相同。如何做呢？</p>

<p>函数对象是解决这个问题的利器。我们可以这样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">CallBack</span><span class="o">&gt;</span>
</span><span class="line"><span class="k">class</span> <span class="nc">LinkedList</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">public</span><span class="o">:</span>
</span><span class="line">    <span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="n">LinkedListNode</span><span class="o">*</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
</span><span class="line">    <span class="kt">void</span> <span class="nf">del</span><span class="p">(</span><span class="n">LinkedListNode</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
</span><span class="line">  <span class="k">private</span><span class="o">:</span>
</span><span class="line">    <span class="n">LinkedListNode</span> <span class="o">*</span><span class="n">head_</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在del中：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">void</span> <span class="nf">del</span><span class="p">(</span><span class="n">LinkedListNode</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="c1">//...</span>
</span><span class="line">  <span class="n">LinkedListNode</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">get_prev</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span class="line">  <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next_</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
</span><span class="line">  <span class="n">CallBack</span> <span class="n">cb</span><span class="p">;</span>
</span><span class="line">  <span class="n">cb</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="c1">//调用用户提供的资源回收例程</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>用户需要实现自己的CallBack类的operator()成员函数。如下所示：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">class</span> <span class="nc">MyReclaimRoutine</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">public</span><span class="o">:</span>
</span><span class="line">    <span class="kt">void</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="n">LinkedListNode</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">      <span class="k">delete</span> <span class="n">p</span><span class="p">;</span> <span class="c1">//free(p) ? my_release_func(p) ? all up to you!</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然后就万事大吉了：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">MyReclaimRoutine</span><span class="o">&gt;</span> <span class="n">list</span><span class="p">;</span>
</span><span class="line"><span class="n">LinkedListNode</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedListNode</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line"><span class="n">list</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span class="line"><span class="n">list</span><span class="p">.</span><span class="n">del</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="c1">//ok! delete p will be called</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Materials In Concurrency Programming]]></title>
    <link href="http://www.yebangyu.org/blog/2016/02/16/materials-in-concurrency-programming/"/>
    <updated>2016-02-16T23:36:28+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/02/16/materials-in-concurrency-programming</id>
    <content type="html"><![CDATA[<h2 id="prerequisite">Prerequisite</h2>

<p>对CPU、内存、Cache有一个很好的认识，对学习并发编程有很大的帮助。</p>

<p><a href="https://people.freebsd.org/~lstewart/articles/cpumemory.pdf">What Every Programmer Should Know About Memory</a></p>

<p><a href="http://www.amazon.com/Consistency-Coherence-Synthesis-Lectures-Architecture/dp/1608455645">A Primer on Memory Consistency and Cache Coherence</a></p>

<!--more-->

<h2 id="textbook">Textbook</h2>

<p><a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html">Is Parallel Programming Hard, And, If So, What Can You Do About It?</a></p>

<p>Paul大叔的神作。</p>

<p>优点：</p>

<p>1，很全面，除了介绍lock的实现、RCU、Transaction Memory等等之外，还包括一些并发程序设计的其他知识，比如如何验证、如何调试等。</p>

<p>个人非常喜欢第14章和附录C，分别详细介绍了什么是Memory Barrier以及为什么需要Memory Barrier。强烈推荐！</p>

<p>2，很正派。这里面介绍的技术都非常通用，普遍适用，没有太多的黑科技。比如书中重点强调的partition，就是一种非常重要、非常scientific的思想。</p>

<p>3，很幽默。真的，很幽默。</p>

<p>缺点：因为正派，所以就没有介绍lock free这种很tricky的黑科技，算是不足吧。</p>

<p>个人喜爱程度：5颗星</p>

<p><a href="http://www.amazon.com/The-Multiprocessor-Programming-Revised-Reprint/dp/0123973376">The Art of Multiprocessor Programming</a></p>

<p>被很多人推崇。第一版有很多错误，作者随后推出了revised版本。</p>

<p>优点：市面上目前能见到的唯一一本包括大量Lock Free Data Structure实现的书籍。</p>

<p>缺点：</p>

<p>1，Java语言实现。个人固执认为应该用C或者C++</p>

<p>2，没有介绍RCU等重要内容</p>

<p>3，不详细。可能是我个人实力不行，感觉这本书讲的并不好，看完还是得看论文才懂。</p>

<p>个人喜爱程度：3颗星</p>

<p><a href="http://www.morganclaypool.com/doi/abs/10.2200/S00499ED1V01Y201304CAC023">Shared Memory Synchronization</a></p>

<p>优点：</p>

<p>1，很新。2013年的书</p>

<p>2，选题不错。综合了上面两本</p>

<p>缺点：</p>

<p>1，鸡肋。初学者看了云里雾里，高手没必要看。</p>

<p>是作者实力不够吗？恐怕不是。作者Michael L. Scott是程序语言设计和并发编程的大拿。</p>

<p>是作者表述能力不行吗？恐怕不是。他写有一本非常著名和畅销的书籍：《Programming Language Pragmatics》</p>

<p>这本书偏综述＋lecture notes性质，估计和这系列丛书的定位有关。</p>

<p>2，没有中文版，没有英文影印版，很难下到pdf。苦逼穷学生想阅读的话基本上只能去amazon.com购买原版</p>

<p>个人喜爱程度：1颗星</p>

<h2 id="blog">Blog</h2>

<p><a href="http://preshing.com/">Jeff Preshing’s Blog</a></p>

<p><a href="http://www.cliffc.org/blog/">Cliff Click’s Blog</a></p>

<p><a href="http://www.yebangyu.org">Yebangyu’s Blog</a></p>

<h2 id="course">Course</h2>

<p><a href="http://www.cs.rice.edu/~johnmc/comp522/lecture-notes/">Multicore Computing</a></p>

<h2 id="paper">Paper</h2>

<h3 id="linked-list--skip-list">Linked List &amp; Skip List</h3>

<p><a href="https://timharris.uk/papers/2001-disc.pdf">A Pragmatic Implementation of Non-Blocking Linked-Lists</a></p>

<p><a href="http://www.cse.yorku.ca/~ruppert/papers/lfll.pdf">Lock Free Linked Lists and Skip Lists</a></p>

<p><a href="http://www.cse.yorku.ca/~ruppert/Mikhail.pdf">Lock Free Linked Lists and Skip Lists</a></p>

<p><a href="http://cs.ucf.edu/~dcm/Teaching/COT4810-Spring2011/Literature/SplitOrderedLists.pdf">Split-Ordered Lists: Lockfree Extensible Hash Tables</a></p>

<p><a href="http://cs.brown.edu/~mph/LevHLS06/OPODIS2006-BA.pdf">A Provably Correct Scalable Concurrent Skip List</a></p>

<h3 id="stack">Stack</h3>

<p><a href="http://www.cs.bgu.ac.il/~hendlerd/papers/scalable-stack.pdf">A Scalable Lock Free Stack Algorithm</a></p>

<h3 id="queue">Queue</h3>

<p><a href="http://www.cs.rochester.edu/~scott/papers/1996_PODC_queues.pdf">Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms</a></p>

<p><a href="http://www.non-blocking.com/download/SunT03_PQueue_TR.pdf">Fast and Lock Free Concurrent Priority Queues for Multi-Thread Systems</a></p>

<p><a href="http://people.csail.mit.edu/edya/publications/OptimisticFIFOQueue-DISC2004.pdf">An Optimistic Approach to Lock Free FIFO Queues</a></p>

<h3 id="hash-map">Hash Map</h3>

<p><a href="http://www.win.tue.nl/~jfg/articles/CS-Report03-03.pdf">Efficient Almost Wait Free Parallel Accessible Dynamic Hash-tables</a></p>

<p><a href="http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-639.pdf">Non-Blocking Hash-Tables With Open Addressing</a></p>

<p><a href="http://cs.brown.edu/~mph/HellerHLMSS05/2005-OPODIS-Lazy.pdf">A Lazy Concurrent List-Based Set Algorithm</a></p>

<p><a href="http://www.research.ibm.com/people/m/michael/spaa-2002.pdf">High Performance Dynamic Lock-Free Hash Tables and List-Based Sets</a></p>

<h3 id="cuckoo-hash-map">Cuckoo Hash Map</h3>

<p><a href="http://excess-project.eu/publications/published/CuckooHashing_ICDCS.pdf">Lock-free Cuckoo Hashing</a></p>

<h3 id="b-tree">B+ Tree</h3>

<p><a href="http://www.cs.technion.ac.il/~erez/Papers/lfbtree-full.pdf">A Lock-Free B+ Tree</a></p>

<p><a href="http://www.cs.technion.ac.il/~anastas/lfbtree-spaa.pdf">A Lock-Free B+ Tree</a></p>

<h3 id="others">Others</h3>

<p><a href="https://www.research.ibm.com/people/m/michael/ieeetpds-2004.pdf">Hazard Pointers: Safe Memory Reclamation For Lock-Free Objects</a></p>

<p><a href="http://www.grame.fr/ressources/publications/fober-JIM2002.pdf">Lock Free Techniques for Concurrent Access to Shared Objects</a></p>

<p><a href="http://www.cs.rochester.edu/~scott/papers/1998_JPDC_nonblocking.pdf">Non-Blocking Algorithms and Preemption-Safe Locking on Multiprogrammed Shared Memory Multiprocessors</a></p>

<p><a href="http://cs.brown.edu/people/mph/HerlihyLM03/main.pdf">Obstruction-Free Synchronization: Double-Ended Queues as an Example</a></p>

<p><a href="http://www.research.ibm.com/people/m/michael/podc-2002.pdf">Safe Memory Reclamation for Dynamic Lock Free Objects Using Atomic Reads and Writes</a></p>

<p><a href="http://www.ece.uc.edu/~paw/classes/ece975/sp2010/papers/herlihy-05.pdf">Non-blocking Memory Management Support for Dynamic-Sized Data Structures</a></p>

<p><a href="http://cs.brown.edu/~mph/DohertyHLM04/ft_gateway.cfm.pdf">Bringing Practical Lock Free Synchronization to 64Bit Applications</a></p>

<p><a href="https://www.research.ibm.com/people/m/michael/pldi-2004.pdf">Scalable Lock-Free Dynamic Memory Allocation</a></p>

<p><a href="http://research.microsoft.com/pubs/209106/paper.pdf">Are Lock-Free Concurrent Algorithms Practically Wait-Free</a></p>

<p><a href="http://www.cl.cam.ac.uk/~pes20/cpp/popl085ap-sewell.pdf">Mathematizing C++ Concurrency</a></p>

<h2 id="pages">Pages</h2>

<p><a href="https://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync">Memory model synchronization modes</a></p>

<p><a href="http://jakob.engbloms.se/archives/65">Dekker’s Algorithm Does not Work, as Expected</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多线程内存问题分析之mprotect方法]]></title>
    <link href="http://www.yebangyu.org/blog/2016/02/01/detectmemoryghostinmultithread/"/>
    <updated>2016-02-01T22:24:25+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/02/01/detectmemoryghostinmultithread</id>
    <content type="html"><![CDATA[<p>多线程中的内存问题，一直被认为是噩梦般的存在，几乎只有高手、大仙才能解决。除了大量的打log、gdb调试、code review以及依靠多年的经验和直觉之外，有没有一些分析的手段和工具呢？答案是肯定的。本文首先介绍其中的一种：mprotect大法。通过mprotect，保护特定的感兴趣的内存，当有线程改写该区域时，会产生一个中断，我们在中断处理函数中把调用栈等信息打印出来。这是大概的思路，不过其中的问题很多，我们慢慢道来。</p>

<!--more-->

<h2 id="section">原理</h2>

<h3 id="mprotect">mprotect函数</h3>

<p>mprotect函数的原型如下：</p>

<p>int mprotect(const void *addr, size_t len, int prot);</p>

<p>其中addr是待保护的内存首地址，必须按页对齐；len是待保护内存的大小，必须是页的整数倍，prot代表模式，可能的取值有PROT_READ（表示可读）、PROT_WRITE（可写）等。</p>

<p>不同体系结构和操作系统，一页的大小不尽相同。如何获得页大小呢？通过PAGE_SIZE宏或者getpagesize()系统调用即可。</p>

<h3 id="section-1">定制中断处理函数</h3>

<p>当线程试图对我们已保护（成只读）的内存进行篡改时，默认情况下程序会收到SIGSEGV错误而退出。能不能不退出并且把相应的调用栈打印出来分析？当然可以。通过如下代码注册你定制的中断处理函数即可：</p>

<pre><code>struct sigaction act;
act.sa_sigaction = your_handler;
sigemptyset(&amp;act.sa_mask);
act.sa_flags = SA_SIGINFO;
if(sigaction(SIGSEGV, &amp;act, NULL) == -1) {
  perror("Register hanlder failed");
  exit(EXIT_FAILURE);
}
</code></pre>

<p>这样，控制流就会到达你编写的your_handler函数上。而your_handler的函数原型是：</p>

<p>void your_handler(int sig, siginfo_t *si, void *unused)；</p>

<p>编写your_handler函数即可？是的，不过这里面有两个注意事项：</p>

<p>1，中断处理函数里不应该调用内存分配函数，否则可能会引起double fault。因此，不适合调用backtrace_symbols（内部会动态分配内存），而是通过backtrace_symbols_fd直接将调用栈信息直接刷到文件中。</p>

<p>2，中断处理函数中应该恢复被保护内存为可写，否则会引起死循环。（再次中断并进入咱们编写的函数）</p>

<h3 id="section-2">封装</h3>

<p>为了方便使用，我封装了一个类，供参考：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include &lt;fcntl.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;signal.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;string.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;stdint.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;sys/mman.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;sys/stat.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;unistd.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;sys/user.h&gt;</span>
</span><span class="line"><span class="cp">#include &lt;execinfo.h&gt;</span>
</span><span class="line"><span class="k">class</span> <span class="nc">MemoryDetector</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">segv_handler</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="kt">siginfo_t</span> <span class="o">*</span><span class="n">si</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">);</span>
</span><span class="line">  <span class="k">static</span> <span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="n">register_handler</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span>
</span><span class="line">    <span class="n">fd_</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="o">|</span><span class="n">O_CREAT</span><span class="p">,</span> <span class="mi">777</span><span class="p">);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">static</span> <span class="kt">int</span> <span class="nf">protect</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="n">address_</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span class="line">    <span class="n">len_</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
</span><span class="line">    <span class="kt">uint64_t</span> <span class="n">start_address</span> <span class="o">=</span> <span class="p">(</span><span class="n">address_</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
</span><span class="line">    <span class="k">return</span> <span class="n">mprotect</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">start_address</span><span class="p">),</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="p">);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">static</span> <span class="kt">int</span> <span class="nf">umprotect</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="kt">uint64_t</span> <span class="n">tmp_address_</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span class="line">    <span class="kt">uint64_t</span> <span class="n">start_address</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp_address_</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
</span><span class="line">    <span class="k">return</span> <span class="n">mprotect</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">start_address</span><span class="p">),</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">static</span> <span class="kt">int</span> <span class="nf">umprotect</span><span class="p">()</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="kt">uint64_t</span> <span class="n">start_address</span> <span class="o">=</span> <span class="p">(</span><span class="n">address_</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
</span><span class="line">    <span class="k">return</span> <span class="n">mprotect</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">start_address</span><span class="p">),</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">static</span> <span class="kt">void</span> <span class="nf">finish</span><span class="p">()</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="n">close</span><span class="p">(</span><span class="n">fd_</span><span class="p">);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="k">private</span><span class="o">:</span>
</span><span class="line">  <span class="k">static</span> <span class="kt">void</span> <span class="n">register_handler</span><span class="p">(</span><span class="n">segv_handler</span> <span class="n">sh</span><span class="p">)</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">sigaction</span> <span class="n">act</span><span class="p">;</span>
</span><span class="line">    <span class="n">act</span><span class="p">.</span><span class="n">sa_sigaction</span> <span class="o">=</span> <span class="n">sh</span><span class="p">;</span>
</span><span class="line">    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">act</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">);</span>
</span><span class="line">    <span class="n">act</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="n">SA_SIGINFO</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">sigaction</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">act</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span><span class="line">      <span class="n">perror</span><span class="p">(</span><span class="s">&quot;Register hanlder failed&quot;</span><span class="p">);</span>
</span><span class="line">      <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">static</span> <span class="kt">void</span> <span class="n">handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="kt">siginfo_t</span> <span class="o">*</span><span class="n">si</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="kt">uint64_t</span> <span class="n">address</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">si_addr</span><span class="p">);</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">address</span> <span class="o">&gt;=</span> <span class="n">address_</span> <span class="o">&amp;&amp;</span> <span class="n">address</span> <span class="o">&lt;</span> <span class="n">address_</span> <span class="o">+</span> <span class="n">len_</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">umprotect</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">si_addr</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
</span><span class="line">      <span class="n">my_backtrace</span><span class="p">();</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">static</span> <span class="kt">void</span> <span class="n">my_backtrace</span><span class="p">()</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</span><span class="line">    <span class="kt">void</span><span class="o">*</span> <span class="n">array</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
</span><span class="line">    <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">backtrace</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
</span><span class="line">    <span class="n">backtrace_symbols_fd</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">fd_</span><span class="p">);</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">static</span> <span class="kt">uint64_t</span> <span class="n">address_</span><span class="p">;</span>
</span><span class="line">  <span class="k">static</span> <span class="kt">int</span> <span class="n">len_</span><span class="p">;</span>
</span><span class="line">  <span class="k">static</span> <span class="kt">int</span> <span class="n">fd_</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这个封装还存在一些问题，比如缺少错误处理，待保护内存必须在一页内等。读者诸君可以根据需要自行完善。</p>

<h2 id="section-3">实战</h2>

<p>来个例子,实战一下吧</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include &quot;test.h&quot; </span><span class="c1">//就是上面封装的MemoryDetector类</span>
</span><span class="line"><span class="cp">#include &lt;thread&gt;</span>
</span><span class="line"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class="line"><span class="kt">uint64_t</span> <span class="n">MemoryDetector</span><span class="o">::</span><span class="n">address_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="kt">int</span> <span class="n">MemoryDetector</span><span class="o">::</span><span class="n">len_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="kt">int</span> <span class="n">MemoryDetector</span><span class="o">::</span><span class="n">fd_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="c1">///////////////////////////////////////</span>
</span><span class="line"><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">usleep</span><span class="p">(</span><span class="mi">2000000</span><span class="p">);</span>
</span><span class="line">  <span class="kt">char</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span class="line">  <span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">111</span><span class="p">;</span><span class="c1">//非法篡改！！！</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class="line">  <span class="n">MemoryDetector</span><span class="o">::</span><span class="n">protect</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="s">&quot;result.tmp&quot;</span><span class="p">;</span><span class="c1">//调用栈信息存放路径</span>
</span><span class="line">  <span class="n">MemoryDetector</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
</span><span class="line">  <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="n">MemoryDetector</span><span class="o">::</span><span class="n">finish</span><span class="p">();</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>用如下方式编译链接以上程序：</p>

<pre><code>g++ -g -rdynamic -std=c++11 -pthread  test.cpp -o test
</code></pre>

<p>程序运行结束后，打开result.tmp文件，看到如下内容：</p>

<pre><code>./test(_ZN14MemoryDetector12my_backtraceEv+0x26)[0x405ce8]
./test(_ZN14MemoryDetector7handlerEiP7siginfoPv+0x60)[0x405cc0]
/lib64/libpthread.so.0[0x339a80f500]
./test(_Z1gv+0x25)[0x405909]
./test(_ZNSt6thread5_ImplIPFvvEE6_M_runEv+0x16)[0x406e2c]
/usr/lib64/libstdc++.so.6[0x3a6f6b6490]
/lib64/libpthread.so.0[0x339a807851]
/lib64/libc.so.6(clone+0x6d)[0x339a4e767d]
</code></pre>

<p>注意其中的第四行：./test(_Z1gv+0x25)[0x405909]。使用addr2line命令：</p>

<pre><code>addr2line -e test 0x405909
</code></pre>

<p>获得非法篡改的代码位置：</p>

<p>/home/yebangyu/test.cpp:13</p>

<p>真相大白了。</p>

<h2 id="section-4">感谢</h2>

<p>我最早知道这个方法，是从我主管<a href="http://weibo.com/yangzhifeng83">杨志丰</a>先生那儿以及他的<a href="http://blog.csdn.net/killmice/article/details/38443343">这篇</a>文章。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入解析Bloom Filter(中)]]></title>
    <link href="http://www.yebangyu.org/blog/2016/01/29/insidethebloomfilter/"/>
    <updated>2016-01-29T22:38:31+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/01/29/insidethebloomfilter</id>
    <content type="html"><![CDATA[<p>本篇将介绍：</p>

<blockquote>
  <ul>
    <li>d-left hashing</li>
    <li>d-left counting bloom filter</li>
  </ul>
</blockquote>

<p>在<a href="http://www.yebangyu.org/blog/2016/01/23/insidethebloomfilter/">上篇</a>文章，我们介绍了Standard Bloom Filter(SBF)和Counting Bloom Filter(CBF)。简单回顾下，我们大概思路和历程是：为了解决允许false positive下的membership问题，我们设计了哈希表算法，由于它所需空间巨大，我们引入bitmap方法；因为它false positive possibility太大，我们引入了SBF，它使用多个独立的、均匀分布的哈希函数。而SBF的一个缺点是不支持删除操作，为了能够删除，我们引入了CBF，然而，CBF存在一个问题。</p>

<p>什么问题呢？那就是空间利用率不高。这可以通过简单的数学计算知道大概：</p>

<p>考察某个位置，该位置的计数器counter的值$\xi$</p>

<p>$P(\xi = c) \approx \binom{mk}{c} {(\frac{1}{n})}^{c}({1-\frac{1}{n}})^{mk-c} = B(km,\frac{1}{n})$</p>

<!--more-->

<p>若二项分布B(n,p)里n很大，p很小时，二项分布的极限近似分布是泊松分布$P(\lambda=k) = \frac{\lambda^k}{k!}{e}^{-\lambda}$，其中$\lambda=np=\frac{km}{n}$，并结合$k = \frac{n}{m}ln2$，可以得到，counter的期望值为：</p>

<p>$E(\xi) = \lambda = np = ln2 \approx 0.7$</p>

<p>即大量的counter的值都是0，空间效率不高。</p>

<p>在介绍新的Bloom Filter之前，我们一起先看看什么是所谓的d-left hashing。</p>

<h3 id="d-left-hashing">d-left hashing</h3>

<p>在d-left hashing中，我们有d张哈希子表（序号分别为1,2,…d，并且假设是从左到右），每张子表都包含B个bucket，每个bucket都包含w个cell，每个cell可以存放一个元素。</p>

<p>为了插入一个元素x，我们：</p>

<p>1，首先通过一个哈希函数hf，得到x的哈希函数值value = hf(x)</p>

<p>2，通过value，得到d个位置（每个位置对应每张子表），表示为：</p>

<p>(1,$B_1$) , (2,$B_2$),… (d,$B_d$)</p>

<p>其中(i,$B_i$)表示第i张子表，Bucket的index为$B_i$。</p>

<p>那么，到底插入哪张表呢？d-left hashing选择$B_i$中负载最小（已经存放的元素最少）的位置。注意，这里说的是bucket的负载，不是子表的负载。如果有多个子表对应的位置负载都是最小，那么选择最左边（序号最小）的子表插入。</p>

<p>为了查找该元素，我们需要检查d个位置，wd个cell（元素）。</p>

<h3 id="d-left-counting-bloom-filter">d-left counting bloom filter</h3>

<p>在基于d-left hashing的CBF中，我们有d张哈希子表（序号分别为1,2,…d，并且假设是从左到右），每张子表都包含B个bucket，每个bucket都包含w个cell，每个cell可以存放一个counter和一个fingerprint。</p>

<p>为了插入一个元素x，我们：</p>

<p>1，首先通过一个哈希函数hf，得到x的哈希函数值value = hf(x)</p>

<p>2，通过value，得到d个位置（每个位置对应每张子表）和对应的fingerprint，表示为d个位置向量：</p>

<p>(1,$B_1$,$fp_1$) , (2,$B_2$,$fp_2$),… (d,$B_d$,$fp_d$)</p>

<p>其中位置向量(i,$B_i$,$fp_i$)表示第i张子表，Bucket的index为$B_i$，fingerprint为$fp_i$。</p>

<p>3，通过d-left hashing将x插入，如果插入的位置(i,$B_i$,$fp_i$)上已经有cell的fingerprint等于$fp_i$，那么只需要将它的counter++即可。</p>

<p>举个栗子，假设某时刻，我们有：</p>

<p><img src="http://7xnljs.com1.z0.glb.clouddn.com/dleftcbf1.jpg" alt="d-leftcbf1" /></p>

<p>2张子表（d=2），每张子表有6个bucket（B=6），每个bucket包括3个cell（w=3），每个cell可以存放一个counter(4位表示，最大值为16)和fingerprint（6位表示）。</p>

<p>假如我们要插入元素x，我们对它进行hash，得到两个位置向量：</p>

<p>(1, 1, 010100)和(2, 2, 010101)</p>

<p>$d_1$子表中index为1的bucket的负载，要小于$d_2$子表中index为2的bucket的负载，因此，我们选择插入$d_1$中，如下：</p>

<p><img src="http://7xnljs.com1.z0.glb.clouddn.com/dleftcbf2.jpg" alt="d-leftcbf2" /></p>

<p>如果得到的位置向量分别是(1, 1, 001100)和(2, 2, 010101)呢？那么，还是插入到$d_1$中index为1的bucket中，但是只需要将第二个cell里的counter++即可，如下图：</p>

<p><img src="http://7xnljs.com1.z0.glb.clouddn.com/dleftcbf3.jpg" alt="d-leftcbf3" /></p>

<p>看起来很完美，但是这种方案在删除时会有问题。比如说，还是刚才的例子，我们欲插入x和y。分别得到x和y的位置向量们：</p>

<p>x: (1, 1, 010100)和(2, 2, 010100)</p>

<p>y: (1, 1, 010100)和(2, 4, 010100)</p>

<p>根据d-left hashing，x被插入到$d_1$中index为1的bucket中；y被插入到$d_2$中index为4的bucket中。好，这没问题。如果现在要删除y呢？我们需要检查两个位置，$d_1$中的index为1的bucket，以及$d_2$中index为4的bucket，要删哪个？fp都是010100啊。这就出现问题。</p>

<p>什么时候会出现这种问题？当以下条件满足时：</p>

<p>1，两个元素的有公共【重合】的位置向量。位置向量相同，表示同一个子表，同一个bucket，以及相同的fingerprint。</p>

<p>2，其中一个元素被插入了公共位置向量对应的位置，另外一个元素没有。</p>

<p>3，欲删除未使用公共位置向量的元素（比如说上例中的y）</p>

<p>为了解决这个问题，作者做了两点改进：</p>

<p>I 引入d轮随机置换。</p>

<p>置换，即一一映射。假设置换为P，输入为a和b，那么将满足：</p>

<p>如果$a = b$，那么$P(a) = P(b)$</p>

<p>如果$a \neq b$ ，那么 $P(a) \neq P(b)$</p>

<p>为了插入x，我们首先通过一个哈希函数hf，计算它的哈希函数值value = hf(x)。然后，我们对value进行d轮随机置换，得到d个位置向量：</p>

<p>$P_1(value) = (1, B_1, fp_1)$</p>

<p>$P_2(value) = (2, B_2, fp_2)$</p>

<p>……</p>

<p>$P_d(value) = (d, B_d, fp_d)$</p>

<p>这里面有一个小问题：如果要插入的元素x和y不等，那么它们的置换可能相等吗？当然可能。因为x和y虽然不等，但是它们的hash value可能相等，这样它们的置换结果即位置向量可能相同。</p>

<p>别忘了，我们是对x和y的hash value进行置换，不是对x和y进行置换。</p>

<p>网上流传很广的<a href="http://blog.csdn.net/jiaomeng/article/details/1526099">这篇</a>文章的解释是错误的，小心！！！</p>

<p>II 插入修正</p>

<p>当得到d个位置向量后，和上面介绍的过程稍微不同：我们首先需要根据d个位置向量，从第1个子表开始，对每个子表$d_i$，去对应的位置$B_i$处查找是否有cell中的fp等于$fp_i$，如果有，我们把相应的counter++，插入动作完成，不用再继续检查后续子表了。</p>

<p>否则，当所有d个子表都没有对应的$fp_i$时，我们运用d-left hashing，插入x。</p>

<p>综合运用这两点，我们知道上面所说的删除时的问题已经不存在了。</p>

<p>假如欲插入x和y，分别对它们的hash value进行d轮（这里d=2）随机置换后，有没有可能得到如下的位置向量？</p>

<p>x: (1, 1, 010100)和(2, 2, 010101)</p>

<p>y: (1, 1, 010100)和(2, 4, 010111)</p>

<p>不可能。</p>

<p>注意到，x和y的第一个位置向量（对应第一张子表）完全相同（bucket index相同，fp也相同），也就是</p>

<p>$P_1(hf(x)) = P_1(hf(y))$</p>

<p>那么可以推出hf(x) = hf(y)，也就是x和y的哈希函数值相等，那么对于任何的i都有$P_i(hf(x)) = P_i(hf(y))$。</p>

<p>因此：</p>

<p>如果$hf(x) = hf(y)$，那么$P_i(hf(x)) = P_i(hf(y))$ (i=1,2,3…d)，假如先插入x后插入y，插入y的时候，会更新counter。后续删除x或者y都不存在上述问题。</p>

<p>如果$hf(x) \neq hf(y)$，那么$P_i(hf(x)) \neq P_i(hf(y))$ (i=1,2,3…d)，那么x和y没有公共的位置向量。后续删除x或者y都不存在上述问题。</p>

<h2 id="section">附录</h2>

<h3 id="section-1">如何随机置换</h3>

<p>作者提供了一个简单的函数：</p>

<p>$P_i(value) = (a * value ) mod 2^B$</p>

<p>其中value的范围是[0, $2^B$]，a是随机的一个奇数。</p>

<h3 id="section-2">数学分析</h3>

<p>首先，如果z是false positive，那么它的哈希函数值会和集合S中的某个元素的哈希函数值相等。也就是</p>

<p>hf(z) = hf(e) 其中 $e\in S$</p>

<p>这是因为，如果z是false positive，那么</p>

<p>$p_i(hf(z)) = p_i(hf(e))$</p>

<p>根据置换的性质，可得hf(z) = hf(e)</p>

<p>因此，false positive possibility为</p>

<p>$P = 1 - (1 - \frac{1}{B}*\frac{1}{2^r})^m$</p>

<p>根据伯努利公式，当x很小时，$(1+x)^a \approx 1 + ax$，所以</p>

<p>$P \approx 1 - (1 - m * \frac{1}{B} * \frac{1}{2^r}) \approx \frac{m}{B*2^r}$</p>

<p>那么d-left CBF的false positive和空间利用情况如何？我们下面简单分析一下：</p>

<p>比较嘛，肯定是相同的空间利用，比较谁的false positive possibility小；相同的false positive possibility下，谁所需空间少。</p>

<p>在CBF中，假设counter需要c位（<a href="http://www.yebangyu.org/blog/2016/01/23/insidethebloomfilter/">上次</a>我们分析过，c取4足矣），那么所需的空间是cn。结合$k = \frac{n}{m}ln2$，false positive possibility大约为$(0.6185)^{\frac{n}{m}}$。</p>

<p>在d-left CBF中，我们选择d=4，B=$\frac{m}{24}$，w=8（平均负载为6，这样$4 * \frac{m}{24} * 6 = m$），counter占用2位，fingerprint占用r位。那么它的空间占用为</p>

<p>$4 * \frac{m}{24} * 8  * (2+r) = \frac{4m(r+2)}{3}$</p>

<p>而false positive possibility的大概为 $\frac{m}{B*2^r} = 24 * \frac{1}{2^r}$ (别忘了，B=$\frac{m}{24}$ )</p>

<p>通过计算不难发现，当空间占用相等时，d-left CBF的false positive possibility是CBF的百分之一；当false positive possibility相等时，d-left CBF所需空间是CBF的一半。</p>

<h2 id="section-3">感谢</h2>

<p>特别感谢<a href="http://www.xiaolili.net/">汪立</a>大神参与讨论。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spinlock and mutex]]></title>
    <link href="http://www.yebangyu.org/blog/2016/01/24/spinlock-and-mutex/"/>
    <updated>2016-01-24T15:50:31+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/01/24/spinlock-and-mutex</id>
    <content type="html"><![CDATA[<p>Spinlock（自旋锁）和mutex作为两种互斥锁，在并行编程中都得到了广泛应用。那么，这两种锁有什么区别吗？</p>

<p>当一个线程对Spinlock加锁时，如果该锁被其他线程占用，那么该线程会通过一个loop不断地重试（ try again and again）；而使用mutex的线程没有得到锁时，会sleep。</p>

<p>因为，当临界区较短时，Spinlock因为没有上下文切换，可能性能更优；当临界区较长时，不断的spin将浪费大量的cpu资源。</p>

<!--more-->

<p>如何实现一个Spinlock呢？下面简单封装了一下，并在Ubuntu 14.04 32bit系统，X86体系结构，Intel I5双核处理器环境下，测试相应的性能：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include&lt;thread&gt;</span>
</span><span class="line"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class="line"><span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="kt">int</span> <span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">spin_lock</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">while</span><span class="p">(</span><span class="n">__sync_lock_test_and_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">spin_unlock</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">__sync_lock_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span>  <span class="mi">10000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">spin_lock</span><span class="p">();</span>
</span><span class="line">    <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span><span class="c1">//tiny critical section</span>
</span><span class="line">    <span class="n">spin_unlock</span><span class="p">();</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</span><span class="line">  <span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</span><span class="line">  <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>2个线程时，这个程序的运行时间为：</p>

<pre><code>real	0m1.082s
user	0m2.060s
sys	0m0.000s
</code></pre>

<p>4个线程时：</p>

<pre><code>real	0m5.701s
user	0m19.400s
sys	0m0.000s
</code></pre>

<p>如果改为std::mutex(lock和unlock成员函数)呢？对比一下：</p>

<p>2个线程：</p>

<pre><code>real	0m3.081s
user	0m2.796s
sys	0m3.344s
</code></pre>

<p>4个线程：</p>

<pre><code>real	0m5.860s
user	0m6.004s
sys	0m14.936s
</code></pre>

<p>不难发现，由于大量的上下文切换，使用mutex时，花在sys上的时间要远比使用Spinlock的要多。</p>

<h2 id="section">小结</h2>

<p>以下两种情况，应该考虑使用spinlock代替mutex：</p>

<p>1，每个processor上（只）运行一个线程。</p>

<p>2，线程平均等待（spin）时间少于两次上下文切换的开销。</p>

<p>当然，一切都离不开实际的测试和分析。</p>

<p>下次，我们将研究更多、更高效的spinlock实现。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入解析Bloom Filter(上)]]></title>
    <link href="http://www.yebangyu.org/blog/2016/01/23/insidethebloomfilter/"/>
    <updated>2016-01-23T13:24:49+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/01/23/insidethebloomfilter</id>
    <content type="html"><![CDATA[<p>本文将介绍：</p>

<blockquote>
  <ul>
    <li>Bloom Filter和它的变形与拓展</li>
    <li>Bloom Filter的使用场景</li>
    <li>Bloom Filter的详细数学分析</li>
  </ul>
</blockquote>

<h2 id="section">提出问题</h2>

<p>Google的爬虫每天需要抓取大量的网页。于是就有一个问题：每当爬虫分析出一个url的时候，是抓呢，还是不抓呢？如何知道这个url已经爬过了？</p>

<!--more-->

<p>这个问题，归纳抽象后可以定义为：</p>

<p>给定一个集合S（注意，这里的集合是传统意义上的集合：元素彼此不同。本文不考虑multiset），给定一个元素e，需要判断$e\in S$ 是否成立。（学术界一般称为membership问题）</p>

<h2 id="section-1">分析问题</h2>

<p>都有哪些方案可以解决这个问题？</p>

<p>一种简单的想法是把url存储在一个哈希表中，每次去表里look up下判断是否存在。假如每个url占用40B，那么10亿条url将占用大概30多GB的内存！Can this be more space efficient ?</p>

<h2 id="section-2">解决问题</h2>

<p>我们可不可以不存url本身？这样子所需空间就会大大减少了。于是我们想到一个很经典的做法：bitmap（位图）。将集合S中的url哈希到bitmap上，给定一个url，只需要将它hash，得到它在bitmap的下标，检查该位置是否为1即可。</p>

<p>这样做空间是省了，可是也产生了一个问题：由于冲突（碰撞），不是集合S中的元素也可能被哈希到值为1的位置上，导致误报。</p>

<p>给定一个元素e，如果实际上$e\notin S$ 而被判为 $e\in S$，那么我们称e是false positive（伪正例。顺便说一句，false positive等的分析在machine learning的classification任务里评价model时非常重要）。</p>

<p>如何降低false positive的概率呢？Bloom Filter的想法是使用多个独立的哈希函数。</p>

<h3 id="standard-bloom-filter">Standard Bloom Filter</h3>

<p>在传统的Bloom Filter中，我们有：</p>

<p>集合S：其大小为m。也就是说，集合中有m个不同元素。</p>

<p>可用内存B：B被当成位数组bitmap来使用，大小为n。（有n个bit）。</p>

<p>哈希函数：有k个独立的、均匀分布的哈希函数。</p>

<p>Bloom Filter的做法是：初始时，所有比特位都初始化为0。对于集合中的每个元素，利用k个哈希函数，对它哈希得到k个位置，将bitmap中的对应的k个位置置为1。</p>

<p>给定一个元素e，为了判断它是否是集合中的元素，也利用该k个函数得到k个位置，检查该k个位置是否都为1，如果是，认为$e\in S$，否则认为$e\notin S$。</p>

<p>不难看出，如果$e\in S$，那么Bloom Filter肯定会正确判断出$e\in S$，但是它还是可能产生false positive。那么，如何分析false positive的概率呢？</p>

<p>false positive发生时，表示哈希该元素后得到的k个位置都为1。这个概率大概为：</p>

<p>$P\approx p_1^k$</p>

<p>其中$p_1$代表某位为1的概率，它等于：</p>

<p>$p_1 = 1 - p_0$</p>

<p>对于$p_0$，表示某个特定的比特位为0。什么时候该位才为0呢？也就是说m个元素各自经过k次哈希得到km个对象，没有一个对象定位到了该位置。某个对象定位到该位置的概率为$\frac{1}{n}$，因此我们可以得到：</p>

<p>$p_0 = (1 - \frac{1}{n})^{mk}$</p>

<p>分析$p_0$。在实际应用中，n一般很大，根据重要极限公式，我们有：</p>

<p>$p_0 = (1 - \frac{1}{n})^{mk} = (1-\frac{1}{n})^{-n{\frac{mk}{-n}}} \approx e^{-\frac{mk}{n}} $</p>

<p>代入到最上面的那个式子，我们不难得到：</p>

<p>$P \approx ({1 - e^{-\frac{mk}{n}}})^{k}$</p>

<p>当k为何值时，P取得最小，false positive possibility最低呢？</p>

<p>令 $f(k) = ({1 - e^{-\frac{mk}{n}}})^{k}$</p>

<p>$ln(f(k)) = kln({1 - e^{-\frac{mk}{n}}})$</p>

<p>$\frac{f\prime(k)}{f(k)} = ln({1 - e^{-\frac{mk}{n}}}) + k(\frac{1}{1 - e^{- \frac{mk}{n}}})(- e^{-\frac{mk}{n}})(\frac{-m}{n})$</p>

<p>$f\prime(k) = f(k)(ln({1 - e^{-\frac{mk}{n}}}) + k(\frac{1}{1 - e^{- \frac{mk}{n}}})(- e^{-\frac{mk}{n}})(\frac{-m}{n}))$</p>

<p>看起来够复杂了，然而别怕！！！</p>

<p>令$f\prime(k) = 0$ ， 我们有(注意到$f(k) &gt; 0$ 恒成立)：</p>

<p>$ln({1 - e^{-\frac{mk}{n}}}) + k(\frac{1}{1 - e^{- \frac{mk}{n}}})(- e^{- \frac{mk}{n}})(\frac{-m}{n}) = 0$</p>

<p>作代换，令$\lambda = e^{-\frac{mk}{n}}$ 则 $k = \frac{-nln\lambda}{m}$，代入上式，得到</p>

<p>$(1-\lambda)ln(1-\lambda) = \lambda ln\lambda$</p>

<p>因此$\lambda = \frac{1}{2}$ ， $k = \frac{n}{m}ln2$</p>

<p>也就是说，当n和m固定时，选择$k = \frac{n}{m}ln2$ 附近的一个整数，将使false positive possibility最小。</p>

<p>工程实现时，我们需要k个哈希函数或者哈希函数值。如何构造和获得k个独立的哈希函数呢？这篇<a href="https://www.eecs.harvard.edu/~michaelm/postscripts/rsa2008.pdf">论文</a> 提出，只需要两个独立的哈希函数hf1和hf2即可，也就是通过如下方式获得k个哈希函数值：</p>

<p>hash value = hf1(key) + i*hf2(key)</p>

<p>其中i=0、1、2…k-1</p>

<h3 id="counting-bloom-filter">Counting Bloom Filter</h3>

<p>除了存在false positive这个问题之外，传统的Bloom Filter还有一个不足：无法支持删除操作（想想看，是不是这样的）。而Counting Bloom Filter(CBF)就是用来解决这个问题的。</p>

<p>在CBF中，维护的不是单纯的标示0或者1的比特位，而是计数器counter。对于集合中的每个元素，利用k个哈希函数，对它哈希得到k个位置，将对应的k个位置上的k个counter都加1。删除时，只需要把k个counter都减1即可。</p>

<p>那么，这个counter应该占用几位呢？分配太多，浪费空间；分配太少，容易溢出。通过下面的分析，我们可以知道，实际使用时，4位足矣。</p>

<p>考察（是考察，不是考查。这两个词有什么区别？）某个位置，该位置的计数器counter的值$\xi$</p>

<p>$P(\xi = c) \approx \binom{mk}{c} {(\frac{1}{n})}^{c}({1-\frac{1}{n}})^{mk-c} = B(km,\frac{1}{n})$</p>

<p>这个式子有点点复杂，然而回忆下概率论里的知识：若二项分布B(n,p)里n很大，p很小时，二项分布的极限近似分布是泊松分布$P(\lambda=k) = \frac{\lambda^k}{k!}{e}^{-\lambda}$，其中$\lambda=np$，因此：</p>

<p>$P(\xi = c) \approx \binom{mk}{c} {(\frac{1}{n})}^{c}({1-\frac{1}{n}})^{mk-c} \approx \frac{({\frac{km}{n}})^{c}}{c!}{e}^{-{\frac{km}{n}}}$</p>

<p>令$k = \frac{n}{m}ln2$，代入，我们得到</p>

<p>$P(\xi &gt;16) \approx \frac{(ln2)^{16}}{16!} * \frac{1}{2} &lt; \frac{1}{16!} = \frac{1}{20922789888000}$</p>

<p>也就是说，选择4位来存counter在实际情况中已经足矣，发生溢出的概率极小。</p>

<h2 id="section-3">本文小结</h2>

<p>总结下，Bloom Filter可以用在什么地方，或者说，在什么场景下，你应该想到这种技术：</p>

<p>1，回答是或者不是的问题。你需要判断一个元素是否属于某个集合，仅仅这样。你不应该要求更多。如果你想获得该元素对应的value或者还有其他payload，那么bloom filter不适合你，你需要哈希表。</p>

<p>2，允许false positive。也就是说，发生false positive不应该是致命的。比如说，搜索引擎的爬虫里，如果url不是set的元素，却被bloom filter过滤了，那么顶多就是不抓它而已，没啥特别大的损失。</p>

<p>3，空间敏感。作为一种概率数据结构，Bloom Filter不存储原始数据（比如说url），这也是它为什么space efficient的本质原因。</p>

<p>有了Standard Bloom Filter和Counting Bloom Filter，似乎可以满足绝大多数需求了，然而，这里面还是有问题。什么问题？请看<a href="http://www.yebangyu.org/blog/2016/01/29/insidethebloomfilter/">下集</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Concurrent and Parallel]]></title>
    <link href="http://www.yebangyu.org/blog/2016/01/17/concurrenyandparallism/"/>
    <updated>2016-01-17T09:49:00+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/01/17/concurrenyandparallism</id>
    <content type="html"><![CDATA[<p>什么是并发(<strong>Concurrency，Concurrent</strong>)，什么是并行(<strong>parallism，Parallel</strong>)？这两者有什么区别？本文收录一下我听过的、我见过的、我看过的一些人的看法。仅供参考：</p>

<h2 id="paul-butcher">Paul Butcher</h2>

<p><strong>Paul Butcher</strong>在他的《<strong>Seven Concurrency Models in Seven Weeks</strong>
》里开篇就谈到：</p>

<!--more-->

<p>An alternative way of thinking about this is that concurrency is an aspect of
the problem domain—your program needs to handle multiple simultaneous
(or near-simultaneous) events. Parallelism, by contrast, is an aspect of the
solution domain—you want to make your program faster by processing different
portions of the problem in parallel</p>

<p>也就是说，并发是<strong>问题域</strong>，并行是<strong>解决域</strong>。问题是并发的，解决方法是并行的。</p>

<h2 id="rob-pike">Rob Pike</h2>

<p><strong>Rob</strong>是<strong>Go</strong>语言之父，《<strong>The Unix Programming Environment</strong>》 和 《<strong>The Practice of Programming</strong>》（最近正在重读这本小册子）的作者。他有一个经典的解释：</p>

<p>Concurrency is about dealing with lots of things at once.</p>

<p>Parallelism is about doing lots of things at once.</p>

<p>嘿嘿，这个有点意思，不过只能意会了。</p>

<h2 id="paul-e-mckenney">Paul E. McKenney</h2>

<p>又是一个<strong>Paul</strong>。不过这个<strong>Paul</strong>大叔是<strong>IBM</strong>的研究人员，写了一本非常幽默并且有深度的书：《<strong>Is Parallel Programming Hard, And, If So, What Can You Do About It?</strong>》（最近一直在细读，并且做读书笔记，感兴趣的朋友可以参考我的相关<a href="http://www.yebangyu.org/blog/categories/bing-xing-bian-cheng/">博客</a>。） 在这本书（<strong>v2015.01.31a</strong>版本）的第<strong>319</strong>页，有一个附录，介绍 <strong>What is the Difference Between</strong>
“<strong>Concurrent</strong>” <strong>and</strong> “<strong>Parallel</strong>”?时说：</p>

<p>From a classic computing perspective, “concurrent” and
“parallel” are clearly synonyms. However, this has not
stopped many people from drawing distinctions between
the two</p>

<p>说明<strong>Paul</strong>大叔认为，其实这两者是一回事，有些人非得区分。好吧，那就区分吧。这些人是如何区分呢？有两个<strong>perspective</strong>：</p>

<p>The first perspective treats “parallel” as an abbreviation
for “data parallel,” and treats “concurrent” as pretty
much everything else</p>

<p>也就是说，<strong>concurrency</strong>有很强的<strong>interdependencies</strong>，它们之间可能要做各种通信，基于比如说<strong>locks</strong>啊，<strong>transactions</strong>啊，等等同步机制。相比，<strong>parallel</strong>中组件的相互依赖就很少。新浪微博网友 <a href="http://weibo.com/u/1085583241">@小恶魔提利昂</a>就持这种观点，他说：“并发任务处理的时候，会在并发处理时候可以交换信息，有CSP式的，也可以内存共享式的，但是在外部看到的效果是若干核或若干线程/协程同时对应这些并发任务。并行处理的话，同时处理的任务要做到上下文环境都是隔离的。”</p>

<p>Now, this second perspective can be thought of as making
the workload match the available scheduler, with parallel
workloads able to operate on a simple scheduler
and concurrent workloads requiring more sophisticated
schedulers.</p>

<p>恩，第二个角度就是需不需要复杂的<strong>scheduler</strong>。</p>

<p>但是<strong>Paul</strong>大叔说，这两个视角很可能是不可兼得或者说矛盾滴。此话怎讲？</p>

<p>考虑每个<strong>CPU</strong>一个线程的基于<strong>lock</strong>通信的程序。是<strong>Concurrency</strong>吗？从第一个角度讲，是的，用<strong>lock</strong>啊，各种同步各种通信啊。从第二个角度看，又不是。</p>

<p>以上就是<strong>Paul McKenney</strong>大致的观点。</p>

<h2 id="yebangyu">yebangyu</h2>

<p><strong>yebangyu</strong>是博主，<strong>yebangyu.org</strong>公司CEO兼站长兼董事长兼老板，苦逼屌丝底层搬砖码农。恩，就是我了。</p>

<p>个人观点：</p>

<p>1，首先，持<strong>Paul McKenney</strong>的观点，没必要区分这两个词。</p>

<p>2，<strong>Concurrency</strong>这个单词含有类“occur”的词根，表示发生，<strong>con</strong>代表共同、一起，指共同发生的意思。而<strong>parallel</strong>词根是<strong>para</strong>，表示相同的、类似、平行的、差不多的。因为，也可以认为问题是同时发生的，解决方法是平行处理。</p>

<p>3，写书在取书名的时候需要区分。如果你是讲<strong>MPI、Open MP</strong>这类技术，建议用并行或者说<strong>Parallel Computing</strong>。如果是讲<strong>lock free、multi-thread</strong>这些共享内存编程的，建议用<strong>Concurrency</strong>或者<strong>Concurrency Programming</strong>。</p>

<p>那么，<strong>Go</strong>语言这种<strong>CSP</strong>类型的<strong>Channel</strong>的呢？个人认为，都可以吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Memory Consistency和Cache Coherence]]></title>
    <link href="http://www.yebangyu.org/blog/2016/01/09/memoryconsistencyandcachecoherence/"/>
    <updated>2016-01-09T22:52:52+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/01/09/memoryconsistencyandcachecoherence</id>
    <content type="html"><![CDATA[<h2 id="memory-consistency">Memory Consistency</h2>

<p><strong>Memory Consistency</strong>(<strong>MC</strong>)，有时候又叫做<strong>Memory Consistency Model</strong>或者<strong>Memory Model</strong>。为了理解为什么需要引入这种东西，我们首先看以下程序：</p>

<!--more-->

<pre><code>初始：x=0 y=0

Thread1：

S1：x=1

L1：r1=y

Thread2：

S2：y=2

L2：r2=x
</code></pre>

<p>其中，<strong>S1、S2、L1、L2</strong>是语句代号（<strong>BTW</strong>，<strong>S</strong>表示<strong>Store</strong>，<strong>L</strong>表示<strong>Load</strong>）；<strong>r1</strong>和<strong>r2</strong>是两个寄存器。<strong>x</strong>和<strong>y</strong>是两个不同的内存变量。</p>

<p>两个线程执行完之后，<strong>r1</strong>和<strong>r2</strong>可能是什么值？</p>

<p>注意到线程是并发、交替执行的，下面是可能的执行顺序和相应结果：</p>

<p><strong>S1 L1 S2 L2</strong> 那么<strong>r1=0 r2=2</strong></p>

<p><strong>S1 S2 L1 L2</strong> 那么<strong>r1=2 r2=1</strong></p>

<p><strong>S2 L2 S1 L1</strong> 那么<strong>r1=2 r2=0</strong></p>

<p>这些都是意料之内、情理之中的。但是在<strong>x86</strong>体系结构下，很可能得到<strong>r1=0 r2=0</strong>这样的结果。是不是大吃一惊？</p>

<p>如果没有<strong>Memory Consistency</strong>，那么程序员对于自己编写的多线程程序会输出什么将一无所知：天知道会输出什么。</p>

<p>因此，<strong>Memory Consistency</strong>就是程序员（编程语言）、编译器、CPU间的一种协议。这个协议保证了程序访问内存时可能得到什么值，会得到什么值。</p>

<h2 id="sequential-consistency">Sequential Consistency</h2>

<p>在<strong>Sequential Consistency</strong>这种<strong>Memory Model</strong>下，刚才讨论的那个程序不可能输出<strong>r1=0 r2=0</strong>这种结果。怎么说？这就牵涉到一个问题：什么是<strong>Sequential Consistency</strong>（<strong>SC</strong>）。</p>

<p>根据<strong>Leslie Lamport</strong>在<strong>1979</strong>年<strong>9</strong>月发表的论文《<strong>How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs</strong>》里提出的<strong>SC</strong>的定义：</p>

<p>the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program.</p>

<p>根据这个定义，在<strong>SC</strong>模型下，任何<strong>execution</strong>的执行顺序（我们称为<strong>Memory Order</strong>）必须<strong>respect</strong>每个线程的<strong>Program Order</strong>。什么是<strong>Program Order</strong>？对于以上程序，在<strong>Thread1</strong>中，<strong>S1</strong>先于<strong>L1</strong>（不妨记为<strong>S1&lt;L1</strong>）；在<strong>Thread2</strong>中，<strong>S2</strong>先于<strong>L2</strong>（记为<strong>S2&lt;L2</strong>）。这就是<strong>Program Order</strong>。</p>

<p>请时刻注意，<strong>Program Order</strong>只针对某个线程内的语句而言，不涉及到跨线程。比如<strong>Thread1</strong>中的<strong>S1</strong>和<strong>Thread2</strong>中的<strong>L2</strong>，就无所谓什么<strong>Program Order</strong>了。</p>

<p>好了，现在知道为什么在<strong>SC</strong>下，有些结果可能出现，有些不可能了。</p>

<p><strong>S1 L1 S2 L2 r1=0 r2=2</strong> 没问题，没有违背<strong>S1&lt;L1 S2&lt;L2</strong></p>

<p><strong>S1 S2 L1 L2 r1=1 r2=2</strong> 没问题，没有违背<strong>S1&lt;L1 S2&lt;L2</strong></p>

<p><strong>S2 L2 S1 L1 r1=2 r2=0</strong> 没问题，没有违背<strong>S1&lt;L1 S2&lt;L2</strong></p>

<p>而对于<strong>r1=0 r2=0</strong>，在<strong>SC</strong>下，我们找不到一个能<strong>respect Program Order</strong>的<strong>Memory Order</strong>。因为<strong>r1=0</strong>，说明<strong>L1&lt;S2</strong>，<strong>r2=0</strong>说明<strong>L2&lt;S1</strong>；而<strong>S1&lt;L1，S2&lt;L2</strong>，不难看出这里形成了一个环。</p>

<h2 id="cache-coherence">Cache Coherence</h2>

<p>还是先搬出这张图吧:</p>

<p><img src="http://7xnljs.com1.z0.glb.clouddn.com/cpuand%20cache.png" alt="memorycache" /></p>

<p>(图片来源于<strong>Paul</strong>大叔的《<strong>Is Parallel Programming Hard</strong>》这本书第三章)</p>

<p>多个<strong>CPU cores</strong>，每个<strong>core</strong>上有自己的<strong>Cache</strong>。我们知道，<strong>Cache</strong>是部分内存的映射和缓存，或者说，副本。这就带来一个问题：副本一致性。内存只有一个，每个<strong>cpu cores</strong>却有自己的内存副本，如何保证大家看到的内容是一样的、一致的、正确的呢？这就是<strong>Cache Coherence(CC)</strong>要解决的问题。</p>

<h2 id="cache-coherence--vs-memory-consistency">Cache Coherence  VS Memory Consistency</h2>

<p>从以上分析，我们不难看出，<strong>CC</strong>和<strong>MC</strong>涉及的是两个不同层面的东西，解决的是不同的问题，不可混淆。<strong>CC</strong>解决的是副本一致性问题；<strong>MC</strong>保证的是多线程程序访问内存时可以（可能）读到什么值。</p>

<p>两者有联系吗？有。实现<strong>Memory Consistency</strong>时可能会使用到<strong>Cache Coherence</strong>。细节下次我们接着聊。</p>

<h2 id="section">附录</h2>

<p>1，在并行编程中，我们常常有一个问题，或者需求：比如说上面的那个程序，如何保证线程<strong>2</strong>读到的<strong>x</strong>是线程<strong>1</strong>更新（<strong>x=1</strong>）后的<strong>x</strong>的值呢？</p>

<p>如果不加任何同步设施，仅仅考虑上面的程序，那么答案是：无法保证。因为线程的推进速度不同，哪条指令先被执行也一无所知。这个程序重跑几次，也可能输出不同的结果出来。</p>

<p>也就是说，<strong>Memory Model</strong>保证的是，例如，当线程<strong>2</strong>看到<strong>x</strong>等于<strong>1</strong>的时候，线程<strong>1</strong>是否已经执行了<strong>L1</strong>。也就是说，<strong>Memory Model</strong>确保当一件事情发生时，有其他什么事情<strong>has happened</strong>。在<strong>SC</strong>中，当<strong>L1</strong>发生时，说明或者说暗示着，<strong>S1</strong>已经发生了。</p>

<p>2，为什么<strong>x86</strong>下可能得出<strong>r1=0 r2=0</strong>的结果？</p>

<p>因为<strong>S1</strong>是写一个内存变量而<strong>L1</strong>是读取另一个内存变量（两个变量，或者说两个内存地址），这种情况下的写读可能被<strong>CPU</strong>乱序：先执行<strong>L1</strong>，再执行<strong>S1</strong>。（为了性能，所谓的延后写）</p>

<h2 id="section-1">致谢</h2>

<p>本文发出后，微博网友@linyvxiang 指出了其中的一个笔误，非常感谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下C++程序计时方法]]></title>
    <link href="http://www.yebangyu.org/blog/2016/01/07/timingcprograminlinux/"/>
    <updated>2016-01-07T23:02:14+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/01/07/timingcprograminlinux</id>
    <content type="html"><![CDATA[<p>最近简单学习了下<strong>Linux</strong>下<strong>C++</strong>程序计时的一些函数和方法，总结如下。没啥<strong>insight</strong>了。</p>

<p>方法一：</p>

<p>如果是想统计某个程序的运行时间，那么可以使用</p>

<pre><code>time ./a.out
</code></pre>

<!--more-->

<p>方法二：</p>

<p>如果是想对某个函数或者语句进行计时，那么有别的方法。比如说，<code>gettimeofday</code>函数。直接贴示例代码:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include &lt;sys/time.h&gt;</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="c1">//...</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">struct</span> <span class="n">timeval</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>
</span><span class="line">  <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">  <span class="n">f</span><span class="p">();</span>
</span><span class="line">  <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">  <span class="c1">//那么函数f运行所花的时间为</span>
</span><span class="line">  <span class="c1">//deltaT = (t2.tv_sec-t1.tv_sec) * 1000000 + t2.tv_usec-t1.tv_usec 微秒</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><code>gettimeofday</code>只能精确到微秒，并且它受系统时钟的影响(它的原理就是通过读取系统时钟，因此当计时的这段时间里有其他程序修改了系统时钟，那么结果将不准确)。</p>

<p>如果想精确到纳秒呢？继续往下看：</p>

<p>方法三：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include &lt;time.h&gt;</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="c1">//...</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">timespec</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>
</span><span class="line">  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t1</span><span class="p">);</span>
</span><span class="line">  <span class="n">f</span><span class="p">();</span>
</span><span class="line">  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t2</span><span class="p">);</span>
</span><span class="line">  <span class="c1">//那么f所花时间为</span>
</span><span class="line">  <span class="c1">//deltaT = (t2.tv_sec - t1.tv_sec) * 10^9 + t2.tv_nsec - t1.tv_nsec 纳秒</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这里说的都是<strong>wall clock</strong>，如果想获得<strong>cpu</strong>执行时间，以及了解<code>clock_gettime</code>参数的解释和可能的取值，可以<strong>man</strong>一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[诡异的程序性能问题]]></title>
    <link href="http://www.yebangyu.org/blog/2015/12/30/falsesharing/"/>
    <updated>2015-12-30T23:06:12+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/12/30/falsesharing</id>
    <content type="html"><![CDATA[<p>本文所使用的环境是<strong>Ubuntu 14.04 32bit</strong>系统，<strong>Intel I5</strong>处理器，<strong>X86</strong>体系结构</p>

<h2 id="section">提出问题</h2>

<p>如果我说下面的程序存在性能问题，您信吗？</p>

<!--more-->

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include&lt;thread&gt;</span>
</span><span class="line"><span class="kt">int32_t</span> <span class="n">global</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="o">++</span><span class="n">global</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="o">++</span><span class="n">global</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">thread1</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">thread2</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
</span><span class="line">  <span class="n">thread1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="n">thread2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这个程序，在我的电脑上，运行时间为：</p>

<pre><code>real	0m0.822s
user	0m1.596s
sys     0m0.000s
</code></pre>

<h2 id="section-1">分析问题</h2>

<p>有人说，两个线程分别操作不同的计数器，这么完美的程序，会有性能问题？</p>

<p>答案是：有。</p>

<p>恩，原因在于大名鼎鼎的<strong>false sharing</strong>。如果您看过我以前写的<a href="http://www.yebangyu.org/blog/2015/10/18/hardwareanditshabit/">这篇</a>博客，应该还记得:现在的计算机一般由一个内存、一个<strong>CPU</strong>组成，而包含多个<strong>CPU Cores</strong>和<strong>Cache</strong>。如这幅图所示：</p>

<p><img src="http://7xnljs.com1.z0.glb.clouddn.com/cpuand%20cache.png" alt="memorycache" /></p>

<p><strong>cacheline</strong>是<strong>cache</strong>块单位，一个<strong>cacheline</strong>大小一般在<strong>32</strong>到<strong>256</strong>字节左右。<strong>cacheline</strong>是这张图中不同模块的数据交互元素。</p>

<p>在上面程序中，<strong>global</strong>是两个<strong>4</strong>字节变量构成的数组，大小为<strong>8</strong>字节，很可能被放到同一个<strong>cacheline</strong>里。当运行在<strong>CPU1 Core</strong>上的线程<strong>thread1</strong>修改了<strong>global[0]</strong>时，会让运行在<strong>CPU2 Core</strong>上对应<strong>global[0]</strong>和<strong>global[1]</strong>的<strong>cacheline</strong>失效，因此运行在<strong>CPU2 Core</strong>上的线程<strong>thread2</strong>修改<strong>global[1]</strong>时会发生<strong>cache miss</strong>，接着它访问内存，修改<strong>global[1]</strong>，这也会让<strong>CPU1 Core</strong>中的<strong>cacheline</strong>失效。很明显，这里面会有大量的<strong>cache miss</strong>和为了缓存一致性而花费的通信开销。</p>

<p>因此这种<strong>false sharing</strong>发生在多核、多线程环境中。单核或者单线程不会有<strong>false sharing</strong>问题。</p>

<p>遗憾的是，程序里存在这样的问题，并不容易通过肉眼发现。</p>

<p>幸运的是，这种问题一旦知道，就比较好解决。</p>

<h2 id="section-2">解决问题</h2>

<p>解决方法一：让这两个计数器间隔足够大，让它们不要在同一个<strong>cacheline</strong>里，不就行了么？</p>

<p>恩，定义一个<strong>global[10000]</strong>，然后线程<strong>1</strong>利用<strong>global[0]</strong>，线程<strong>2</strong>利用<strong>global[9999]</strong>，应该就可以了。</p>

<p>什么？这么愚蠢的方法都想得出来？接着往下看。</p>

<p>解决方法二：假如<strong>global</strong>不是一个数组呢？而是包含多个变量的结构体呢(这种情形也很常见)？上面的方法就不灵了吧？</p>

<p>恩，上面的方法不灵了，而且上面的方法太笨。网上有很多资料告诉您怎么定义变量让其<strong>cacheline aligned</strong>，这也是那些博客千篇一律的做法。还有没有其他方法？有。接着往下看。</p>

<p>解决方法三：重点来了。</p>

<p>我们其实可以在线程里使用局部变量！</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include&lt;thread&gt;</span>
</span><span class="line"><span class="kt">int32_t</span> <span class="n">global</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">counter1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="o">++</span><span class="n">counter1</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">global</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">counter2</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span><span class="line">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="o">++</span><span class="n">counter2</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">global</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter2</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">thread1</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">thread2</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
</span><span class="line">  <span class="n">thread1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="n">thread2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><strong>counter1</strong>和<strong>counter2</strong>在自己的线程栈上，<strong>cacheline</strong>位于对应的<strong>CPU core</strong>里，大家相安无事。只有执行第<strong>9</strong>行和第<strong>17</strong>行时代价可能高点。</p>

<p>这个程序，在我的电脑上运行时间为：</p>

<pre><code>real	0m0.293s
user	0m0.580s
sys     0m0.000s
</code></pre>

<p>解决方法四：</p>

<p><strong>global</strong>神马变量？全局变量。<strong>counter1/counter2</strong>神马变量？局部变量。</p>

<p>有没有一种东东，既有全局的性质，又有局部的效果（线程私有）呢？</p>

<p>恩，如果您看过我以前写的<a href="http://www.yebangyu.org/blog/2015/10/31/linux-parallen-programmming-infrastructure/">这篇</a>博客，就不会对<strong>__thread</strong>感到陌生。对！提供强大<strong>scalability</strong>的利器，就是它了！</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include&lt;thread&gt;</span>
</span><span class="line"><span class="n">__thread</span> <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="o">++</span><span class="n">counter</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="o">++</span><span class="n">counter</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">thread1</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">thread2</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
</span><span class="line">  <span class="n">thread1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="n">thread2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这个程序在我的电脑上的运行时间为：</p>

<pre><code>real	0m0.325s
user	0m0.644s
sys     0m0.000s
</code></pre>

<p>不过其他线程如何读取到每个计数线程的<strong>counter</strong>呢？不难，但是也不是那么简单，背后涉及到很多问题（其实本文最大的目的是通过<strong>false sharing</strong>，揭示<strong>partition</strong>这种并发编程里最大的设计原则）。我们下次专门聊。</p>

<h2 id="section-3">附录</h2>

<p>1，编译以上多线程程序的时候，请使用：</p>

<pre><code>g++ -pthread -std=c++11 xxx.cpp
</code></pre>

<p>如果没有指定<code>-pthread</code>，那么程序可以编译链接通过，运行时报错：</p>

<p>terminate called after throwing an instance of ‘std::system_error’</p>

<p>what():  Enable multithreading to use std::thread: Operation not permitted</p>

<p>Aborted (core dumped)</p>

<p>2，程序计时我用的是 <code>time ./a.out</code>的方式。</p>

<h2 id="section-4">致谢</h2>

<p>本文发出后，微博网友@Debin_IIE指出了一个笔误。非常感谢。</p>
]]></content>
  </entry>
  
</feed>
