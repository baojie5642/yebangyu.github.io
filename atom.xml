<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Yebangyu's Blog]]></title>
  <link href="http://www.yebangyu.org/atom.xml" rel="self"/>
  <link href="http://www.yebangyu.org/"/>
  <updated>2015-10-18T13:05:41+08:00</updated>
  <id>http://www.yebangyu.org/</id>
  <author>
    <name><![CDATA[Yebangyu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Hardware and Its Habit]]></title>
    <link href="http://www.yebangyu.org/blog/2015/10/18/hardwareanditshabit/"/>
    <updated>2015-10-18T12:29:44+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/10/18/hardwareanditshabit</id>
    <content type="html"><![CDATA[<p>最近在阅读《Is parallel programming hard》这本书，本篇就是整理其中第三章《Hardware and its habit》，不是单纯的翻译，只是一个总结，略有补充。</p>

<p>这章介绍了影响CPU执行效率的几个因素。具体包括：</p>

<blockquote><ul>
<li>流水线被打断</li>
<li>内存访问</li>
<li>原子操作</li>
<li>Memory Barrier</li>
<li>Cache Misses</li>
<li>IO 操作</li>
</ul>
</blockquote>

<!--more-->


<p>这其中，前面两个，流水线被打断以及内存访问主要针对串行程序，而后面四个主要针对并行程序，因为在并行程序中显得更为突出。</p>

<h3>流水线被打断</h3>

<p>现代CPU执行指令采用流水线设计和指令预取机制，而影响流水的两种重要情况是停机等待和分支判断失败。前者是CPU没有足够的信息来判断取哪些指令（例如，涉及到C++中的虚函数时）。而分支判断失败，则是取了指令but没取对。例如</p>

<pre><code>int a = get();
if (a == 1 )
{
  //A
}
else
{
  //B
}
</code></pre>

<p>假设CPU预取指令A。当预测失败时（a不等于1），流水线中A的指令需要被冲刷（flush），继而载入B指令。冲刷流水线和载入B指令都是非常昂贵的操作，因此这深深地影响了效率。</p>

<p>因此，在实际编程时，应该将最有可能执行的代码放到最前面。在gcc中内置提供了likely和unlikely宏，来优化程序分支判断。</p>

<pre><code>#define  likely(x)        __builtin_expect(!!(x), 1) 
#define  unlikely(x)      __builtin_expect(!!(x), 0) 
</code></pre>

<p>因此，上面的程序可以改写为：</p>

<pre><code>int a = get();
if (unlikely（a == 1 )) //根据实际情况选择unlikely或者likely
{
  //A
}
else
{
  //B
}
</code></pre>

<h3>内存访问</h3>

<p>这个不用说了，内存访问是昂贵操作，相对于寄存器、cache而言。</p>

<p>在上世纪的系统中，从内存中读一个值的速度要比CPU执行一条指令快速。后来，由于CPU的快速发展以及内存容量的增大，这种局面发生了改变。你能想象只有4KB内存的机器吗？现在，光是cache都不止4KB了。</p>

<p>数组通常有比较好的内存访问模式，也就是说访问了a[0]，就可以将a[1],a[2],a[3]等存进cache，等访问到a[1]时不需要去访问内存了。但是一般用指针实现的链表的访问模式则比较差。恩，所谓的数据局部性。</p>

<h3>原子操作</h3>

<p>gcc内置提供了一系列的原子操作，包括著名的用于CAS(compare and swap)的__sync_bool_compare_and_swap等。当多个线程对一个内存变量进行原子操作时，往往依赖于硬件支持。在x86下，原子操作时，锁住总线，防止其他cpu core访问该内存单元。</p>

<h3>Memory Barrier</h3>

<p>CPU对指令可能采取乱序执行，以达到优化的目的。但是，并发访问的锁破坏了这种机制。</p>

<pre><code>c = 3;
lock.lock();
a = 1;
b = 2;
lock.unlock();
d = 4;
</code></pre>

<p>b=2绝对不会在a=1之前执行，d=4绝对不会在a=1之前执行，c=3绝对不会在a=1之后执行。</p>

<p>lock和unlock中包含了memory barrier。由于memory barrier和乱序执行是对着干的，用来防止乱序执行的；而乱序执行一般是优化的手段和方法，因此memory barrier往往带来性能下降。</p>

<h3>Cache Misses</h3>

<p>先贴一张现代CPU和cache架构粗略图。</p>

<p><img src="http://7xnljs.com1.z0.glb.clouddn.com/cpuand%20cache.png" alt="cmd-markdown-logo" /></p>

<p>多个CPU core，一个内存。cacheline是cache块单位，一般在32到256字节左右。cacheline是这张图中不同模块的数据交互元素。</p>

<p>当cpu需要进行内存写入操作时，需要先把包含那个变量的cacheline读入自己的cache，并且确保其他的cpu cores不包含该cacheline。</p>

<p>书中举了一个相对简单的例子：cpu 0需要对一个变量进行cas操作，检查自己的cache，发现没有。这时候：</p>

<p>1，它通过Interconnect(cpu0 &amp; cpu1)去cpu1的cache检查，发现木有。</p>

<p>2，请求发给System Interconnect，检查剩下的3个die（本图里，每两个cores组成一个die）得知cache位于由cpu6和cpu7 组成的那个die里。</p>

<p>3，请求发给由cpu6 和cpu 7组成的那个die里的Interconnect(cpu6 &amp; cpu7)，得知cacheline位于cpu 7的cache里。</p>

<p>4，cpu7 把cacheline发送给Interconnect(cpu6 &amp; cpu7), and flushes the cacheline from its cache</p>

<p>5，Interconnect(cpu6 &amp; cpu7)将cacheline发送给System Interconnect。</p>

<p>6，System Interconnect将cacheline发送给Interconnect（cpu0 &amp; cpu1）</p>

<p>7，Interconnect（cpu0 &amp; cpu1）将cacheline存入cpu0的cache里。</p>

<p>是啊，这已经是简单的情况了。想想看，有没有什么可能更复杂？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[计算机读研的若干建议]]></title>
    <link href="http://www.yebangyu.org/blog/2015/10/17/whattodoinmaster/"/>
    <updated>2015-10-17T14:34:04+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/10/17/whattodoinmaster</id>
    <content type="html"><![CDATA[<p>你想进什么公司，和你读什么计算机方向，关系不是很大。只要是理工科的学生，面对技术岗位，其实机会是差不多的。</p>

<p>至于你想什么职位，那显然和你的专业/方向关系较大，比如说很多大数据职位，就明确表示要求你<strong>DM</strong>/<strong>ML</strong>/<strong>NLP</strong>/<strong>IR</strong>背景，但是这也只是说这些
学生可能更有优势些，事实上，数学和统计学出身的，很多搞这个非常牛逼的。</p>

<p>所以，不要问选什么导师，选什么方向；也不要问我的实验室很水老板很菜我还能找到好工作吗？你要问的是：我想毕业去互联
网公司，我读研的这几年是应该打酱油呢，还是打地沟油？</p>

<p>想找一个好的互联网技术类、研发类工作，无非就是以下4点，你任选一点，做好了，都是有利的，哪4点？</p>

<blockquote><ul>
<li>语言层面</li>
<li>算法层面</li>
<li>项目层面</li>
<li>专业层面</li>
</ul>
</blockquote>

<!--more-->


<p>具体分析如下：</p>

<hr />

<h3>语言层面</h3>

<p>你是想搞<strong>C++</strong>还是<strong>Java</strong>？选定一门语言后，多看一些这方面的书。</p>

<p><strong>C++</strong>，不用说了，<strong>《Effective C++》</strong>，<strong>《More Effective C++》</strong>，<strong>《Inside The C++ Object Model》</strong>等等。</p>

<p><strong>Java</strong>，最好能看点虚拟机相关的。尤其是<strong>Java</strong>虚拟机的内存管理。以及多线程、线程池、设计模式等。</p>

<p>问题来了：学<strong>C++</strong>好还是学<strong>Java</strong>好呢？语言争论每天都在发生，真的好无聊。建议按照方向和兴趣来选择，不靠谱的说：</p>

<p>如果是想做大型游戏开发、底层研发、系统研发、驱动研发等等，就选用<strong>C</strong>/<strong>C++</strong>。</p>

<p>如果是想做网站开发、网络研发、上层开发、<strong>Android</strong>开发等等，就选用<strong>Java</strong>。</p>

<p>顺便说一下，有空可以学学<strong>Python</strong>。</p>

<hr />

<h3>算法层面</h3>

<p>学好算法。这个有两条路，最好是并行，那就是看书和做题。</p>

<p>看书的话，主要有《算法导论》、《算法》（<strong>Robert Sedgewick</strong>著）、《算法竞赛入门经典》、《挑战程序设计竞赛》</p>

<p>找一本认真看，认真思考。证明过程可以不看，但是算法思想最好能懂，以及实现，最好能在纸张上写出来。复杂度总要知道吧？</p>

<p>研一的时候，我就把算法导论上的很多算法，都自己亲自coding了下。</p>

<p>特别复杂的数据结构，比如红黑树、<strong>B</strong>树，没空就别搞了。互联网面试一般都不要求的。</p>

<p>主要是排序、查找、简单<strong>DP</strong>、贪心、图算法和搜索。 根据身边同学的面试经验，二分搜索和快速排序，是面试常备了。看书的时候，如果有
时间，可以思考几个问题：</p>

<ul>
<li><p>这个算法的时间空间复杂度，各是多少？如何分析？</p></li>
<li><p>工程实现里，都有哪些<strong>trick</strong>？如何加速？</p></li>
<li><p>这个算法可能用在哪些方面？有哪些应用？你比如说吧，求交集的算法，就广泛用在倒排索引、新浪微博共同关注、计算<strong>Jaccard</strong>系数等
等上。</p></li>
</ul>


<p>除了看书，还有就是很重要的：刷题啦。主要有<strong>poj</strong>，<strong>zoj</strong>等。找一个网站，认真刷一些题目，踏踏实实的，别浮躁。</p>

<hr />

<h3>项目层面</h3>

<p>如果实验室比较牛，基本上忙项目就足够累死累活了；不过做了相对给力的项目，对于找工作，还是有很大帮助的。基本上不用怎么愁了。
如果老板这儿没项目呢？</p>

<p>如果实验室比较水，那就尽量去实习。大公司的实习经验很能给简历加分。如果老板不让你出去实习。ok，既然实验室很水，说明自由时间
比较多，那还是可以干很多事。比如说，<strong>github</strong>上就有很多开源项目，你可以选择一两个著名的，阅读源码，然后尝试自己也参与进去。</p>

<p>说几个我比较感兴趣的开源项目吧：<strong>redis</strong>，<strong>spark</strong>。</p>

<hr />

<h3>专业层面</h3>

<p>你对数据挖掘很精通，你对推荐系统很熟悉。你在<strong>NIPS</strong>，<strong>SIGIR</strong>上发表论文无数；你是百度推荐大赛，阿里巴巴大数据比赛冠军常客。</p>

<p>也就是说，除了尝试发顶会论文，还可以参加各种比赛。本专业本领域里都有什么比赛可以参加呢？搜一下微博或者知乎，或者问下师兄师姐，不就知道了？</p>

<p>专业层面，可以做的东西非常多。比如，你对数据挖掘很感兴趣，那么数据挖掘中的常见模型，我们了解多少？机器学习，我们掌握到什么
程度了？举个例子：</p>

<ul>
<li><p><strong>SVM</strong>和<strong>logistic regression</strong>这两种<strong>model</strong>，有什么特点？各自的适用场合？</p></li>
<li><p><strong>feature selection</strong>的常用方法有哪些？为什么<strong>lasso</strong>可以作为<strong>feature selection</strong>？</p></li>
<li><p><strong>Adaboosting</strong>为什么不容易<strong>over-fitting</strong>？你能不能从<strong>statistical view</strong>来解释解释？</p></li>
<li><p>哦，你和我说，你不是搞学术研究，你反感<strong>Learning Theory</strong>，你说你是一个工程师，那你写了多少代码？</p></li>
</ul>


<p><strong>scikit-learn</strong>，<strong>weka</strong>，以及<strong>spark</strong>，你会用哪个工具？（熟悉一种工具）</p>

<p>你有自己下载一些数据集跑跑实验吗？你有参加一些大数据相关的竞赛吗？（动手实验/参加比赛）</p>

<p>专业层面，能做的，要做的，还有很多。</p>

<p>哦，最好熟悉下<strong>linux</strong>的基本使用。</p>

<hr />

<h3>最后的话</h3>

<p>如果能在读研期间做到这里的一点或者几点，到时候甚至不需要翻《编程之美》或者<strong>leetcode</strong>就毫无压力啦。 最后说几点个人感受。</p>

<ul>
<li>算法牛，项目牛，长得又帅，又精通很多语言，这种人，是不多见的。</li>
</ul>


<p>也就是说，你想拿一个好<strong>offer</strong>，一般只要有一两点突出，就可以了。</p>

<ul>
<li>互联网面试，除了个别公司个别面试官，一般都是要考查（考查？考察？这两个词有什么区别？考察是调研、研究、分析的意思）算法的
。你研一的时候准备，看书做题，总比研三的时候抱佛脚来的好吧？</li>
</ul>


<p>况且，算法的学习，也不仅仅是为了面试吧？可能是受益终身的。或者，吹牛皮装逼作为谈资，也是可以的。</p>

<ul>
<li>别轻易说我就要去某某公司。到时候，你会发现，选择比你想象的多。</li>
</ul>


<p>也有可能比你想象的还少，为什么？</p>

<p>就看你有没有做到我上面说的这些了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Windows下OctoPress环境搭建]]></title>
    <link href="http://www.yebangyu.org/blog/2015/10/17/howtoinstalloctopress/"/>
    <updated>2015-10-17T11:28:19+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/10/17/howtoinstalloctopress</id>
    <content type="html"><![CDATA[<hr />

<p>近期学习了如何搭建个人博客的方法，这里备忘一下，如果能帮助到别人，那就更好了。</p>

<p>使用的工具主要用<strong>OctoPress</strong>,<strong>github</strong>,<strong>ruby</strong>,<strong>python</strong>等，在配置的过程中，主要参考了这篇文章： <a href="http://www.cnblogs.com/oec2003/archive/2013/05/27/3100896.html">http://www.cnblogs.com/oec2003/archive/2013/05/27/3100896.html</a> 在此表示衷心的感谢</p>

<h3>Github</h3>

<p>首先，得有一个<strong>github</strong>的账号，便于托管。在申请了<strong>github</strong>账号之后，建立一个个人仓库，仓库的命名必须是<code>yourusername.github.io</code>这样的形式。如果您有购买个人域名，还可以通过CNAME来完成绑定。这一步可以google一下</p>

<h3>Ruby</h3>

<p>安装Ruby的时候需要特别注意勾选“<strong>Add Ruby executables to your PATH</strong>”</p>

<!--more-->


<h3>DevKit</h3>

<p>下载解压到某个目录（例如<strong>DevKit</strong>），打开<strong>cmd</strong>，执行如下口令</p>

<pre><code>cd DevKit
ruby dk.rb init 
ruby dk.rb install
</code></pre>

<h3>Python</h3>

<p>安装<strong>python</strong>，安装<strong>easy_install</strong>，然后在<strong>cmd</strong>中执行如下命令安装<strong>pygments</strong></p>

<pre><code>easy_install pygments
</code></pre>

<h3>OctoPress</h3>

<p>首先，通过<strong>git</strong>命令将<strong>OctoPress</strong>下载到本地</p>

<pre><code>git clone git://github.com/imathis/octopress.git octopress
</code></pre>

<p>切换到目录，然后执行</p>

<pre><code>gem sources -a https://ruby.taobao.org/
gem sources -r http://rubygems.org/
gem sources -l
</code></pre>

<p>请特别注意，第一行里，是<strong>https</strong>，而不是<strong>http</strong>。</p>

<p>修改Gemfile下的文件，把将第一行的<a href="http://rubygems.org/">http://rubygems.org/</a> 改为<a href="https://ruby.taobao.org/">https://ruby.taobao.org/</a></p>

<p>然后，依次执行如下命令</p>

<pre><code>gem install bundler
bundle install
</code></pre>

<p>并安装<strong>Octopress</strong>的默认主题</p>

<pre><code>rake install
</code></pre>

<p>环境基本上就配置好了，运行<code>rake preview</code>，然后打开<a href="http://127.0.0.1:4000/">http://127.0.0.1:4000/</a> 看看效果吧，恩，本地的效果。接下去就要写文章，继而发布到<strong>github</strong>上了。</p>

<h3>编写文章</h3>

<p>运行<code>rake new_post['helloworld']</code></p>

<p>这样就可以在<strong>octopress/source/_posts</strong> 下生成一个<strong>markdown</strong>文件，然后就可以开始通过编辑该文件来写文章了。我一般使用<strong>Cmd Markdown</strong> 编辑阅读器来写文章，很适合我这样的新手</p>

<p>写完文章，就可以生成了，命令是<code>rake generate</code> ，然后再通过前面的<code>rake preview</code>来预览下</p>

<h3>发布</h3>

<p>运行命令，<code>rake setup_github_pages</code> 来设置您的<strong>github</strong>账号。注意，这一步得在<strong>git bash</strong>下完成，而不是<strong>Windows</strong>命令提示符下。</p>

<p>运行命令，<code>rake deploy</code> ，将文章发布到<strong>github</strong>上。</p>

<p>这样一篇文章就发布出去了。以后写新文章或者更改文章后，只需要<code>rake generate</code> 然后 <code>rake deploy</code> 就可以啦</p>
]]></content>
  </entry>
  
</feed>
