<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Yebangyu's Blog]]></title>
  <link href="http://www.yebangyu.org/atom.xml" rel="self"/>
  <link href="http://www.yebangyu.org/"/>
  <updated>2016-01-24T23:56:47+08:00</updated>
  <id>http://www.yebangyu.org/</id>
  <author>
    <name><![CDATA[Yebangyu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spinlock and mutex]]></title>
    <link href="http://www.yebangyu.org/blog/2016/01/24/spinlock-and-mutex/"/>
    <updated>2016-01-24T15:50:31+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/01/24/spinlock-and-mutex</id>
    <content type="html"><![CDATA[<p>Spinlock（自旋锁）和mutex作为两种互斥锁，在并行编程中都得到了广泛应用。那么，这两种锁有什么区别吗？</p>

<p>当一个线程对Spinlock加锁时，如果该锁被其他线程占用，那么该线程会通过一个loop不断地重试（ try again and again）；而使用mutex的线程没有得到锁时，会sleep。</p>

<p>因为，当临界区较短时，Spinlock因为没有上下文切换，可能性能更优；当临界区较长时，不断的spin将浪费大量的cpu资源。</p>

<!--more-->

<p>如何实现一个Spinlock呢？下面简单封装了一下，并在Ubuntu 14.04 32bit系统，X86体系结构，Intel I5双核处理器环境下，测试相应的性能：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include&lt;thread&gt;</span>
</span><span class="line"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class="line"><span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="kt">int</span> <span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">spin_lock</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">while</span><span class="p">(</span><span class="n">__sync_lock_test_and_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">spin_unlock</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">__sync_lock_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span>  <span class="mi">10000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">spin_lock</span><span class="p">();</span>
</span><span class="line">    <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span><span class="c1">//tiny critical section</span>
</span><span class="line">    <span class="n">spin_unlock</span><span class="p">();</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</span><span class="line">  <span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</span><span class="line">  <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>2个线程时，这个程序的运行时间为：</p>

<pre><code>real	0m1.082s
user	0m2.060s
sys	0m0.000s
</code></pre>

<p>4个线程时：</p>

<pre><code>real	0m5.701s
user	0m19.400s
sys	0m0.000s
</code></pre>

<p>如果改为std::mutex(lock和unlock成员函数)呢？对比一下：</p>

<p>2个线程：</p>

<pre><code>real	0m3.081s
user	0m2.796s
sys	0m3.344s
</code></pre>

<p>4个线程：</p>

<pre><code>real	0m5.860s
user	0m6.004s
sys	0m14.936s
</code></pre>

<p>不难发现，由于大量的上下文切换，使用mutex时，花在sys上的时间要远比使用Spinlock的要多。</p>

<h2 id="section">小结</h2>

<p>以下两种情况，应该考虑使用spinlock代替mutex：</p>

<p>1，每个processor上（只）运行一个线程。</p>

<p>2，线程平均等待（spin）时间少于两次上下文切换的开销。</p>

<p>当然，一切都离不开实际的测试和分析。</p>

<p>下次，我们将研究更多、更高效的spinlock实现。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入解析Bloom Filter(上)]]></title>
    <link href="http://www.yebangyu.org/blog/2016/01/23/insidethebloomfilter/"/>
    <updated>2016-01-23T13:24:49+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/01/23/insidethebloomfilter</id>
    <content type="html"><![CDATA[<p>本文将介绍：</p>

<blockquote>
  <ul>
    <li>Bloom Filter和它的变形与拓展</li>
    <li>Bloom Filter的使用场景</li>
    <li>Bloom Filter的详细数学分析</li>
  </ul>
</blockquote>

<h2 id="section">提出问题</h2>

<p>Google的爬虫每天需要抓取大量的网页。于是就有一个问题：每当爬虫分析出一个url的时候，是抓呢，还是不抓呢？如何知道这个url已经爬过了？</p>

<!--more-->

<p>这个问题，归纳抽象后可以定义为：</p>

<p>给定一个集合S（注意，这里的集合是传统意义上的集合：元素彼此不同。本文不考虑multiset），给定一个元素e，需要判断$e\in S$ 是否成立。（学术界一般称为membership问题）</p>

<h2 id="section-1">分析问题</h2>

<p>都有哪些方案可以解决这个问题？</p>

<p>一种简单的想法是把url存储在一个哈希表中，每次去表里look up下判断是否存在。假如每个url占用40B，那么10亿条url将占用大概30多GB的内存！Can this be more space efficient ?</p>

<h2 id="section-2">解决问题</h2>

<p>我们可不可以不存url本身？这样子所需空间就会大大减少了。于是我们想到一个很经典的做法：bitmap（位图）。将集合S中的url哈希到bitmap上，给定一个url，只需要将它hash，得到它在bitmap的下标，检查该位置是否为1即可。</p>

<p>这样做空间是省了，可是也产生了一个问题：由于冲突（碰撞），不是集合S中的元素也可能被哈希到值为1的位置上，导致误报。</p>

<p>给定一个元素e，如果实际上$e\notin S$ 而被判为 $e\in S$，那么我们称e是false positive（伪正例。顺便说一句，false positive等的分析在machine learning的classification任务里评价model时非常重要）。</p>

<p>如何降低false positive的概率呢？Bloom Filter的想法是使用多个独立的哈希函数。</p>

<h3 id="standard-bloom-filter">Standard Bloom Filter</h3>

<p>在传统的Bloom Filter中，我们有：</p>

<p>集合S：其大小为m。也就是说，集合中有m个不同元素。</p>

<p>可用内存B：B被当成位数组bitmap来使用，大小为n。（有n个bit）。</p>

<p>哈希函数：有k个独立的、均匀分布的哈希函数。</p>

<p>Bloom Filter的做法是：初始时，所有比特位都初始化为0。对于集合中的每个元素，利用k个哈希函数，对它哈希得到k个位置，将bitmap中的对应的k个位置置为1。</p>

<p>给定一个元素e，为了判断它是否是集合中的元素，也利用该k个函数得到k个位置，检查该k个位置是否都为1，如果是，认为$e\in S$，否则认为$e\notin S$。</p>

<p>不难看出，如果$e\in S$，那么Bloom Filter肯定会正确判断出$e\in S$，但是它还是可能产生false positive。那么，如何分析false positive的概率呢？</p>

<p>false positive发生时，表示哈希该元素后得到的k个位置都为1。这个概率大概为：</p>

<p>$P\approx p_1^k$</p>

<p>其中$p_1$代表某位为1的概率，它等于：</p>

<p>$p_1 = 1 - p_0$</p>

<p>对于$p_0$，表示某个特定的比特位为0。什么时候该位才为0呢？也就是说m个元素各自经过k次哈希得到km个对象，没有一个对象定位到了该位置。某个对象定位到该位置的概率为$\frac{1}{n}$，因此我们可以得到：</p>

<p>$p_0 = (1 - \frac{1}{n})^{mk}$</p>

<p>分析$p_0$。在实际应用中，n一般很大，根据重要极限公式，我们有：</p>

<p>$p_0 = (1 - \frac{1}{n})^{mk} = (1-\frac{1}{n})^{-n{\frac{mk}{-n}}} \approx e^{-\frac{mk}{n}} $</p>

<p>代入到最上面的那个式子，我们不难得到：</p>

<p>$P \approx ({1 - e^{-\frac{mk}{n}}})^{k}$</p>

<p>当k为何值时，P取得最小，false positive possibility最低呢？</p>

<p>令 $f(k) = ({1 - e^{-\frac{mk}{n}}})^{k}$</p>

<p>$ln(f(k)) = kln({1 - e^{-\frac{mk}{n}}})$</p>

<p>$\frac{f\prime(k)}{f(k)} = ln({1 - e^{-\frac{mk}{n}}}) + k(\frac{1}{1 - e^{- \frac{mk}{n}}})(- e^{-\frac{mk}{n}})(\frac{-m}{n})$</p>

<p>$f\prime(k) = f(k)(ln({1 - e^{-\frac{mk}{n}}}) + k(\frac{1}{1 - e^{- \frac{mk}{n}}})(- e^{-\frac{mk}{n}})(\frac{-m}{n}))$</p>

<p>看起来够复杂了，然而别怕！！！</p>

<p>令$f\prime(k) = 0$ ， 我们有(注意到$f(k) &gt; 0$ 恒成立)：</p>

<p>$ln({1 - e^{-\frac{mk}{n}}}) + k(\frac{1}{1 - e^{- \frac{mk}{n}}})(- e^{- \frac{mk}{n}})(\frac{-m}{n}) = 0$</p>

<p>作代换，令$\lambda = e^{-\frac{mk}{n}}$ 则 $k = \frac{-nln\lambda}{m}$，代入上式，得到</p>

<p>$(1-\lambda)ln(1-\lambda) = \lambda ln\lambda$</p>

<p>因此$\lambda = \frac{1}{2}$ ， $k = \frac{n}{m}ln2$</p>

<p>也就是说，当n和m固定时，选择$k = \frac{n}{m}ln2$ 附近的一个整数，将使false positive possibility最小。</p>

<p>工程实现时，我们需要k个哈希函数或者哈希函数值。如何构造和获得k个独立的哈希函数呢？这篇<a href="https://www.eecs.harvard.edu/~michaelm/postscripts/rsa2008.pdf">论文</a> 提出，只需要两个独立的哈希函数hf1和hf2即可，也就是通过如下方式获得k个哈希函数值：</p>

<p>hash value = hf1(key) + i*hf2(key)</p>

<p>其中i=0、1、2…k-1</p>

<h3 id="counting-bloom-filter">Counting Bloom Filter</h3>

<p>除了存在false positive这个问题之外，传统的Bloom Filter还有一个不足：无法支持删除操作（想想看，是不是这样的）。而Counting Bloom Filter(CBF)就是用来解决这个问题的。</p>

<p>在CBF中，维护的不是单纯的标示0或者1的比特位，而是计数器counter。对于集合中的每个元素，利用k个哈希函数，对它哈希得到k个位置，将对应的k个位置上的k个counter都加1。删除时，只需要把k个counter都减1即可。</p>

<p>那么，这个counter应该占用几位呢？分配太多，浪费空间；分配太少，容易溢出。通过下面的分析，我们可以知道，实际使用时，4位足矣。</p>

<p>考察（是考察，不是考查。这两个词有什么区别？）某个位置，该位置的计数器counter的值$\xi$</p>

<p>$P(\xi = c) \approx \binom{mk}{c} {(\frac{1}{n})}^{c}({1-\frac{1}{n}})^{mk-c} = B(km,\frac{1}{n})$</p>

<p>这个式子有点点复杂，然而回忆下概率论里的知识：若二项分布B(n,p)里n很大，p很小时，二项分布的极限近似分布是泊松分布$P(\lambda=k) = \frac{\lambda^k}{k!}{e}^{-\lambda}$，其中$\lambda=np$，因此：</p>

<p>$P(\xi = c) \approx \binom{mk}{c} {(\frac{1}{n})}^{c}({1-\frac{1}{n}})^{mk-c} \approx \frac{({\frac{km}{n}})^{c}}{c!}{e}^{-{\frac{km}{n}}}$</p>

<p>令$k = \frac{n}{m}ln2$，代入，我们得到</p>

<p>$P(\xi &gt;16) \approx \frac{(ln2)^{16}}{16!} * \frac{1}{2} &lt; \frac{1}{16!} = \frac{1}{20922789888000}$</p>

<p>也就是说，选择4位来存counter在实际情况中已经足矣，发生溢出的概率极小。</p>

<h2 id="section-3">本文小结</h2>

<p>总结下，Bloom Filter可以用在什么地方，或者说，在什么场景下，你应该想到这种技术：</p>

<p>1，回答是或者不是的问题。你需要判断一个元素是否属于某个集合，仅仅这样。你不应该要求更多。如果你想获得该元素对应的value或者还有其他payload，那么bloom filter不适合你，你需要哈希表。</p>

<p>2，允许false positive。也就是说，发生false positive不应该是致命的。比如说，搜索引擎的爬虫里，如果url不是set的元素，却被bloom filter过滤了，那么顶多就是不抓它而已，没啥特别大的损失。</p>

<p>3，空间敏感。作为一种概率数据结构，Bloom Filter不存储原始数据（比如说url），这也是它为什么space efficient的本质原因。</p>

<p>有了Standard Bloom Filter和Counting Bloom Filter，似乎可以满足绝大多数需求了，然而，这里面还是有问题。什么问题？请看下集。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Concurrent and Parallel]]></title>
    <link href="http://www.yebangyu.org/blog/2016/01/17/concurrenyandparallism/"/>
    <updated>2016-01-17T09:49:00+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/01/17/concurrenyandparallism</id>
    <content type="html"><![CDATA[<p>什么是并发(<strong>Concurrency，Concurrent</strong>)，什么是并行(<strong>parallism，Parallel</strong>)？这两者有什么区别？本文收录一下我听过的、我见过的、我看过的一些人的看法。仅供参考：</p>

<h2 id="paul-butcher">Paul Butcher</h2>

<p><strong>Paul Butcher</strong>在他的《<strong>Seven Concurrency Models in Seven Weeks</strong>
》里开篇就谈到：</p>

<!--more-->

<p>An alternative way of thinking about this is that concurrency is an aspect of
the problem domain—your program needs to handle multiple simultaneous
(or near-simultaneous) events. Parallelism, by contrast, is an aspect of the
solution domain—you want to make your program faster by processing different
portions of the problem in parallel</p>

<p>也就是说，并发是<strong>问题域</strong>，并行是<strong>解决域</strong>。问题是并发的，解决方法是并行的。</p>

<h2 id="rob-pike">Rob Pike</h2>

<p><strong>Rob</strong>是<strong>Go</strong>语言之父，《<strong>The Unix Programming Environment</strong>》 和 《<strong>The Practice of Programming</strong>》（最近正在重读这本小册子）的作者。他有一个经典的解释：</p>

<p>Concurrency is about dealing with lots of things at once.</p>

<p>Parallelism is about doing lots of things at once.</p>

<p>嘿嘿，这个有点意思，不过只能意会了。</p>

<h2 id="paul-e-mckenney">Paul E. McKenney</h2>

<p>又是一个<strong>Paul</strong>。不过这个<strong>Paul</strong>大叔是<strong>IBM</strong>的研究人员，写了一本非常幽默并且有深度的书：《<strong>Is Parallel Programming Hard, And, If So, What Can You Do About It?</strong>》（最近一直在细读，并且做读书笔记，感兴趣的朋友可以参考我的相关<a href="http://www.yebangyu.org/blog/categories/bing-xing-bian-cheng/">博客</a>。） 在这本书（<strong>v2015.01.31a</strong>版本）的第<strong>319</strong>页，有一个附录，介绍 <strong>What is the Difference Between</strong>
“<strong>Concurrent</strong>” <strong>and</strong> “<strong>Parallel</strong>”?时说：</p>

<p>From a classic computing perspective, “concurrent” and
“parallel” are clearly synonyms. However, this has not
stopped many people from drawing distinctions between
the two</p>

<p>说明<strong>Paul</strong>大叔认为，其实这两者是一回事，有些人非得区分。好吧，那就区分吧。这些人是如何区分呢？有两个<strong>perspective</strong>：</p>

<p>The first perspective treats “parallel” as an abbreviation
for “data parallel,” and treats “concurrent” as pretty
much everything else</p>

<p>也就是说，<strong>concurrency</strong>有很强的<strong>interdependencies</strong>，它们之间可能要做各种通信，基于比如说<strong>locks</strong>啊，<strong>transactions</strong>啊，等等同步机制。相比，<strong>parallel</strong>中组件的相互依赖就很少。新浪微博网友 <a href="http://weibo.com/u/1085583241">@小恶魔提利昂</a>就持这种观点，他说：“并发任务处理的时候，会在并发处理时候可以交换信息，有CSP式的，也可以内存共享式的，但是在外部看到的效果是若干核或若干线程/协程同时对应这些并发任务。并行处理的话，同时处理的任务要做到上下文环境都是隔离的。”</p>

<p>Now, this second perspective can be thought of as making
the workload match the available scheduler, with parallel
workloads able to operate on a simple scheduler
and concurrent workloads requiring more sophisticated
schedulers.</p>

<p>恩，第二个角度就是需不需要复杂的<strong>scheduler</strong>。</p>

<p>但是<strong>Paul</strong>大叔说，这两个视角很可能是不可兼得或者说矛盾滴。此话怎讲？</p>

<p>考虑每个<strong>CPU</strong>一个线程的基于<strong>lock</strong>通信的程序。是<strong>Concurrency</strong>吗？从第一个角度讲，是的，用<strong>lock</strong>啊，各种同步各种通信啊。从第二个角度看，又不是。</p>

<p>以上就是<strong>Paul McKenney</strong>大致的观点。</p>

<h2 id="yebangyu">yebangyu</h2>

<p><strong>yebangyu</strong>是博主，<strong>yebangyu.org</strong>公司CEO兼站长兼董事长兼老板，苦逼屌丝底层搬砖码农。恩，就是我了。</p>

<p>个人观点：</p>

<p>1，首先，持<strong>Paul McKenney</strong>的观点，没必要区分这两个词。</p>

<p>2，<strong>Concurrency</strong>这个单词含有类“occur”的词根，表示发生，<strong>con</strong>代表共同、一起，指共同发生的意思。而<strong>parallel</strong>词根是<strong>para</strong>，表示相同的、类似、平行的、差不多的。因为，也可以认为问题是同时发生的，解决方法是平行处理。</p>

<p>3，写书在取书名的时候需要区分。如果你是讲<strong>MPI、Open MP</strong>这类技术，建议用并行或者说<strong>Parallel Computing</strong>。如果是讲<strong>lock free、multi-thread</strong>这些共享内存编程的，建议用<strong>Concurrency</strong>或者<strong>Concurrency Programming</strong>。</p>

<p>那么，<strong>Go</strong>语言这种<strong>CSP</strong>类型的<strong>Channel</strong>的呢？个人认为，都可以吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Memory Consistency和Cache Coherence]]></title>
    <link href="http://www.yebangyu.org/blog/2016/01/09/memoryconsistencyandcachecoherence/"/>
    <updated>2016-01-09T22:52:52+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/01/09/memoryconsistencyandcachecoherence</id>
    <content type="html"><![CDATA[<h2 id="memory-consistency">Memory Consistency</h2>

<p><strong>Memory Consistency</strong>(<strong>MC</strong>)，有时候又叫做<strong>Memory Consistency Model</strong>或者<strong>Memory Model</strong>。为了理解为什么需要引入这种东西，我们首先看以下程序：</p>

<!--more-->

<pre><code>初始：x=0 y=0

Thread1：

S1：x=1

L1：r1=y

Thread2：

S2：y=2

L2：r2=x
</code></pre>

<p>其中，<strong>S1、S2、L1、L2</strong>是语句代号（<strong>BTW</strong>，<strong>S</strong>表示<strong>Store</strong>，<strong>L</strong>表示<strong>Load</strong>）；<strong>r1</strong>和<strong>r2</strong>是两个寄存器。<strong>x</strong>和<strong>y</strong>是两个不同的内存变量。</p>

<p>两个线程执行完之后，<strong>r1</strong>和<strong>r2</strong>可能是什么值？</p>

<p>注意到线程是并发、交替执行的，下面是可能的执行顺序和相应结果：</p>

<p><strong>S1 L1 S2 L2</strong> 那么<strong>r1=0 r2=2</strong></p>

<p><strong>S1 S2 L1 L2</strong> 那么<strong>r1=2 r2=1</strong></p>

<p><strong>S2 L2 S1 L1</strong> 那么<strong>r1=2 r2=0</strong></p>

<p>这些都是意料之内、情理之中的。但是在<strong>x86</strong>体系结构下，很可能得到<strong>r1=0 r2=0</strong>这样的结果。是不是大吃一惊？</p>

<p>如果没有<strong>Memory Consistency</strong>，那么程序员对于自己编写的多线程程序会输出什么将一无所知：天知道会输出什么。</p>

<p>因此，<strong>Memory Consistency</strong>就是程序员（编程语言）、编译器、CPU间的一种协议。这个协议保证了程序访问内存时可能得到什么值，会得到什么值。</p>

<h2 id="sequential-consistency">Sequential Consistency</h2>

<p>在<strong>Sequential Consistency</strong>这种<strong>Memory Model</strong>下，刚才讨论的那个程序不可能输出<strong>r1=0 r2=0</strong>这种结果。怎么说？这就牵涉到一个问题：什么是<strong>Sequential Consistency</strong>（<strong>SC</strong>）。</p>

<p>根据<strong>Leslie Lamport</strong>在<strong>1979</strong>年<strong>9</strong>月发表的论文《<strong>How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs</strong>》里提出的<strong>SC</strong>的定义：</p>

<p>the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program.</p>

<p>根据这个定义，在<strong>SC</strong>模型下，任何<strong>execution</strong>的执行顺序（我们称为<strong>Memory Order</strong>）必须<strong>respect</strong>每个线程的<strong>Program Order</strong>。什么是<strong>Program Order</strong>？对于以上程序，在<strong>Thread1</strong>中，<strong>S1</strong>先于<strong>L1</strong>（不妨记为<strong>S1&lt;L1</strong>）；在<strong>Thread2</strong>中，<strong>S2</strong>先于<strong>L2</strong>（记为<strong>S2&lt;L2</strong>）。这就是<strong>Program Order</strong>。</p>

<p>请时刻注意，<strong>Program Order</strong>只针对某个线程内的语句而言，不涉及到跨线程。比如<strong>Thread1</strong>中的<strong>S1</strong>和<strong>Thread2</strong>中的<strong>L2</strong>，就无所谓什么<strong>Program Order</strong>了。</p>

<p>好了，现在知道为什么在<strong>SC</strong>下，有些结果可能出现，有些不可能了。</p>

<p><strong>S1 L1 S2 L2 r1=0 r2=2</strong> 没问题，没有违背<strong>S1&lt;L1 S2&lt;L2</strong></p>

<p><strong>S1 S2 L1 L2 r1=1 r2=2</strong> 没问题，没有违背<strong>S1&lt;L1 S2&lt;L2</strong></p>

<p><strong>S2 L2 S1 L1 r1=2 r2=0</strong> 没问题，没有违背<strong>S1&lt;L1 S2&lt;L2</strong></p>

<p>而对于<strong>r1=0 r2=0</strong>，在<strong>SC</strong>下，我们找不到一个能<strong>respect Program Order</strong>的<strong>Memory Order</strong>。因为<strong>r1=0</strong>，说明<strong>L1&lt;S2</strong>，<strong>r2=0</strong>说明<strong>L2&lt;S1</strong>；而<strong>S1&lt;L1，S2&lt;L2</strong>，不难看出这里形成了一个环。</p>

<h2 id="cache-coherence">Cache Coherence</h2>

<p>还是先搬出这张图吧:</p>

<p><img src="http://7xnljs.com1.z0.glb.clouddn.com/cpuand%20cache.png" alt="memorycache" /></p>

<p>(图片来源于<strong>Paul</strong>大叔的《<strong>Is Parallel Programming Hard</strong>》这本书第三章)</p>

<p>多个<strong>CPU cores</strong>，每个<strong>core</strong>上有自己的<strong>Cache</strong>。我们知道，<strong>Cache</strong>是部分内存的映射和缓存，或者说，副本。这就带来一个问题：副本一致性。内存只有一个，每个<strong>cpu cores</strong>却有自己的内存副本，如何保证大家看到的内容是一样的、一致的、正确的呢？这就是<strong>Cache Coherence(CC)</strong>要解决的问题。</p>

<h2 id="cache-coherence--vs-memory-consistency">Cache Coherence  VS Memory Consistency</h2>

<p>从以上分析，我们不难看出，<strong>CC</strong>和<strong>MC</strong>涉及的是两个不同层面的东西，解决的是不同的问题，不可混淆。<strong>CC</strong>解决的是副本一致性问题；<strong>MC</strong>保证的是多线程程序访问内存时可以（可能）读到什么值。</p>

<p>两者有联系吗？有。实现<strong>Memory Consistency</strong>时可能会使用到<strong>Cache Coherence</strong>。细节下次我们接着聊。</p>

<h2 id="section">附录</h2>

<p>1，在并行编程中，我们常常有一个问题，或者需求：比如说上面的那个程序，如何保证线程<strong>2</strong>读到的<strong>x</strong>是线程<strong>1</strong>更新（<strong>x=1</strong>）后的<strong>x</strong>的值呢？</p>

<p>如果不加任何同步设施，仅仅考虑上面的程序，那么答案是：无法保证。因为线程的推进速度不同，哪条指令先被执行也一无所知。这个程序重跑几次，也可能输出不同的结果出来。</p>

<p>也就是说，<strong>Memory Model</strong>保证的是，例如，当线程<strong>2</strong>看到<strong>x</strong>等于<strong>1</strong>的时候，线程<strong>1</strong>是否已经执行了<strong>L1</strong>。也就是说，<strong>Memory Model</strong>确保当一件事情发生时，有其他什么事情<strong>has happened</strong>。在<strong>SC</strong>中，当<strong>L1</strong>发生时，说明或者说暗示着，<strong>S1</strong>已经发生了。</p>

<p>2，为什么<strong>x86</strong>下可能得出<strong>r1=0 r2=0</strong>的结果？</p>

<p>因为<strong>S1</strong>是写一个内存变量而<strong>L1</strong>是读取另一个内存变量（两个变量，或者说两个内存地址），这种情况下的写读可能被<strong>CPU</strong>乱序：先执行<strong>L1</strong>，再执行<strong>S1</strong>。（为了性能，所谓的延后写）</p>

<h2 id="section-1">致谢</h2>

<p>本文发出后，微博网友@linyvxiang 指出了其中的一个笔误，非常感谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下C++程序计时方法]]></title>
    <link href="http://www.yebangyu.org/blog/2016/01/07/timingcprograminlinux/"/>
    <updated>2016-01-07T23:02:14+08:00</updated>
    <id>http://www.yebangyu.org/blog/2016/01/07/timingcprograminlinux</id>
    <content type="html"><![CDATA[<p>最近简单学习了下<strong>Linux</strong>下<strong>C++</strong>程序计时的一些函数和方法，总结如下。没啥<strong>insight</strong>了。</p>

<p>方法一：</p>

<p>如果是想统计某个程序的运行时间，那么可以使用</p>

<pre><code>time ./a.out
</code></pre>

<!--more-->

<p>方法二：</p>

<p>如果是想对某个函数或者语句进行计时，那么有别的方法。比如说，<code>gettimeofday</code>函数。直接贴示例代码:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include &lt;sys/time.h&gt;</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="c1">//...</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">struct</span> <span class="n">timeval</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>
</span><span class="line">  <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">  <span class="n">f</span><span class="p">();</span>
</span><span class="line">  <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">  <span class="c1">//那么函数f运行所花的时间为</span>
</span><span class="line">  <span class="c1">//deltaT = (t2.tv_sec-t1.tv_sec) * 1000000 + t2.tv_usec-t1.tv_usec 微秒</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>不难看出，<code>gettimeofday</code>只能精确到微秒；如果想精确到纳秒呢？</p>

<p>方法三：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include &lt;time.h&gt;</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="c1">//...</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">timespec</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>
</span><span class="line">  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t1</span><span class="p">);</span>
</span><span class="line">  <span class="n">f</span><span class="p">();</span>
</span><span class="line">  <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t2</span><span class="p">);</span>
</span><span class="line">  <span class="c1">//那么f所花时间为</span>
</span><span class="line">  <span class="c1">//deltaT = (t2.tv_sec - t1.tv_sec) * 10^9 + t2.tv_nsec - t1.tv_nsec 纳秒</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这里说的都是<strong>wall clock</strong>，如果想获得<strong>cpu</strong>执行时间，以及了解<code>clock_gettime</code>参数的解释和可能的取值，可以<strong>man</strong>一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[诡异的程序性能问题]]></title>
    <link href="http://www.yebangyu.org/blog/2015/12/30/falsesharing/"/>
    <updated>2015-12-30T23:06:12+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/12/30/falsesharing</id>
    <content type="html"><![CDATA[<p>本文所使用的环境是<strong>Ubuntu 14.04 32bit</strong>系统，<strong>Intel I5</strong>处理器，<strong>X86</strong>体系结构</p>

<h2 id="section">提出问题</h2>

<p>如果我说下面的程序存在性能问题，您信吗？</p>

<!--more-->

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include&lt;thread&gt;</span>
</span><span class="line"><span class="kt">int32_t</span> <span class="n">global</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="o">++</span><span class="n">global</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="o">++</span><span class="n">global</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">thread1</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">thread2</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
</span><span class="line">  <span class="n">thread1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="n">thread2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这个程序，在我的电脑上，运行时间为：</p>

<pre><code>real	0m0.822s
user	0m1.596s
sys     0m0.000s
</code></pre>

<h2 id="section-1">分析问题</h2>

<p>有人说，两个线程分别操作不同的计数器，这么完美的程序，会有性能问题？</p>

<p>答案是：有。</p>

<p>恩，原因在于大名鼎鼎的<strong>false sharing</strong>。如果您看过我以前写的<a href="http://www.yebangyu.org/blog/2015/10/18/hardwareanditshabit/">这篇</a>博客，应该还记得:现在的计算机一般由一个内存、一个<strong>CPU</strong>组成，而包含多个<strong>CPU Cores</strong>和<strong>Cache</strong>。如这幅图所示：</p>

<p><img src="http://7xnljs.com1.z0.glb.clouddn.com/cpuand%20cache.png" alt="memorycache" /></p>

<p><strong>cacheline</strong>是<strong>cache</strong>块单位，一个<strong>cacheline</strong>大小一般在<strong>32</strong>到<strong>256</strong>字节左右。<strong>cacheline</strong>是这张图中不同模块的数据交互元素。</p>

<p>在上面程序中，<strong>global</strong>是两个<strong>4</strong>字节变量构成的数组，大小为<strong>8</strong>字节，很可能被放到同一个<strong>cacheline</strong>里。当运行在<strong>CPU1 Core</strong>上的线程<strong>thread1</strong>修改了<strong>global[0]</strong>时，会让运行在<strong>CPU2 Core</strong>上对应<strong>global[0]</strong>和<strong>global[1]</strong>的<strong>cacheline</strong>失效，因此运行在<strong>CPU2 Core</strong>上的线程<strong>thread2</strong>修改<strong>global[1]</strong>时会发生<strong>cache miss</strong>，接着它访问内存，修改<strong>global[1]</strong>，这也会让<strong>CPU1 Core</strong>中的<strong>cacheline</strong>失效。很明显，这里面会有大量的<strong>cache miss</strong>和为了缓存一致性而花费的通信开销。</p>

<p>因此这种<strong>false sharing</strong>发生在多核、多线程环境中。单核或者单线程不会有<strong>false sharing</strong>问题。</p>

<p>遗憾的是，程序里存在这样的问题，并不容易通过肉眼发现。</p>

<p>幸运的是，这种问题一旦知道，就比较好解决。</p>

<h2 id="section-2">解决问题</h2>

<p>解决方法一：让这两个计数器间隔足够大，让它们不要在同一个<strong>cacheline</strong>里，不就行了么？</p>

<p>恩，定义一个<strong>global[10000]</strong>，然后线程<strong>1</strong>利用<strong>global[0]</strong>，线程<strong>2</strong>利用<strong>global[9999]</strong>，应该就可以了。</p>

<p>什么？这么愚蠢的方法都想得出来？接着往下看。</p>

<p>解决方法二：假如<strong>global</strong>不是一个数组呢？而是包含多个变量的结构体呢(这种情形也很常见)？上面的方法就不灵了吧？</p>

<p>恩，上面的方法不灵了，而且上面的方法太笨。网上有很多资料告诉您怎么定义变量让其<strong>cacheline aligned</strong>，这也是那些博客千篇一律的做法。还有没有其他方法？有。接着往下看。</p>

<p>解决方法三：重点来了。</p>

<p>我们其实可以在线程里使用局部变量！</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include&lt;thread&gt;</span>
</span><span class="line"><span class="kt">int32_t</span> <span class="n">global</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">counter1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="o">++</span><span class="n">counter1</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">global</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">counter2</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span><span class="line">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="o">++</span><span class="n">counter2</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="n">global</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter2</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">thread1</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">thread2</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
</span><span class="line">  <span class="n">thread1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="n">thread2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><strong>counter1</strong>和<strong>counter2</strong>在自己的线程栈上，<strong>cacheline</strong>位于对应的<strong>CPU core</strong>里，大家相安无事。只有执行第<strong>9</strong>行和第<strong>17</strong>行时代价可能高点。</p>

<p>这个程序，在我的电脑上运行时间为：</p>

<pre><code>real	0m0.293s
user	0m0.580s
sys     0m0.000s
</code></pre>

<p>解决方法四：</p>

<p><strong>global</strong>神马变量？全局变量。<strong>counter1/counter2</strong>神马变量？局部变量。</p>

<p>有没有一种东东，既有全局的性质，又有局部的效果（线程私有）呢？</p>

<p>恩，如果您看过我以前写的<a href="http://www.yebangyu.org/blog/2015/10/31/linux-parallen-programmming-infrastructure/">这篇</a>博客，就不会对<strong>__thread</strong>感到陌生。对！提供强大<strong>scalability</strong>的利器，就是它了！</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include&lt;thread&gt;</span>
</span><span class="line"><span class="n">__thread</span> <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="o">++</span><span class="n">counter</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="o">++</span><span class="n">counter</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">thread1</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</span><span class="line">  <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">thread2</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
</span><span class="line">  <span class="n">thread1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="n">thread2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这个程序在我的电脑上的运行时间为：</p>

<pre><code>real	0m0.325s
user	0m0.644s
sys     0m0.000s
</code></pre>

<p>不过其他线程如何读取到每个计数线程的<strong>counter</strong>呢？不难，但是也不是那么简单，背后涉及到很多问题（其实本文最大的目的是通过<strong>false sharing</strong>，揭示<strong>partition</strong>这种并发编程里最大的设计原则）。我们下次专门聊。</p>

<h2 id="section-3">附录</h2>

<p>1，编译以上多线程程序的时候，请使用：</p>

<pre><code>g++ -pthread -std=c++11 xxx.cpp
</code></pre>

<p>如果没有指定<code>-pthread</code>，那么程序可以编译链接通过，运行时报错：</p>

<p>terminate called after throwing an instance of ‘std::system_error’</p>

<p>what():  Enable multithreading to use std::thread: Operation not permitted</p>

<p>Aborted (core dumped)</p>

<p>2，程序计时我用的是 <code>time ./a.out</code>的方式。</p>

<h2 id="section-4">致谢</h2>

<p>本文发出后，微博网友@Debin_IIE指出了一个笔误。非常感谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[程序员时钟解读]]></title>
    <link href="http://www.yebangyu.org/blog/2015/12/26/aprogrammersclock/"/>
    <updated>2015-12-26T10:59:04+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/12/26/aprogrammersclock</id>
    <content type="html"><![CDATA[<p>最近购买圣诞礼物，抱着万能的淘宝的想法，在上面搜了一下“数学钟”，也就是非常流行的下面这幅图：</p>

<p><img src="http://7xnljs.com1.z0.glb.clouddn.com/mathclock.jpg" alt="matchclock" /></p>

<p>以前，只知道其中十一个点钟的分析；对于3点钟，一直没有思路。于是发了一条朋友圈，求助大神解释其中的3点钟。在刘梓溪、贾顾森、黎鸣等大神的指导下，明白了其中是怎么回事。所以这里介绍下这十二个点，应该如何解释。个人观点，仅供参考。</p>

<h2 id="section">12点</h2>

<p>不用说了，1728的立方根。</p>

<h2 id="section-1">1点</h2>

<p>可能很多人不大知道，这是勒让德常数：</p>

<!--more-->

<p>$\lim_{x \rightarrow +\infty} {ln(x) - \frac{x}{\pi(x)}}$</p>

<p>其中的$\pi(x)$表示不大于x的素数的个数，可以用$\frac{x}{lnx}$近似。</p>

<p>这个值经过勒让德、高斯等一批数学大佬的努力，最后被数学家Charles Jean证明为1。</p>

<h2 id="section-2">2点</h2>

<p>无穷递缩等比级数的求和，首项为1，公比为$\frac{1}{2}$ ，所以它的和为</p>

<p>S = $\frac{a_1}{1-q}$ = 2</p>

<h2 id="section-3">3点</h2>

<p>在刘梓溪、贾顾森、黎鸣等大神的帮助下，终于知道了。</p>

<p>广泛用于XML、HTML中。&amp;#后面接十进制字符，&amp;#x后面接十六进制字符。相当于转义序列吧。</p>

<p>其中十六进制33，等于十进制51，即’3’。</p>

<h2 id="section-4">4点</h2>

<p>同余问题（Modular Multiplicative Inverse）</p>

<p>令</p>

<p>$x\equiv2^{-1} mod 7$</p>

<p>$2x\equiv1 mod 7$</p>

<p>$x =  4$</p>

<h2 id="section-5">5点</h2>

<p>$\phi$表示黄金分割比，$\phi = \frac{\sqrt{5} - 1}{2} $</p>

<p>黄金分割比在斐波那契数列的通项公式中出现。</p>

<p>不过这个地方，我没搞懂，不知道这是不是这幅图作者的笔误？个人认为应该是 $(2\phi+1)^2$ 而不是 $(2\phi-1)^2$</p>

<h2 id="section-6">6点</h2>

<p>不用说了，阶乘。</p>

<h2 id="section-7">7点</h2>

<p>表示6.999999999…其中9的头上一横，表示循环节是9。</p>

<p>那么，6.9999….为什么等于7呢？恩，还是无穷递缩等比级数的视角来考虑，就老少皆宜了。</p>

<p>6.9999…= 6 + 0.9 + 0.09 + 0.009 + 0.0009 + …</p>

<p>后面的那个，</p>

<p>0.9 + 0.09 + 0.009 + 0.0009 + …</p>

<p>首项为0.9，公比为0.1，收敛于1。</p>

<p>因此6.9999… = 7</p>

<h2 id="section-8">8点</h2>

<p>代表1000（二进制），因为只有第一个是亮的，其他是暗的。（亮为1，暗为0，bitmap的感觉。可能是盲文），因此为8。</p>

<h2 id="section-9">9点</h2>

<p>四进制。21（四进制） = 2 * 4 + 1 = 9。</p>

<h2 id="section-10">10点</h2>

<p>组合数，5! /(2! * 3!) = 10</p>

<h2 id="section-11">11点</h2>

<p>十六进制，A是10，B是11，C是12。注意，注意，这里是0x0B，不是0x08。哈哈。</p>

<p>点评：知识点有点重复，比如进制就有好几个。给个好评吧，但不是五星的。</p>

<h2 id="section-12">致谢</h2>

<p>感谢朋友刘梓溪、贾顾森、黎鸣告诉我如何解读其中的3点钟。</p>

<p>本文发出后，阿里花隆同学指出了文中的一个笔误。非常感谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction To Cuckoo Hashing]]></title>
    <link href="http://www.yebangyu.org/blog/2015/12/19/cuckoo-hashing/"/>
    <updated>2015-12-19T00:41:37+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/12/19/cuckoo-hashing</id>
    <content type="html"><![CDATA[<h2 id="motivation--intuition">Motivation &amp; Intuition</h2>

<p>为什么引入<strong>Cuckoo Hashing</strong>？</p>

<p>常见的<strong>hashing</strong>处理冲突方法一般包括两种：<strong>Separate Chaining</strong>和<strong>Open Addressing</strong>（<strong>Linear Probing</strong>）。<strong>Separate Chaining</strong>是将冲突的元素组织成一个链表（其实组织成一个二叉搜索树也是完全没问题的，甚至跳表也行），<strong>Open Addressing</strong>将冲突的元素还是放在哈希表<strong>slot</strong>中，使用线性探测等方法进行处理。</p>

<p>那么，这两种方法，都有啥优缺点呢？</p>

<!--more-->

<p><strong>Separate Chaining</strong> : 实现简单，但是对<strong>cache</strong>不友好，<strong>cache miss rate</strong>较高。</p>

<p><strong>Open Addressing</strong> : 实现相对复杂一点点，对<strong>cache</strong>很友好，但是对<strong>load factor</strong>要求苛刻：<strong>load factor</strong>稍高性能就急剧下降。</p>

<p>这两种方式下，查找某个元素的最坏时间都是<strong>O(n)</strong>。</p>

<p>你说，<strong>OK，OK</strong>，我知道，这些都是常识。那么，是否可以做到查找最坏是<strong>O(1)</strong>呢？</p>

<p>一种思路是元素只可能被安置到有限的常数(记为<strong>K</strong>)个位置，插入时，如果发生冲突，由于每个元素可以存放的位置有<strong>K</strong>个，因此可以对表部分元素进行重排，产生一个空缺的位置。</p>

<p><strong>Cuckoo Hashing</strong>就是这样的方式。当<strong>K=2</strong>时，<strong>Cuckoo Hashing</strong>在<strong>load factor</strong>为<strong>50%</strong>左右的情况下表现较佳。如果<strong>K=4</strong>，那么甚至可以在<strong>97%</strong>的<strong>load factor</strong>下良好工作。</p>

<h2 id="cuckoo-hashing">Cuckoo Hashing</h2>

<p>一般的<strong>Hashing</strong>只包括一个<strong>Hash Tables</strong>，但是<strong>Cuckoo Hashing</strong>由两张甚至多张表构成。每张表对应一个哈希函数。本文讨论两张哈希表（记为<strong>table1</strong>和<strong>table2</strong>）、两个哈希函数（记为<strong>hf1</strong>和<strong>hf2</strong>）这种常见情形。</p>

<h3 id="insert">Insert</h3>

<p>首先通过<strong>hf1</strong>计算出一个<strong>slot index</strong>，然后查看<strong>table1</strong>中该<strong>slot</strong>是否<strong>vacant</strong>，如果是，则插入；否则通过<strong>hf2</strong>计算出一个<strong>slot index</strong>，通过查看<strong>table2</strong>中该<strong>slot</strong>是否<strong>vacant</strong>，如果是，则插入，否则执行<strong>rearrange</strong>操作。</p>

<p><strong>rearrange</strong>操作的过程：随机选出一张表，将<strong>slot index</strong>对应的那个元素踢出(<strong>evict</strong>)，把我们待插入的元素插到那个位置。那被踢出来的元素呢？尝试插入到另外一张表对应的<strong>slot</strong>处，这时候可能又踢出一个元素，接下去就是递归的执行这个过程，直到所有元素都安置妥当。</p>

<p>举个例子吧，假如某个时刻，两个哈希表的内容如下：</p>

<p><img src="http://7xnljs.com1.z0.glb.clouddn.com/table1.jpg" alt="table1" /></p>

<p>假设我们待插入的元素为<strong>77</strong>。</p>

<p><strong>slot index1 = hf1(77) = 1</strong></p>

<p><strong>Table1</strong>中的<strong>index</strong>为<strong>1</strong>的<strong>slot</strong>已经被<strong>78</strong>占了。那么看<strong>Table2</strong>：</p>

<p><strong>slot index2 = hf2(77) = 3</strong></p>

<p><strong>Table2</strong>中的<strong>index</strong>为<strong>3</strong>的<strong>slot</strong>已经被<strong>33</strong>占了。因此执行<strong>rearrange</strong>。</p>

<p>执行<strong>rearrange</strong>动作，选择<strong>Table2</strong>，将<strong>slot index = 3</strong>的元素<strong>33</strong>踢出，插入<strong>77</strong>。然后被踢出的元素<strong>33</strong>，计算它在<strong>Table1</strong>中的<strong>index</strong>为<strong>slot index1 = hf2(33) = 2</strong>，因此将<strong>95</strong>踢出，插入<strong>33</strong>。被踢出的元素<strong>95</strong>在<strong>Table2</strong>中的<strong>slot index</strong>为<strong>2</strong>，该<strong>slot</strong>为<strong>vacant</strong>，没人使用，因此将<strong>95</strong>插入。完毕。现在的<strong>Tables</strong>中元素为：</p>

<p><img src="http://7xnljs.com1.z0.glb.clouddn.com/table2.jpg" alt="table2" /></p>

<p>值得注意的是，<strong>rearrange</strong>可能失败（表满了;或者发生“死循环”），此时需要进行<strong>rehash</strong>，因此代码里需要有一定的判断。当<strong>K=2</strong>时，只要<strong>load factor</strong>低于<strong>50%</strong>，需要<strong>rehash</strong>的概率很小很小。</p>

<p>在某些假设下，插入操作的摊还期望复杂度为常数时间。</p>

<h3 id="find">Find</h3>

<p>要检查的<strong>slot</strong>一共两个，<strong>index</strong>分别为<strong>hf1(key)</strong>和<strong>hf2(key)</strong>，因此只要查看一下<strong>Table1</strong>中的<strong>hf1(key)</strong>以及<strong>Table2</strong>中的<strong>hf2(key)</strong>这两个<strong>slot</strong>即可。时间复杂度为<strong>O(1)</strong>。</p>

<h3 id="del">Del</h3>

<p>同<strong>Find</strong>，要检查的<strong>slot</strong>也就两个，复杂度为<strong>O(1)</strong>。</p>

<h2 id="section">实现</h2>

<p>简单实现了一个，有需要的可以参考<a href="https://github.com/yebangyu/Yedis/blob/master/src/ds/CuckooHashMap.h">这里</a></p>

<h2 id="section-1">其他</h2>

<p>1，我们注意到，<strong>Cuckoo Hashing</strong>的精髓是使用两个不同的哈希函数，而不是两张表。两张表的存在，仅仅是为了分析上的方便。</p>

<p>当需要<strong>rehash</strong>而<strong>load factor</strong>又没达到<strong>100%</strong>时，我们其实不需要扩容哈希表，只需要更换哈希函数。</p>

<p>2，为嘛叫做<strong>Cuckoo Hashing</strong>？<strong>Cuckoo</strong>，即杜鹃鸟（布谷鸟），这种鸟有一种尿性：孵卵寄生。把蛋产到别的鸟窝里，让别人帮它孵化。这还不算，还要把人家寄主的一些卵给移走（不然容易引起怀疑嘛，毕竟鸟窝里突然多出几枚蛋。至于移走多少，就得看杜鹃鸟数学合不合格了）！等卵孵化完成，幼雏会将鸟窝里寄主的卵和其他幼雏推出鸟窝。真是牛逼闪闪了。</p>

<h2 id="section-2">参考文献</h2>

<p>http://resources.mpi-inf.mpg.de/departments/d1/teaching/ws14/AlgoDat/materials/cuckoo.pdf</p>

<p><strong>Cuckoo Hashing</strong>原始论文</p>

<p>https://www.eecs.harvard.edu/~michaelm/postscripts/esa2009.pdf</p>

<p>这篇文章介绍了一些关于<strong>Cuckoo Hashing</strong>的<strong>Open Questions</strong></p>

<p>http://web.stanford.edu/class/cs166/lectures/13/Slides13.pdf</p>

<p>这个<strong>slides</strong>偏重对<strong>Cuckoo Hashing</strong>理论上的分析，注意其中对于插入操作的处理和本文介绍的不同。</p>

<p>http://excess-project.eu/publications/published/CuckooHashing_ICDCS.pdf</p>

<p>碉堡了，<strong>Lock Free Cuckoo Hashing</strong>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2015-12-16 近期好书推荐]]></title>
    <link href="http://www.yebangyu.org/blog/2015/12/16/readinglist/"/>
    <updated>2015-12-16T23:05:35+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/12/16/readinglist</id>
    <content type="html"><![CDATA[<p>推荐几本近期阅读的好书。</p>

<h2 id="recommender-systems-handbook">Recommender Systems Handbook</h2>

<!--more-->

<p><img src="http://7xnljs.com1.z0.glb.clouddn.com/recommendersystemhandbook2nd.jpg" alt="rsh" /></p>

<p>这本书最近出第二版了，和第一版相比新增了不少内容，我最感兴趣的是其中的第11章，<strong>Recommender Systems in Industry: A Netflix Case Study</strong>，<strong>Xavier Amatriain</strong>大牛所写。</p>

<h2 id="distributed-systems--an-algorithmic-approach">Distributed Systems : An Algorithmic Approach</h2>

<p><img src="http://7xnljs.com1.z0.glb.clouddn.com/distributedsystem.jpg" alt="dsaaa" /></p>

<p>这本书去年出的第二版(第一版没看过)，貌似增加了<strong>paxos</strong>等不少内容。这本书强烈推荐，和其他分布式系统书籍相比，它不扯淡，也不是百科全书一样各种列词条全而不深，这本书实实在在的讲了一些内容，非常适合作为分布式系统的入门书。</p>

<h2 id="the-go-programming-language">The Go Programming Language</h2>

<p><img src="http://7xnljs.com1.z0.glb.clouddn.com/thegoprogramminglanguage.jpg" alt="tgpl" /></p>

<p><strong>Go</strong>语言编程入门书，作者之一<strong>Brian W. Kernighan</strong>，不用多介绍了吧。估计不久就要被列为<strong>Go</strong>语言的圣经了。为嘛学<strong>Go</strong>？个人对其中的并行特性比较感兴趣。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lock Free中的Hazard Pointer(中)]]></title>
    <link href="http://www.yebangyu.org/blog/2015/12/14/introduction-to-hazard-pointer/"/>
    <updated>2015-12-14T22:33:01+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/12/14/introduction-to-hazard-pointer</id>
    <content type="html"><![CDATA[<p>看过<a href="http://www.yebangyu.org/blog/2015/12/10/introduction-to-hazard-pointer/">上篇</a>的朋友，可能会认为：这不就是<strong>Smart Pointer</strong>么？于是可能写出这样的代码：</p>

<!--more-->

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include&lt;iostream&gt;</span>
</span><span class="line"><span class="cp">#include&lt;thread&gt;</span>
</span><span class="line"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class="line"><span class="k">class</span> <span class="nc">SmartPointer</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="n">SmartPointer</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="n">pointee_</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</span><span class="line">    <span class="n">ref_counts_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="kt">int</span> <span class="o">*</span><span class="n">pointee_</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">ref_counts_</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="n">SmartPointer</span> <span class="nf">sp</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">Reader</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="o">++</span><span class="n">sp</span><span class="p">.</span><span class="n">ref_counts_</span><span class="p">;</span>
</span><span class="line">  <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="p">(</span><span class="n">sp</span><span class="p">.</span><span class="n">pointee_</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">  <span class="o">--</span><span class="n">sp</span><span class="p">.</span><span class="n">ref_counts_</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">Writer</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="p">.</span><span class="n">ref_counts_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line">    <span class="k">delete</span> <span class="n">sp</span><span class="p">.</span><span class="n">pointee_</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">Reader</span><span class="p">);</span>
</span><span class="line">  <span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">Reader</span><span class="p">);</span>
</span><span class="line">  <span class="kr">thread</span> <span class="n">t3</span><span class="p">(</span><span class="n">Reader</span><span class="p">);</span>
</span><span class="line">  <span class="kr">thread</span> <span class="n">t4</span><span class="p">(</span><span class="n">Writer</span><span class="p">);</span>
</span><span class="line">  <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="n">t3</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="n">t4</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>然而事实上，这样做是错的。其中的<strong>race condition</strong>请读者自行分析。</p>

<p>那么，<strong>Hazard Pointer</strong>(<strong>HP</strong>)和<strong>Smart Pointer</strong>(<strong>SP</strong>)有什么区别呢？它们的共同点就是管理对应对象的生命周期，然而这两者有本质的区别，<strong>HP</strong>是线程安全的，而<strong>SP</strong>不是。</p>

<p>在<strong>HP</strong>中，每个读线程维护着自己的<strong>HP</strong> <strong>list</strong>，这个<strong>list</strong>，只由该线程写。因此，它是线程安全的。该<strong>list</strong>会（可以）被其他线程读。</p>

<p>每个写线程维护自己的<strong>retire list</strong>，该<strong>retire list</strong>只由该写线程进行读写。由于写线程可以读其他所有读线程的<strong>HP list</strong>，这样，差集（在自己的<strong>retire list</strong>，但是不在所有读线程的<strong>HP list</strong>里的指针），就是可以安全释放的指针。</p>

<p>而<strong>SP</strong>，则被多个线程读写，<strong>18、19</strong>两行也无法做成原子操作，因此，<strong>SP</strong>和<strong>HP</strong>有本质的区别，使用<strong>SP</strong>的程序往往需要搭配使用锁等设施来保证线程安全。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lock Free中的Hazard Pointer(上)]]></title>
    <link href="http://www.yebangyu.org/blog/2015/12/10/introduction-to-hazard-pointer/"/>
    <updated>2015-12-10T23:00:20+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/12/10/introduction-to-hazard-pointer</id>
    <content type="html"><![CDATA[<p>废话不多说了，直接开始讨论。</p>

<h2 id="section">险象环生</h2>

<p>首先看以下的程序，有问题吗？</p>

<!--more-->

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include&lt;iostream&gt;</span>
</span><span class="line"><span class="cp">#include&lt;thread&gt; </span><span class="c1">//C++11中的多线程基础设施</span>
</span><span class="line"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class="line"><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">reader</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="k">nullptr</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//nullptr是C++11中引入的</span>
</span><span class="line">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="nf">writer</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
</span><span class="line">  <span class="n">p</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">reader</span><span class="p">);</span>
</span><span class="line">  <span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">writer</span><span class="p">);</span>
</span><span class="line">  <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>答案当然是有问题。这个程序存在如下的<strong>race</strong> <strong>condition</strong>：如果当线程<strong>reader</strong>判断完<strong>p</strong>发现它不是<strong>nullptr</strong>后，还未执行第<strong>8</strong>行就被调度出去，轮到线程<strong>writer</strong>执行，它执行完<strong>13</strong>、<strong>14</strong>行后，又继续调度线程<strong>reader</strong>，此时执行第<strong>8</strong>行导致程序崩溃。</p>

<p>这里的问题，可以不精确地表述为：多线程程序中，某线程通过一个指针访问一段内存时，如何保证指针所指向的那块内存是有效的？</p>

<h2 id="hazard-pointer">Hazard Pointer</h2>

<p>这当然有多种方法，加一把互斥锁就万事大吉了(当然，得注意锁本身的生命周期)。不过本文讨论的是<strong>lock</strong> <strong>free</strong>情况下的内存管理，这里要介绍的是<strong>2004</strong>年左右提出的<strong>Hazard</strong> <strong>Pointer</strong>方法。</p>

<p>接着看以下代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include&lt;thread&gt;</span>
</span><span class="line"><span class="cp">#include&lt;iostream&gt;</span>
</span><span class="line"><span class="cp">#define Strong_Memory_Barrier __sync_synchronize</span>
</span><span class="line"><span class="cp">#define ACCESS_ONCE(x) (* (volatile typeof(x) *) &amp;(x))</span>
</span><span class="line"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class="line"><span class="k">struct</span> <span class="n">HazardPointer</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">HazardPointer</span><span class="p">()</span> <span class="o">:</span><span class="n">p_</span><span class="p">(</span><span class="k">nullptr</span><span class="p">){}</span>
</span><span class="line">  <span class="kt">int</span> <span class="o">*</span><span class="n">p_</span><span class="p">;</span> <span class="c1">//Hazard Pointer封装了原始指针</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">//原始指针</span>
</span><span class="line">
</span><span class="line"><span class="n">HazardPointer</span> <span class="o">*</span><span class="n">hp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HazardPointer</span><span class="p">();</span> <span class="c1">//只有一个线程可以写</span>
</span><span class="line">
</span><span class="line"><span class="k">class</span> <span class="nc">Writer</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="kt">void</span> <span class="n">retire</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">retire_list</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span><span class="c1">//设置要释放的指针</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="kt">void</span> <span class="n">gc</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="n">retire_list</span> <span class="o">==</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">p_</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="c1">//说明有读者正在使用它，不能释放</span>
</span><span class="line">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">      <span class="c1">//可以安全地释放</span>
</span><span class="line">      <span class="k">delete</span> <span class="n">retire_list</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="kt">void</span> <span class="n">write</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span class="line">    <span class="n">p</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span><span class="line">    <span class="n">retire</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
</span><span class="line">    <span class="n">gc</span><span class="p">();</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="k">private</span><span class="o">:</span>
</span><span class="line">  <span class="kt">int</span> <span class="o">*</span><span class="n">retire_list</span><span class="p">;</span><span class="c1">//记录待释放的指针</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="k">class</span> <span class="nc">Reader</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="kt">void</span> <span class="n">acquire</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="n">hp</span><span class="o">-&gt;</span><span class="n">p_</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="kt">void</span> <span class="n">release</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">    <span class="n">hp</span><span class="o">-&gt;</span><span class="n">p_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="kt">void</span> <span class="n">read</span><span class="p">()</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span><span class="line">    <span class="k">do</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">      <span class="n">tmp</span> <span class="o">=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span class="line">      <span class="n">Strong_Memory_Barrier</span><span class="p">();</span>
</span><span class="line">      <span class="n">acquire</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span> <span class="c1">//封装。这是告诉Writer：我要读，别释放！</span>
</span><span class="line">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="n">ACCESS_ONCE</span><span class="p">(</span><span class="n">p</span><span class="p">));</span><span class="c1">//仔细想想，为什么这里还要判断？</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="k">nullptr</span> <span class="o">!=</span> <span class="n">tmp</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//不妨想想，这里为什么也要判断？</span>
</span><span class="line">      <span class="c1">//it is safe to access *tmp from now on</span>
</span><span class="line">      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//没问题~</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">//when you finish reading it, just release it .</span>
</span><span class="line">    <span class="n">release</span><span class="p">();</span><span class="c1">//其实就是告诉Writer：用完了，可以释放了。</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Reader</span><span class="o">::</span><span class="n">read</span><span class="p">,</span> <span class="n">Reader</span><span class="p">());</span>
</span><span class="line">  <span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Writer</span><span class="o">::</span><span class="n">write</span><span class="p">,</span> <span class="n">Writer</span><span class="p">());</span>
</span><span class="line">  <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>总结：</p>

<p>1，对于读线程，每次访问指针前，都通过<strong>acquire</strong>动作，用<strong>Hazard</strong> <strong>Pointer</strong>封装一下待读取指针，此举保护了原始指针，向其他线程宣告，我正在读取它指向的内存，请别释放它。用完就<strong>release</strong>一下。</p>

<p>2，对于写线程，真正释放前，需要检查是否有读线程正在操作它。如何知道？看看自己待释放的指针，有没有存在在读线程的<strong>Hazard</strong> <strong>Pointer</strong>里即可。</p>

<p>至于<strong>52</strong>行，考虑如下情形：读线程刚刚设置了<strong>tmp</strong>指针，还没对它进行保护，就被调度出去；写线程执行<strong>gc</strong>时，发现没有读线程的<strong>Hazard</strong> <strong>Pointer</strong>封装了<strong>tmp</strong>指针，于是将它释放；等读线程重新被调度执行时通过<strong>tmp</strong>进行内存访问，就会导致问题。</p>

<p>至于<strong>53</strong>行，请读者自行分析。</p>

<h2 id="section-1">最后思考</h2>

<p>那么，<strong>Hazard</strong> <strong>Pointer</strong>的内存空间，谁来负责管理？</p>

<p>在实际程序里，一般所需<strong>Hazard</strong> <strong>Pointer</strong>的数量不会太多且较为固定，因此基本上只申请，不释放了。</p>

<h2 id="section-2">参考文献</h2>

<p>https://www.research.ibm.com/people/m/michael/ieeetpds-2004.pdf</p>

<h2 id="section-3">致谢</h2>

<p>感谢<a href="http://weibo.com/hanfooo">韩富晟</a>先生对我的指点，让我加深了对<strong>Hazard</strong> <strong>Pointer</strong>的认识。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Distcc和Dmucs构建大规模、分布式C++编译环境(下)]]></title>
    <link href="http://www.yebangyu.org/blog/2015/11/30/build-distributed-compilation-env/"/>
    <updated>2015-11-30T22:23:46+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/11/30/build-distributed-compilation-env</id>
    <content type="html"><![CDATA[<p><a href="http://www.yebangyu.org/blog/2015/11/23/build-distributed-compilation-ev/">上篇</a>文章，我们介绍了如何利用<strong>Distcc</strong>来搭建分布式编译环境，但是<strong>Distcc</strong>的默认调度策略过于简单，并且并不合理。假如我们的配置是</p>

<pre><code>export DISTCC_HOSTS="192.168.1.11 192.168.1.22 192.168.1.33"
</code></pre>

<p>那么<strong>Distcc</strong>会根据<strong>DISTCC_HOSTS</strong>中机器出现的先后顺序，来安排编译任务，越靠前的机器(比如这里的<strong>192.168.1.11</strong>)获得越多的任务，这显然是不科学的。</p>

<p>因此，我们可以利用<strong>Dmucs</strong>提供的调度策略，来优化我们的方案。它可以根据编译机的负载情况和硬件实力，来合理的调度资源。能者多劳嘛。</p>

<p>为了保证本文的完整性，我们还是不厌其烦地把我们的环境再交待下：</p>

<!--more-->

<p>开发机（<strong>Client</strong>）：这一台机器上有我们的项目、工程文件、代码，平时我们在这台机器上写代码，要编译的对象也在这台机器上。机器<strong>IP</strong>为<strong>192.168.1.99</strong>。</p>

<p>服务器（<strong>Server</strong>）：负责编译的机器，一共有<strong>3</strong>台。<strong>IP</strong>分别为<strong>192.168.1.11</strong>,<strong>192.168.1.22</strong>,<strong>192.168.1.33</strong>。</p>

<p>调度器（<strong>Scheduler</strong>）：调度程序<strong>Dmucs</strong>所在的机器，负责把编译任务合理的派发到编译机器（服务器）的编译程序上。<strong>IP</strong>为<strong>192.168.1.88</strong>。</p>

<h2 id="section">服务器</h2>

<p>1，安装<strong>gcc</strong></p>

<pre><code>sudo apt-get install gcc
</code></pre>

<p>2，安装<strong>Distcc</strong></p>

<pre><code>sudo apt-get install distcc
</code></pre>

<p>安装后可以得到两个二进制文件，<strong>distccd</strong>和<strong>distcc</strong>。前者主要负责网络数据处理，后者可以认为是<strong>g++</strong>的前端，调用<strong>g++</strong>进行编译。</p>

<p>3，配置<strong>Distcc</strong></p>

<p>打开<code>/etc/default/distcc</code>，设置如下配置项：</p>

<pre><code>STARTDISTCC="true"  
ALLOWEDNETS="127.0.0.1 192.168.1.0/24"
LISTENER="0.0.0.0"
</code></pre>

<p>第一行设置开机就启动<strong>distccd</strong></p>

<p>第二行设置允许利用本机进行编译的开发机</p>

<p>第三行设置监听的网络</p>

<p>4，启动<strong>distccd</strong></p>

<pre><code>sudo service distcc start
</code></pre>

<p>经过以上配置，每次机器开机，都会自动运行<strong>distccd</strong>。</p>

<p>运行如下命令确认下：</p>

<pre><code>ps -aux | grep distccd
</code></pre>

<p>如果看到类似的输出，说明<strong>distccd</strong>成功启动了。</p>

<pre><code>distccd   3457  0.0  0.0   3260   144 ?        SNs  23:33   0:00 /usr/bin/distccd --pid-file=/var/run/distccd.pid --log-file=/var/log/distccd.log --daemon --allow 127.0.0.1 --listen 0.0.0.0 --nice 10
distccd   3458  0.0  0.0   3260   144 ?        SN   23:33   0:00 /usr/bin/distccd --pid-file=/var/run/distccd.pid --log-file=/var/log/distccd.log --daemon --allow 127.0.0.1 --listen 0.0.0.0 --nice 10
distccd   3461  0.0  0.0   3260   144 ?        SN   23:33   0:00 /usr/bin/distccd --pid-file=/var/run/distccd.pid --log-file=/var/log/distccd.log --daemon --allow 127.0.0.1 --listen 0.0.0.0 --nice 10
</code></pre>

<p>5，安装<strong>Dmucs</strong></p>

<p>首先，从<a href="http://sourceforge.net/projects/dmucs/files/dmucs/dmucs%200.6.1/">这里</a>下载最新版本的<strong>Dmucs</strong>。</p>

<p>安装也就是普通的<code>configure</code>、<code>make</code>和<code>make install</code>，需要注意的是，执行<strong>make</strong>时，需要加上参数，例如：</p>

<pre><code>make CPPFLAGS=-DSERVER_MACH_NAME=\\\"192.168.1.88\\\"
</code></pre>

<p>其中<strong>192.168.1.88</strong>是我们的调度器的机器<strong>IP</strong>，根据实际情况自行修改。服务器上的编译程序，需要把编译负载情况，发送给调度器上的调度程序，作为它调度时的参考信息。</p>

<p>如果您嫌这样麻烦，那么也可以在<strong>make</strong>的时候不指定选项，而是在安装后，打开<code>/etc/default/dmucs</code>文件，设置如下字段：</p>

<pre><code>USE_SERVER = 192.168.1.88
</code></pre>

<p>6，启动<strong>loadavg</strong></p>

<p><strong>loadavg</strong>是安装<strong>Dmucs</strong>后得到的一个二进制文件，它会定期发送服务器平均负载情况给调度器，供调度程序决策之用。</p>

<pre><code>sudo loadavg -s 192.168.1.88 &amp;
</code></pre>

<p>其中，<strong>192.168.1.88</strong>是调度程序所在机器的<strong>IP</strong>地址。</p>

<h2 id="section-1">调度器</h2>

<p>1，安装<strong>Dmucs</strong></p>

<p>请参考上面的第<strong>5</strong>步。</p>

<p>2，配置服务器属性</p>

<p>在调度器的<code>/usr/local/share/dmucs/</code>目录下，新建<strong>hosts-info</strong>文件，格式和内容如下：</p>

<pre><code>#Format: machine number-of-cpus power-index
192.168.1.11       4            10
192.168.1.22       4            5
192.168.1.33       4            5
</code></pre>

<p>其中，<strong>power-index</strong>（必须大于等于<strong>1</strong>）表示了这台机器的战斗力，值越高代表性能越强，分到的编译任务也越多。能者多劳嘛。</p>

<p>3，启动调度程序</p>

<p>命令为：</p>

<pre><code>sudo service dmucs start
</code></pre>

<h2 id="section-2">开发机</h2>

<p>1，安装<strong>Distcc</strong></p>

<p>当然啦，我们假设您的开发机上已经安装<strong>gcc</strong>了。</p>

<p>2，安装<strong>Dmucs</strong></p>

<p>请参考上面的第<strong>5</strong>步。</p>

<p>3，应用<strong>Distcc</strong>和<strong>Dmucs</strong></p>

<p>应用<strong>Distcc</strong>和<strong>Dmucs</strong>来编译代码有几种方法：</p>

<p>方法一：修改<strong>makefile</strong>中的<strong>CXX</strong>的值</p>

<p>将<strong>makefile</strong>文件中的这一行</p>

<pre><code>CXX = g++
</code></pre>

<p>改为</p>

<pre><code>CXX = gethost distcc g++
</code></pre>

<p>然后运行<code>make -j18</code>即可。这里的<strong>18</strong>，为所有服务器的<strong>CPU Cores</strong>的数量乘以<strong>1.5</strong>。上面有<strong>3</strong>台服务器，每台有<strong>4</strong>核，因此这里设置为<strong>18</strong>。</p>

<p>为了获得最优值，很可能需要反复实验、测试。这里的<strong>gethost</strong>是<strong>DMUCS</strong>里的一个组件。</p>

<p>方法二：修改<strong>configure</strong>文件</p>

<p>如果您的<strong>makefile</strong>文件由<strong>automake</strong>产生，那么在运行<code>./configure</code>时得加上参数，变为：</p>

<pre><code>./configure --CXX=gethost distcc g++
</code></pre>

<p>那么生成的<strong>makefile</strong>文件将自动使用<strong>Distcc</strong>和<strong>Dmucs</strong>了。</p>

<h2 id="section-3">附录：调度策略</h2>

<p>根据<a href="http://dmucs.sourceforge.net/">文档</a>，<strong>Dmucs</strong>的调度策略是：</p>

<p>1，<strong>Dmucs</strong>会维护几个列表（原文为<strong>tier</strong>，表示等级、阶梯），每个列表对应一个<strong>power-index</strong>，具有相同<strong>power-index</strong>值的机器会在同一个列表中。因此，上面三台服务器，<strong>192.168.1.22</strong>和<strong>192.168.1.33</strong>会在同一个列表里，<strong>192.168.1.11</strong>在一个列表里。</p>

<p>2，每次获得编译任务请求时，<strong>Dmucs</strong>会优先从高<strong>power-index</strong>对应的列表里随机选一台机器。</p>

<p>3，如果<strong>Dmucs</strong>获知某台机器的平均负载过高（回忆下，该信息是服务器上的<strong>loadavg</strong>进程发过来的），那么会把该机器放到低一级的<strong>power-index</strong>对应的列表里。例如，<strong>192.168.1.11</strong>会被“下放”到<strong>power-index</strong>为<strong>5</strong>对应的列表里。</p>

<p>4，如果某台机器的平均负载过高超过五分钟，那么该机器会被暂时雪藏，不会给它分发编译任务，直到它的负载下降到正常水平。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Distcc和Dmucs构建大规模、分布式C++编译环境(上)]]></title>
    <link href="http://www.yebangyu.org/blog/2015/11/23/build-distributed-compilation-ev/"/>
    <updated>2015-11-23T22:48:32+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/11/23/build-distributed-compilation-ev</id>
    <content type="html"><![CDATA[<p>如果您的<strong>C++</strong>项目非常庞大，含有<strong>1000</strong>个<strong>.h</strong>文件，<strong>2000</strong>个<strong>.cpp</strong>文件，那么我敢打赌，每次编译所花的时间，都足够您喝<strong>3000</strong>杯咖啡了。如何加快编译速度？</p>

<p><strong>Distcc</strong>是开源的用于搭建分布式编译环境的利器，它通过利用多台机器的资源，并行编译，来解决这个棘手的问题。然而，它的调度算法过于简单，不大合理，因此我们利用<strong>DMUCS</strong>提供的调度功能，来搭建一个相对完美的分布式编译平台。本文，我们首先介绍如何（单独）使用<strong>Distcc</strong>来加速编译，下一篇介绍如何组合使用<strong>Distcc</strong>+<strong>DMUCS</strong>来做进一步的完善和优化。</p>

<p>话不多说，我们的编译平台包括：</p>

<!--more-->

<p>开发机（<strong>Client</strong>）：这一台机器上有我们的项目、工程文件、代码，平时我们在这台机器上写代码，要编译的对象也在这台机器上。机器<strong>IP</strong>为<strong>192.168.1.99</strong></p>

<p>服务器（<strong>Server</strong>）：负责编译的机器，一共有<strong>3</strong>台。<strong>IP</strong>分别为<strong>192.168.1.11</strong>,<strong>192.168.1.22</strong>,<strong>192.168.1.33</strong>.</p>

<p>调度器（<strong>Scheduler</strong>）：调度程序所在的机器，负责把编译任务合理的派发到编译机器（服务器）的编译程序上。<strong>IP</strong>为<strong>192.168.1.88</strong>。这台机器的部署和配置，我们留到下一篇博文介绍。</p>

<p>以上所有机器都是安装的<strong>Ubuntu 14.04</strong>操作系统。</p>

<h2 id="section">服务器</h2>

<p>1，安装<strong>gcc</strong></p>

<pre><code>sudo apt-get install gcc
</code></pre>

<p>2，安装<strong>Distcc</strong></p>

<pre><code>sudo apt-get install distcc
</code></pre>

<p>安装后可以得到两个二进制文件，<strong>distccd</strong>和<strong>distcc</strong>。前者主要负责网络数据处理，后者可以认为是<strong>g++</strong>的前端，调用<strong>g++</strong>进行编译。</p>

<p>3，配置<strong>Distcc</strong></p>

<p>打开<code>/etc/default/distcc</code>，设置如下配置项：</p>

<pre><code>STARTDISTCC="true"  
ALLOWEDNETS="127.0.0.1 192.168.1.0/24"
LISTENER="0.0.0.0"
</code></pre>

<p>第一行设置开机就启动<strong>distccd</strong></p>

<p>第二行设置允许利用本机进行编译的开发机</p>

<p>第三行设置监听的网络</p>

<p>4，启动<strong>distccd</strong></p>

<pre><code>sudo service distcc start
</code></pre>

<p>经过以上配置，每次机器开机，都会自动运行<strong>distccd</strong>。</p>

<p>运行如下命令确认下：</p>

<pre><code>ps -aux | grep distccd
</code></pre>

<p>如果看到类似的输出，说明一切OK了。</p>

<pre><code>distccd   3457  0.0  0.0   3260   144 ?        SNs  23:33   0:00 /usr/bin/distccd --pid-file=/var/run/distccd.pid --log-file=/var/log/distccd.log --daemon --allow 127.0.0.1 --listen 0.0.0.0 --nice 10
distccd   3458  0.0  0.0   3260   144 ?        SN   23:33   0:00 /usr/bin/distccd --pid-file=/var/run/distccd.pid --log-file=/var/log/distccd.log --daemon --allow 127.0.0.1 --listen 0.0.0.0 --nice 10
distccd   3461  0.0  0.0   3260   144 ?        SN   23:33   0:00 /usr/bin/distccd --pid-file=/var/run/distccd.pid --log-file=/var/log/distccd.log --daemon --allow 127.0.0.1 --listen 0.0.0.0 --nice 10
</code></pre>

<h2 id="section-1">开发机</h2>

<p>1，安装<strong>Distcc</strong></p>

<p>当然啦，我们假设您的开发机上已经安装<strong>gcc</strong>了。</p>

<p>2，设置编译资源</p>

<p>这一步是指定哪些机器（也就是上面的<strong>Server</strong>）来负责编译工作。</p>

<pre><code>export DISTCC_HOSTS="192.168.1.11 192.168.1.22 192.168.1.33"
</code></pre>

<p>每台机器的<strong>IP</strong>之间用空格隔开。</p>

<p>如果机器很多，那么这样填写可能不大方便，可以在<code>/etc/distcc/hosts</code>里添加。</p>

<p>这两种方法可以任选一种，如果您两种都用，那么<strong>Distcc</strong>只认<strong>DISTCC_HOSTS</strong>值。</p>

<p>3，应用<strong>Distcc</strong></p>

<p>应用<strong>Distcc</strong>来编译代码有几种方法：</p>

<p>方法一：修改<strong>makefile</strong>中的<code>CXX</code>的值</p>

<p>将<strong>makefile</strong>文件中的这一行</p>

<pre><code>CXX = g++ 
</code></pre>

<p>改为</p>

<pre><code>CXX = distcc g++
</code></pre>

<p>然后运行<code>make -j18</code>即可。这里的<strong>18</strong>，为所有服务器的<strong>CPU Cores</strong>的数量乘以<strong>1.5</strong>。上面有3台服务器，每台有<strong>4</strong>核，因此这里设置为<strong>18</strong>。</p>

<p>为了获得最优值，很可能需要反复实验、测试。</p>

<p>方法二：修改<strong>configure</strong>文件</p>

<p>如果您的<strong>makefile</strong>文件由<strong>automake</strong>产生，那么在运行<code>./configure</code>时得加上参数，变为：</p>

<pre><code>./configure --CXX=distcc g++
</code></pre>

<p>那么生成的<strong>makefile</strong>文件将自动使用<strong>Distcc</strong>了。</p>

<p>如果不出意外，编译速度已经大大提升了。然而，还有提高的空间，欲知详情，请看<a href="http://www.yebangyu.org/blog/2015/11/30/build-distributed-compilation-env/">下篇</a>分解。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[再谈C++中的static const]]></title>
    <link href="http://www.yebangyu.org/blog/2015/11/15/static-const-in-cpp/"/>
    <updated>2015-11-15T12:45:16+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/11/15/static-const-in-cpp</id>
    <content type="html"><![CDATA[<p>废话不多说了，开始这次的讨论吧。</p>

<h2 id="section">提出问题</h2>

<p>同事颜廷帅（微博：@颜挺帅）拿了一段代码让我分析。以下代码，能编译链接通过吗？</p>

<!--more-->

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="k">class</span> <span class="nc">Test</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">f</span><span class="p">(</span><span class="n">Test</span><span class="o">::</span><span class="n">a</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我的第一感觉是：应该没问题，吧。在<strong>Visual Studio 2013</strong> 实验了下，顺利通过，一切正常.</p>

<p>然而同事说，<strong>gcc</strong>下是报错的：Undefined reference to ‘Test::a’</p>

<p>这是为什么？</p>

<h2 id="section-1">分析问题</h2>

<p>写作本文时所用的环境是<strong>gcc 4.8.2 (Ubuntu 14.04 , X86平台)</strong>。</p>

<p>注意，本文的讨论只针对类的<strong>static const</strong>成员，也就是所谓的<strong>class scope</strong>。<strong>namespace scope</strong>的情况不属于我们的讨论范围内。</p>

<p>把以上代码保存为<strong>test.cpp</strong>，然后用<strong>gcc</strong>编译它：</p>

<pre><code>g++ -c -o test.o test.cpp
</code></pre>

<p>这个命令执行之后，我们会在目录下得到<strong>test.o</strong>文件。接着，我们通过<strong>objdump</strong>来查看符号表：</p>

<pre><code>objdump -x test.o
</code></pre>

<p>我们可以看到类似如下的输出：</p>

<pre><code>SYMBOL TABLE:
00000000 l    df *ABS*	00000000 test.cpp
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .note.GNU-stack	00000000 .note.GNU-stack
00000000 l    d  .eh_frame	00000000 .eh_frame
00000000 l    d  .comment	00000000 .comment
00000000 g     F .text	00000005 _Z1fRKi
00000005 g     F .text	00000019 main
00000000         *UND*	00000000 _ZN4Test1aE
</code></pre>

<p>上面的最后一行，<strong>_ZN4Test1aE</strong>就是对应我们程序中声明的<strong>Test::a</strong>。之所以长得这么复杂、奇怪，是因为编译器做了<strong>mangling</strong>处理。</p>

<p>注意到*UND*没？根据<a href="https://sourceware.org/binutils/docs/binutils/objdump.html">文档</a>的解释：</p>

<p>*UND* : if the section is referenced in the file being dumped, but not defined there</p>

<p>也就是<strong>_ZN4Test1aE</strong>在本<strong>.o</strong>文件中引用，然而它却木有定义。因此，报Undefined reference to ‘Test::a’的错，也就情理之中了。</p>

<p>那么，我们的程序是否真的引用了<strong>_ZN4Test1aE</strong>呢？恩，我们接着往下看。</p>

<p>输入如下命令：</p>

<pre><code>g++ -S test.cpp
</code></pre>

<p>我们可以得到类似这样的汇编代码(做了整理，节选)：</p>

<pre><code>main:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$4, %esp
	movl	$_ZN4Test1aE, (%esp) ;看到没？_ZN4Test1aE ！
	call	_Z1fRKi ;调用函数f
	movl	$0, %eax
	leave
	ret
</code></pre>

<p>虽然我们已经分析出为什么会报错，然而，我们还有一个疑问，就是，为什么下面的代码，是OK的？</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="c1">//这里没有 &amp;</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="k">class</span> <span class="nc">Test</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">f</span><span class="p">(</span><span class="n">Test</span><span class="o">::</span><span class="n">a</span><span class="p">);</span><span class="c1">//没问题</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>恩，有了前面的基础，相信读者诸君已经知道怎么分析。我们可以用同样的方法，看看它的汇编代码：</p>

<pre><code>main:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$4, %esp
	movl	$1, (%esp)     ;看到没？1，不是_ZN4Test1aE，也不是Test::a
	call	_Z1fi
	movl	$0, %eax
	leave
	ret
</code></pre>

<p>也就是说，在这里，编译器只是把<strong>Test::a</strong>认作一个占位符，实际使用之处用<strong>1</strong>代替了。</p>

<h2 id="section-2">解决问题</h2>

<p>知道原因了，那么怎么解决呢？恩，至少三种方法：</p>

<p>1，我们可以<strong>定义</strong>（而不是声明）<strong>Test::a</strong>。是的，上面的<code>static const int a = 1;</code>并不是它的定义式。如果要定义，那么我们应该这么做：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="c1">//还是传引用</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="k">class</span> <span class="nc">Test</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="k">const</span> <span class="kt">int</span> <span class="n">Test</span><span class="o">::</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//定义a</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">f</span><span class="p">(</span><span class="n">Test</span><span class="o">::</span><span class="n">a</span><span class="p">);</span><span class="c1">//现在没问题了</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>有兴趣的读者可以看看这个程序对应的符号表，就会发现<strong>Test::a</strong>被放在了程序的<strong>rodata section</strong>，而不是*UND*了。</p>

<p>2，如果仅仅声明<strong>a</strong>，那么我们可以按值的方式使用它，这没问题。也就是只使用它的值；而不去获得它的地址(当然，也包括引用。引用本质上也是地址)。</p>

<p>3，使用枚举类型。是的，枚举！像这样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="c1">//还是传引用</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="k">class</span> <span class="nc">Test</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="k">enum</span> <span class="n">HELLOWORLD</span> <span class="p">{</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">};</span> <span class="c1">//枚举，而不是 static const</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">f</span><span class="p">(</span><span class="n">Test</span><span class="o">::</span><span class="n">a</span><span class="p">);</span><span class="c1">//没问题</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>那么，这种情况下，编译器是如何处理的呢？就留给读者诸君作为练习吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[心平气和说三顾茅庐]]></title>
    <link href="http://www.yebangyu.org/blog/2015/11/11/xinpingqiheshuosangumaolu/"/>
    <updated>2015-11-11T22:47:31+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/11/11/xinpingqiheshuosangumaolu</id>
    <content type="html"><![CDATA[<p>前几天在知乎上，看到一个如何评价易中天先生品三国的帖子，楼里有人这样说（节选，细节可以看这里：<a href="http://www.zhihu.com/question/23414118">怎样评价易中天品三国？</a>）：</p>

<!--more-->

<p>“因为偏颇导致他所举出的材料都带有偏颇性。比方说有一集他质疑三顾茅庐的真实性，举出一个例子是出自裴松之的注，诸葛亮去找刘备，结果刘备只是把他当普通人处理，结果之后刘备拿草编织，被诸葛亮看到说难道将军的志向就是编草鞋吗。然后刘备叹口气说那我能怎么办呢。诸葛亮说：你认为你和曹操比何如？刘备便答：自然是比不上云云大抵就是这样的一个故事。易中天照搬不误，讲了出来，但是没有讲这篇材料的出处。这篇材料并不是出自三国志，而是出自《魏略》。是裴松之把他补了进去，并且提出了自己的反对意见，认为这条材料不可信。但是易中天没有提这个故事的出处，也没有谈裴松之的“不可信”意见，却直接拿来用，为了达到自己的观点，丝毫不向观众解释清楚。这个是有点误导了罢？”</p>

<p>在我看来，这是典型的睁着眼睛说瞎话，因此，我在下面和他理论起来，双方对话也不妨贴在下面：</p>

<p><img src="http://7xnljs.com1.z0.glb.clouddn.com/xinpingqiheshuosangu.png" alt="zhihuduihua" /></p>

<p>这就很有意思了，那我就不妨来钻钻牛角尖。</p>

<h2 id="section">易中天是否没讲出处</h2>

<p>根据《易中天品三国》，易中天先生在谈到这个问题时，说：</p>

<p>另外裴松之（这里是口误，应该是陈寿）编完诸葛亮的这个集子以后，有一个《上诸葛亮集表》（有错，应该是进《诸葛亮集》表）里面也是这么记载的，所以裴松之在为《三国志》作注的时候，他把《魏略》和《九州春秋》的说法他注在注文里面了，同时他发了一个议论，他说历史上由于历史学家文件不同，就是他的信息渠道不同，他的信息来源不同，是会有不同的记载，这很正常，但是这个事情如此冲突和矛盾太奇怪了。</p>

<p>可见，易中天先生不仅说了出处是《魏略》和《九州春秋》，并且还提了裴松之的议论。</p>

<p>这里节选的是易中天品三国视频版本，书籍版本也大体一致。读者可以查阅《易中天品三国（上）》149-151页。书里不但明确说了出处，还交待了“裴松之认为不实”。</p>

<h2 id="section-1">《魏书》和《魏略》，谁不可信？</h2>

<p>要明白这一点，得先知道《魏书》和《魏略》的作者。</p>

<p>《魏书》的作者，是王沈。王沈是司马懿一党，所以，在写《魏书》的时候，便抹去了很多真相，抹去了很多对司马懿家族不利的东西。另外，根据《晋书》列传第九之王沈等传对它的评价，“多为时讳，未若陈寿之实录也。”。《史通》也说它“其书多为时讳，殊非实录”。</p>

<p>至于《魏略》，是魏朝郎中鱼豢自己撰写的，非官方史书。马植杰先生在他的《三国史》里（407页），这么评价它：</p>

<p>近人张鹏一《魏略辑本》谓鱼豢死于晋太康以后，则鱼豢入晋后还活了十六年以上，可知鱼豢不曾仕晋。看来，鱼豢是忠于曹魏而耻为晋臣者，故《魏略》叙事颇注重品节作风。裴松之注《三国志》，引用之书，以《魏略》为最多，《魏略》虽早已亡佚，但从裴注中尚可窥知其梗概。从《魏略》的内容和文字看，还是相当好的。</p>

<p>史家多认为《魏略》是良史，比较可信。</p>

<h2 id="section-2">魏国人难道比蜀国更懂蜀国历史？</h2>

<p>不能说蜀国人自己的记载就一定比别国真实。</p>

<p>要知道，魏蜀吴三国中，（只有）蜀国是没有史官的，很多事情的记载，还得去别国的书籍中去了解，比如说，蜀国费祎出使吴国时的一些外交趣事，还得从《祎别传》中获得。这并不奇怪，也没什么。</p>

<p>著名历史学家缪钺先生说，陈寿在写《三国志》时，就把《魏略》等作为参考资料的依据。（参考先生为岳麓出版社出版的《三国志》写的序言）。</p>

<p>因此，认为蜀国人比一定比魏国人更懂蜀国历史，是非常狭隘的观点，也是混账逻辑，也是不懂历史的表现。</p>

<p>完。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[空指针(NULL)不能用吗？]]></title>
    <link href="http://www.yebangyu.org/blog/2015/11/06/null-pointer-can-be-accessed/"/>
    <updated>2015-11-06T22:38:30+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/11/06/null-pointer-can-be-accessed</id>
    <content type="html"><![CDATA[<p>我们常常被告知，使用指针前需要判断是否为<strong>NULL</strong>；如果是<strong>NULL</strong>而你去使用它就会出问题。真相果真是这样吗？</p>

<p>同事颜廷帅（微博：@颜挺帅）给我看以下一个程序，问我，这段程序执行后，有问题吗？</p>

<!--more-->

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include&lt;iostream&gt;</span>
</span><span class="line"><span class="cp">#include&lt;cstdlib&gt;</span>
</span><span class="line"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class="line"><span class="k">class</span> <span class="nc">Test1</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">private</span><span class="o">:</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Test1: Core or not ? &quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">Test1</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">();</span><span class="c1">//会core吗？会出大事吗？</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这里，<strong>p</strong>是一个空指针，通过这个空指针，我们访问了函数<strong>f</strong>。没<strong>core</strong>，没问题，成功输出了 <strong>Test1: Core or not ?</strong></p>

<p>发生了什么事？空指针也能用？</p>

<p>如果我们把<strong>f</strong>稍作修改，程序其他地方不做任何变动：</p>

<pre><code>void f()
{
  cout&lt;&lt;"Test1: Core or not ? "&lt;&lt;a&lt;&lt;endl;//access a
}
</code></pre>

<p>那么程序运行后分分钟<strong>core</strong>掉了。</p>

<p>有没有感觉了？嗯，相信有了。我们继续往下看：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include&lt;iostream&gt;</span>
</span><span class="line"><span class="cp">#include&lt;cstdlib&gt;</span>
</span><span class="line"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class="line"><span class="k">static</span> <span class="kt">int</span> <span class="n">global</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="k">class</span> <span class="nc">Test2</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">private</span><span class="o">:</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Test1: Core or not ? &quot;</span><span class="o">&lt;&lt;</span><span class="n">global</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//access global</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">Test2</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">();</span><span class="c1">//会core吗？会出大事吗？</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>也没问题。</p>

<p>嗯，你可能已经知道了真相。通过空指针访问东西，只要那个东西是确实存在的，就不会有问题。</p>

<p>怎么理解“确实存在”？它是一个实体，看得见，摸得着。</p>

<p>这得说到<strong>C++</strong>程序中对象的内存布局。</p>

<p>在<strong>C++</strong>中，成员函数、静态变量是独立于对象存放的；而普通的数据成员是和对象相关的。</p>

<pre><code>Test1 obj1;
Test1 obj2;
</code></pre>

<p><strong>obj1</strong>和<strong>obj2</strong>是共用函数<strong>f</strong>的，函数<strong>f</strong>对<strong>obj1</strong>和<strong>obj2</strong>是相同的，内存中只有一份实体；而<strong>obj1</strong>和<strong>obj2</strong>有自己的实体<strong>a</strong>。</p>

<p>然而，注意到<code>Test1 *p = NULL;</code>仅仅是声明式，而非定义式。这时候，没有定义任何的对象出来，通过<strong>p</strong>如何访问<strong>a</strong>呢？哪来的<strong>a</strong>呢？<strong>a</strong>在内存里并不存在。因此，访问<strong>a</strong>必定<strong>core</strong>。</p>

<p>而函数<strong>f</strong>呢？它是独立于对象存放的，自然没问题。一般说来，<strong>f</strong>位于程序的代码段，而全局变量一般位于<strong>BSS</strong>段或者<strong>DATA</strong>段（这个比较复杂，和该全局变量是否初始化以及初始化为<strong>0</strong>还是非<strong>0</strong>有关）。而当我们定义对象时，才为该对象分配内存，才有数据成员<strong>a</strong>的存在：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include&lt;iostream&gt;</span>
</span><span class="line"><span class="cp">#include&lt;cstdlib&gt;</span>
</span><span class="line"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class="line"><span class="k">static</span> <span class="kt">int</span> <span class="n">global1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//DATA段</span>
</span><span class="line"><span class="k">static</span> <span class="kt">int</span> <span class="n">global2</span><span class="p">;</span> <span class="c1">//BSS段</span>
</span><span class="line"><span class="k">class</span> <span class="nc">Test3</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">private</span><span class="o">:</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Test1: Core or not ? &quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="n">Test3</span> <span class="n">obj3</span><span class="p">;</span> <span class="c1">//DATA段 (调用默认构造函数进行初始化)</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">Test3</span> <span class="n">obj1</span><span class="p">;</span> <span class="c1">//stack段。定义obj1，这时候自然为a分配内存了</span>
</span><span class="line">  <span class="n">Test3</span> <span class="o">*</span><span class="n">obj2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Test3</span><span class="p">();</span><span class="c1">//heap段，也为a分配内存了。</span>
</span><span class="line">  <span class="n">Test3</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="c1">//只是声明，没有定义。没有对象，也没有a。</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>受王杰兄（微博：@skyline09_）启发和提示，其实我们可以换一种形式来理解。</p>

<p>我们知道，<strong>C++</strong>中，类的非静态成员函数会被编译器改写：</p>

<p><code>void Test::f()</code>被改写为类似于<code>void Test__f(Test *const this)</code></p>

<p>而</p>

<pre><code>Test *p = NULL;

p-&gt;f();
</code></pre>

<p>将被编译器改写为</p>

<pre><code>Test *p = NULL;
Test__f(p);
</code></pre>

<p>因此<code>Test::f</code>中带有一个值为<strong>NULL</strong>的<strong>this</strong>指针（<strong>p</strong>），如果通过这个空指针<strong>p</strong>读写数据，就会崩溃。否则，安然无事。</p>

<p>那么，<strong>this</strong>指针可以操纵哪些东西呢？哦，类的非静态数据成员。而类的静态数据成员，全局变量等，是不会通过<strong>this</strong>指针访问的，因此，上例中，访问<strong>a</strong>崩溃，访问<strong>global</strong>则安全。</p>

<p>最后，我们看一个问题。这个问题，最早我是从杜克伟兄（微博：@小伙伴-小伙伴儿）那里听到的。</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">class</span> <span class="nc">Test4</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">  <span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">    <span class="n">cout</span><span class="o">&lt;&lt;&amp;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 有问题吗？</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">Test4</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">();</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>没问题。<strong>&amp;(*this)</strong>就是<strong>this</strong>，值和<strong>p</strong>相等。因此上面会输出<strong>0</strong>。</p>

<p>综上，使用空指针并不一定会发生问题，关键是怎么用。遇到问题得理性分析，不要想当然。</p>

<p>纸上学来终觉浅，绝知此事要躬行。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编写高质量代码(上)]]></title>
    <link href="http://www.yebangyu.org/blog/2015/11/06/how-to-write-elegant-cpp-codes/"/>
    <updated>2015-11-06T00:24:56+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/11/06/how-to-write-elegant-cpp-codes</id>
    <content type="html"><![CDATA[<p>我们知道，<strong>int</strong>和<strong>double</strong>能表示的数值的范围不同。其中，<strong>64</strong>位有符号整数的范围是[<strong>-9223372036854775808</strong>,<strong>9223372036854775807</strong>]，而<strong>64</strong>位无符号整数的范围是[<strong>0</strong>,<strong>18446744073709551615</strong>]。这两个区间有一定的<strong>overlap</strong>，而<strong>double</strong>可以表示的范围更大。</p>

<p>现在，需要编写两个函数:给定一个<strong>double</strong>型的<strong>value</strong>，判断这个<strong>value</strong>是否是一个合法的<strong>int64_t</strong>或者<strong>uint64_t</strong>。本文说的“合法”，是指数值上落在了范围内。</p>

<pre><code>bool is_valid_uint64(const Double &amp;value);

bool is_valid_int64(const Double &amp;value);
</code></pre>

<p>这里我们用<strong>Double</strong>而不是<strong>double</strong>，原因是我们的<strong>double</strong>不是基础数据类型，而是通过一定方法实现的<strong>ADT</strong>，这个<strong>ADT</strong>的成员函数有：</p>

<!--more-->

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">class</span> <span class="nc">Double</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">public</span><span class="o">:</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">get_next_digit</span><span class="p">(</span><span class="kt">bool</span> <span class="o">&amp;</span><span class="n">is_decimal</span><span class="p">);</span>
</span><span class="line">    <span class="kt">bool</span> <span class="nf">is_zero</span><span class="p">();</span>
</span><span class="line">    <span class="kt">bool</span> <span class="nf">is_neg</span><span class="p">();</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>通过调用<code>get_next_digit</code>，可以返回一个数字，不断调用它，可以得到所有<strong>digits</strong>。举个例子，对于值为<strong>45.67</strong>的一个<strong>Double</strong>对象，调用它的<code>get_next_digit</code>成员函数将依次得到</p>

<p>4 is_decimal = false //表示整数部分</p>

<p>5 is_decimal = false //表示整数部分</p>

<p>6 is_decimal = true //表示小数部分</p>

<p>7 is_decimal = true //表示小数部分</p>

<p>当<code>get_next_digit</code>返回<strong>-1</strong>时，表示读取完毕。</p>

<p>如何利用<strong>Double</strong>类里的成员函数，来实现<code>is_valid_uint64</code>和<code>is_valid_int64</code>这两个函数呢？</p>

<p>一些新手可能会写这样的代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
<span class="line-number">85</span>
<span class="line-number">86</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">bool</span> <span class="nf">is_valid_uint64</span><span class="p">(</span><span class="k">const</span> <span class="n">Double</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">bool</span> <span class="n">is_valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">digits</span><span class="p">[</span><span class="mi">2000</span><span class="p">];</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">counts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">is_zero</span><span class="p">())</span> <span class="p">{</span>
</span><span class="line">    <span class="n">is_valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">is_neg</span><span class="p">())</span> <span class="p">{</span>
</span><span class="line">    <span class="n">is_valid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">bool</span> <span class="n">is_decimal</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">digit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span><span class="p">((</span><span class="n">digit</span><span class="o">=</span><span class="n">value</span><span class="p">.</span><span class="n">get_next_digit</span><span class="p">(</span><span class="n">is_decimal</span><span class="p">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="k">if</span> <span class="p">(</span><span class="n">is_decimal</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">is_valid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">        <span class="k">break</span><span class="p">;</span>
</span><span class="line">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">        <span class="n">digits</span><span class="p">[</span><span class="n">counts</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">digit</span><span class="p">;</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="kt">uint64_t</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="kt">uint64_t</span> <span class="n">base</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">tmp</span> <span class="o">+=</span> <span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">base</span><span class="p">;</span>
</span><span class="line">      <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">UINT64_MAX</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">is_valid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">        <span class="k">break</span><span class="p">;</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">      <span class="n">base</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">return</span> <span class="n">is_valid</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">bool</span> <span class="nf">is_valid_int64</span><span class="p">(</span><span class="k">const</span> <span class="n">Double</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">bool</span> <span class="n">is_valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">digits</span><span class="p">[</span><span class="mi">2000</span><span class="p">];</span>
</span><span class="line">  <span class="kt">int</span> <span class="n">counts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">  <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">is_zero</span><span class="p">())</span> <span class="p">{</span>
</span><span class="line">    <span class="n">is_valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span><span class="line">  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">is_neg</span><span class="p">())</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">bool</span> <span class="n">is_decimal</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">digit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span><span class="p">((</span><span class="n">digit</span><span class="o">=</span><span class="n">value</span><span class="p">.</span><span class="n">get_next_digit</span><span class="p">(</span><span class="n">is_decimal</span><span class="p">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="k">if</span> <span class="p">(</span><span class="n">is_decimal</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">is_valid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">        <span class="k">break</span><span class="p">;</span>
</span><span class="line">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">        <span class="n">digits</span><span class="p">[</span><span class="n">counts</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">digit</span><span class="p">;</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="kt">uint64_t</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="kt">uint64_t</span> <span class="n">base</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">tmp</span> <span class="o">+=</span> <span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">base</span><span class="p">;</span>
</span><span class="line">      <span class="n">tmp</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line">      <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">INT64_MIN</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">is_valid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">        <span class="k">break</span><span class="p">;</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">      <span class="n">base</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">    <span class="kt">bool</span> <span class="n">is_decimal</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">digit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span><span class="p">((</span><span class="n">digit</span><span class="o">=</span><span class="n">value</span><span class="p">.</span><span class="n">get_next_digit</span><span class="p">(</span><span class="n">is_decimal</span><span class="p">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="k">if</span> <span class="p">(</span><span class="n">is_decimal</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">is_valid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">        <span class="k">break</span><span class="p">;</span>
</span><span class="line">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">        <span class="n">digits</span><span class="p">[</span><span class="n">counts</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">digit</span><span class="p">;</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="kt">uint64_t</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="kt">uint64_t</span> <span class="n">base</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">      <span class="n">tmp</span> <span class="o">+=</span> <span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">base</span><span class="p">;</span>
</span><span class="line">      <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">INT64_MAX</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="n">is_valid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">        <span class="k">break</span><span class="p">;</span>
</span><span class="line">      <span class="p">}</span>
</span><span class="line">      <span class="n">base</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="k">return</span> <span class="n">is_valid</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>这样的代码，存在诸多问题。</p>

<h2 id="section">设计问题</h2>

<p>不难发现，两个函数存在很多相似甚至相同的代码；而同一个函数内部，也有不少代码重复。重复的东西往往不是好的。重构？</p>

<h2 id="section-1">性能问题</h2>

<p>先获得所有digits，然后从最低位开始向最高位构造值，效率较低。难道没有可以从最高位开始，边获得边计算，不需要临时数组存储所有digits的方法吗？</p>

<h2 id="section-2">正确性问题</h2>

<p>随便举几个例子：</p>

<p>第<strong>24</strong>行，<code>tmp += digits[i] * base</code>;有没有考虑到可能的溢出呢？</p>

<p>第<strong>68</strong>行，难道有小数部分就一定不是合法的<strong>int64</strong>吗？那么，<strong>123.000</strong>？嗯？</p>

<h2 id="section-3">规范问题</h2>

<p>帅哥，这么多代码，一行注释都没有，这样真的好吗？</p>

<p>因此，毫无疑问，这是烂代码，不合格的代码，需要重写的代码。</p>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux环境多线程编程基础设施]]></title>
    <link href="http://www.yebangyu.org/blog/2015/10/31/linux-parallen-programmming-infrastructure/"/>
    <updated>2015-10-31T18:43:00+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/10/31/linux-parallen-programmming-infrastructure</id>
    <content type="html"><![CDATA[<p>本文介绍多线程环境下并行编程的基础设施。主要包括：</p>

<blockquote>
  <ul>
    <li>volatile</li>
    <li>__thread</li>
    <li>Memory Barrier</li>
    <li>__sync_synchronize</li>
  </ul>
</blockquote>

<h2 id="volatile">volatile</h2>

<p>编译器有时候为了优化性能，会将一些变量的值缓存到寄存器中，因此如果编译器发现该变量的值没有改变的话，将从寄存器里读出该值，这样可以避免内存访问。</p>

<p>但是这种做法有时候会有问题。如果该变量确实（以某种很难检测的方式）被修改呢？那岂不是读到错的值？是的。在多线程情况下，问题更为突出：当某个线程对一个内存单元进行修改后，其他线程如果从寄存器里读取该变量可能读到老值，未更新的值，错误的值，不新鲜的值。</p>

<!--more-->

<p>如何防止这样错误的“优化”？方法就是给变量加上<strong>volatile</strong>修饰。</p>

<pre><code>volatile int i=10;//用volatile修饰变量i
......//something happened 
int b = i;//强制从内存中读取实时的i的值
</code></pre>

<p><strong>OK</strong>，毕竟<strong>volatile</strong>不是完美的，它也在某种程度上限制了优化。有时候是不是有这样的需求：我要你立即实时读取数据的时候，你就访问内存，别优化；否则，你该优化还是优化你的。能做到吗？</p>

<p>不加<strong>volatile</strong>修饰，那么就做不到前面一点。加了<strong>volatile</strong>，后面这一方面就无从谈起，怎么办？伤脑筋。</p>

<p>其实我们可以这样：</p>

<pre><code>int i = 2; //变量i还是不用加volatile修饰

#define ACCESS_ONCE(x) (* (volatile typeof(x) *) &amp;(x))
</code></pre>

<p>需要实时读取i的值时候，就调用<code>ACCESS_ONCE(i)</code>，否则直接使用i即可。</p>

<p>这个技巧，我是从《<strong>Is parallel programming hard？</strong>》上学到的。</p>

<p>听起来都很好？然而险象环生：<strong>volatile</strong>常被误用，很多人往往不知道或者忽略它的两个特点：在<strong>C/C++</strong>语言里，<strong>volatile</strong>不保证原子性；使用<strong>volatile</strong>不应该对它有任何<strong>Memory Barrier</strong>的期待。</p>

<p>第一点比较好理解，对于第二点，我们来看一个很经典的例子：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="k">volatile</span> <span class="kt">int</span> <span class="n">is_ready</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="kt">char</span> <span class="n">message</span><span class="p">[</span><span class="mi">123</span><span class="p">];</span>
</span><span class="line"><span class="kt">void</span> <span class="n">thread_A</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="k">while</span><span class="p">(</span><span class="n">is_ready</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line">  <span class="p">{</span>
</span><span class="line">  <span class="p">}</span>
</span><span class="line">  <span class="c1">//use message;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="n">thread_B</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">strcpy</span><span class="p">(</span><span class="n">message</span><span class="p">,</span><span class="s">&quot;everything seems ok&quot;</span><span class="p">);</span>
</span><span class="line">  <span class="n">is_ready</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>线程<strong>B</strong>中，虽然<strong>is_ready</strong>有<strong>volatile</strong>修饰，但是这里的<strong>volatile</strong>不提供任何<strong>Memory Barrier</strong>，因此<strong>12</strong>行和<strong>13</strong>行可能被乱序执行，<code>is_ready = 1</code>被执行，而<strong>message</strong>还未被正确设置，导致线程<strong>A</strong>读到错误的值。</p>

<p>这意味着，在多线程中使用<strong>volatile</strong>需要非常谨慎、小心。</p>

<h2 id="thread">__thread</h2>

<p><strong>__thread</strong>是<strong>gcc</strong>内置的用于多线程编程的基础设施。用<strong>__thread</strong>修饰的变量，每个线程都拥有一份实体，相互独立，互不干扰。举个例子：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include&lt;iostream&gt;  </span>
</span><span class="line"><span class="cp">#include&lt;pthread.h&gt;  </span>
</span><span class="line"><span class="cp">#include&lt;unistd.h&gt;  </span>
</span><span class="line"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class="line"><span class="n">__thread</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="kt">void</span><span class="o">*</span> <span class="nf">thread1</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">);</span>
</span><span class="line"><span class="kt">void</span><span class="o">*</span> <span class="nf">thread2</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">);</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="kt">pthread_t</span> <span class="n">pthread1</span><span class="p">;</span>
</span><span class="line">  <span class="kt">pthread_t</span> <span class="n">pthread2</span><span class="p">;</span>
</span><span class="line">  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pthread1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">thread1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pthread2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">thread2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">  <span class="n">pthread_join</span><span class="p">(</span><span class="n">pthread1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">  <span class="n">pthread_join</span><span class="p">(</span><span class="n">pthread2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span><span class="o">*</span> <span class="nf">thread1</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">cout</span><span class="o">&lt;&lt;++</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//输出 2  </span>
</span><span class="line">  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span><span class="o">*</span> <span class="nf">thread2</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">  <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//等待thread1完成更新</span>
</span><span class="line">  <span class="n">cout</span><span class="o">&lt;&lt;++</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//输出 2，而不是3</span>
</span><span class="line">  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>需要注意的是：</p>

<p>1，<strong>__thread</strong>可以修饰全局变量、函数的静态变量，但是无法修饰函数的局部变量。</p>

<p>2，被<strong>__thread</strong>修饰的变量只能在编译期初始化，且只能通过常量表达式来初始化。</p>

<h2 id="memory-barrier">Memory Barrier</h2>

<p>为了优化，现代编译器和<strong>CPU</strong>可能会乱序执行指令。例如：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line"><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line"><span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</span><span class="line"><span class="n">b</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><strong>CPU</strong>乱序执行后，第4行语句和第5行语句的执行顺序可能变为先<code>b=10</code>然后再<code>a=b+3</code></p>

<p>有些人可能会说，那结果不就不对了吗？b为10，a为13？可是正确结果应该是a为5啊。</p>

<p>哦，这里说的是语句的执行，对应的汇编指令不是简单的mov b,10和mov b,a+3。</p>

<p>生成的汇编代码可能是：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">movl</span>    <span class="n">b</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span> <span class="o">%</span><span class="n">eax</span> <span class="p">;</span> <span class="err">将</span><span class="n">b</span><span class="err">的值暂存入</span><span class="o">%</span><span class="n">eax</span>
</span><span class="line"><span class="n">movl</span>    <span class="err">$</span><span class="mi">10</span><span class="p">,</span> <span class="n">b</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">)</span> <span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">10</span>
</span><span class="line"><span class="n">addl</span>    <span class="err">$</span><span class="mi">3</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span> <span class="p">;</span> <span class="o">%</span><span class="n">eax</span><span class="err">加</span><span class="mi">3</span>
</span><span class="line"><span class="n">movl</span>    <span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="n">a</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">)</span> <span class="p">;</span> <span class="err">将</span><span class="o">%</span><span class="n">eax</span><span class="err">也就是</span><span class="n">b</span><span class="o">+</span><span class="mi">3</span><span class="err">的值写入</span><span class="n">a</span><span class="p">,</span><span class="err">即</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">3</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这并不奇怪，为了优化性能，有时候确实可以这么做。但是在多线程并行编程中，有时候乱序就会出问题。</p>

<p>一个最典型的例子是用锁保护临界区。如果临界区的代码被拉到加锁前或者释放锁之后执行，那么将导致不明确的结果，往往让人不开心的结果。</p>

<p>还有，比如随意将读数据和写数据乱序，那么本来是先读后写，变成先写后读就导致后面读到了脏的数据。因此，<strong>Memory Barrier</strong>就是用来防止乱序执行的。具体说来，<strong>Memory Barrier</strong>包括三种：</p>

<p>1，<strong>acquire barrier</strong>。<strong>acquire barrier</strong>之后的指令不能也不会被拉到该<strong>acquire barrier</strong>之前执行。</p>

<p>2，<strong>release barrier</strong>。<strong>release barrier</strong>之前的指令不能也不会被拉到该<strong>release barrier</strong>之后执行。</p>

<p>3，<strong>full barrier</strong>。以上两种的合集。</p>

<p>所以，很容易知道，加锁，也就是<strong>lock</strong>对应<strong>acquire barrier</strong>；释放锁，也就是<strong>unlock</strong>对应<strong>release barrier</strong>。哦，那么<strong>full barrier</strong>呢？</p>

<h2 id="syncsynchronize">__sync_synchronize</h2>

<p><code>__sync_synchronize</code>就是一种<strong>full barrier</strong>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tools of the trade]]></title>
    <link href="http://www.yebangyu.org/blog/2015/10/25/tools-of-the-trade/"/>
    <updated>2015-10-25T22:09:08+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/10/25/tools-of-the-trade</id>
    <content type="html"><![CDATA[<p>本篇是对《<strong>Is parallel programming hard</strong>》第四章《<strong>Tools of the trade</strong>》的总结，不是单纯的翻译，算是读书笔记，并且略有补充。</p>

<p>本章介绍了并行编程的工具和途径，具体包括</p>

<blockquote>
  <ul>
    <li>Shell Script Languages</li>
    <li>POSIX 多进程</li>
    <li>POSIX 多线程</li>
    <li>原子操作</li>
  </ul>
</blockquote>

<h2 id="shell-script-language">Shell Script Language</h2>

<!--more-->

<p>如果不同的执行单元之间没有过多的数据交互，待执行的任务分区性较好，那么我们可以考虑通过<strong>Shell</strong>创建多个进程来完成任务。例如，我们需要计算每连续的<strong>100</strong>个元素的和，需要计算3组，好吧，比如说我们需要计算<strong>1+2+3+…+100</strong>；<strong>101+102+…200</strong>；<strong>201+201+…+300</strong>，那么我们可以编写一个程序，然后通过<strong>Shell</strong>创建<strong>3</strong>个进程，通过命令行传入参数（比如这里的待求和的元素的起点）。</p>

<pre><code>compute 1 &gt; compute_1.out &amp;
compute 101 &gt; compute_2.out &amp;
compute 201 &gt; compute_3.out &amp;
wait
</code></pre>

<p>其中<strong>compute</strong>是可执行程序名，<strong>1</strong>、<strong>101</strong>、<strong>201</strong>是命令行参数，<strong>&gt; x.out</strong>代表将输出结果重定向到文件<strong>x.out</strong>中，<strong>&amp;</strong>表示程序后台运行。<strong>wait</strong>表示等待运行程序结束。</p>

<p>那么多进程的并行设计有什么缺点呢？</p>

<p>1，创建进程的时间略长。在<strong>Intel Core Duo Laptop</strong>上创建一个最小<strong>C</strong>程序需要大概<strong>480ms</strong>。当你的任务执行时间和进程启动时间相比反而不值一提时，这时候创建进程所需的时间就显得很尴尬。多线程<strong>VS</strong>多进程也是<strong>Spark</strong>和<strong>Hadoop</strong>相比的一个不同。</p>

<p>2，进程间不共享内存，不利于通信和数据交互。</p>

<p>3，多进程间的同步相对费事复杂。</p>

<h2 id="posix-">POSIX 多进程</h2>

<p>可以通过<strong>fork</strong>、<strong>kill</strong>、<strong>wait</strong>等原语来创建、管理进程。书里简单介绍了这几个原语的使用，小结一下就是：</p>

<p>1，<strong>fork</strong>会有两次返回，一次对<strong>child process</strong>，一次对<strong>parent process</strong>。<strong>fork</strong>的返回值为<strong>0</strong>代表在<strong>child process</strong>的上下文中，负数代表错误，正数代表<strong>parent process</strong>上下文中，并且返回值就是<strong>child process</strong>的<strong>pid</strong>。</p>

<p>2，<strong>parent process</strong>和<strong>child process</strong>并不<strong>share memory</strong>。</p>

<h2 id="posix--1">POSIX 多线程</h2>

<p>可以通过<strong>pthread_mutex_lock</strong>以及<strong>pthread_mutex_unlock</strong>等原语，以加锁和释放锁的方式，使用多线程来并行设计。</p>

<p>锁有多种，除了互斥锁，读写锁也是常见的一种。读写锁的特点是：</p>

<p>1，同一个时刻，允许多个读线程。当然，此时不能有写线程。</p>

<p>2，同一个时刻，最多只能有一个写线程进行更新操作。</p>

<p>也就是说写写互斥，写读互斥，读读不互斥。换句话说，要么多个读线程，要么一个写线程。</p>

<p>那么读写锁的<strong>scalability</strong>如何呢？作者写了一个程序来分析，程序运行在<strong>64</strong>个<strong>cores</strong>，一共<strong>n</strong>个读线程，每个读线程的流程大概是：</p>

<pre><code>while(not terminated)
{
  acquire the lock;
  do something;//t1
  release the lock;
  wait some time;//t2
  ++count of acquisitions;
}
</code></pre>

<p>把其中<strong>t2</strong>的时间设置为<strong>0</strong>，<strong>t1</strong>的控制则是通过更改调整执行循环次数（图上所谓的<strong>100K</strong>、<strong>100M</strong>神马的）。图上的横坐标为线程数目，纵坐标代表 $\frac {C}{nc}$ ，其中<strong>C</strong>是<strong>n</strong>个线程总共的<strong>acquisition</strong>数目，<strong>c</strong>是单个线程<strong>acquisition</strong>数目。</p>

<p>理想情况下，这个值应该是<strong>1.0</strong>。</p>

<p><img src="http://7xnljs.com1.z0.glb.clouddn.com/figure4.10.jpg" alt="expriments for rwl" /></p>

<p>实验表明，当读线程的数目增多，每次<strong>acquire lock</strong>时，花在修改数据结构（锁也是一种数据结构实现，当一个读线程<strong>acquire</strong>或者<strong>release</strong>成功显然需要对数据结构进行修改，加加减减神马的）的时间将显著影响<strong>scalability</strong>。极端情况下，当<strong>n</strong>个读线程同时<strong>acquire</strong>时，第<strong>n</strong>个线程需要等前面的<strong>n-1</strong>个线程都修改完毕，它才能修改。</p>

<p>同时，注意到线程有<strong>n</strong>个，而<strong>CPU</strong> <strong>cores</strong>只有<strong>64</strong>个，因此当<strong>n&lt;=64</strong>时，每个<strong>thread</strong>可以独享一个<strong>core</strong>，当<strong>n&gt;64</strong>后，根据鸽巢原理，至少有一个<strong>core</strong>上有多个<strong>thread</strong>在运行，这也会带来性能下降。</p>

<p>因此，读写锁比较适合临界区比较大的情形（有文件<strong>IO</strong>或者网络访问等）。</p>

<p>如果临界区比较短呢？比如我仅仅是加加一个变量呢？哦，那么原子操作可能是一个很好的选择。</p>

<h2 id="section">原子操作</h2>

<p><strong>gcc</strong>内置提供了一系列的原子操作。很多操作有两个版本，比如说：</p>

<p><code>__sync_fetch_and_sub()</code>与 <code>__sync_sub_and_fetch()</code>，如名字所说，一个是先减，然后获得减之后的新值；一个是减，返回的是减之前的<strong>old value</strong>。</p>

<p>此外，非常有名的<strong>CAS</strong>操作：</p>

<p><code>__sync_bool_compare_and_swap()</code>和<code>__sync_val_compare_and_swap()</code>，前者返回是否操作成功（待修改变量被替换为新值），而后者返回的是老值。</p>

<p>由于原子操作是让多个步骤看起来是一次的行为，因此往往包含<strong>Memory Barrier</strong>以保证语句的执行顺序。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++中逗号表达式的一个应用]]></title>
    <link href="http://www.yebangyu.org/blog/2015/10/22/atrickofcomma/"/>
    <updated>2015-10-22T23:55:35+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/10/22/atrickofcomma</id>
    <content type="html"><![CDATA[<p>假设我们的程序需要调用三个函数<strong>f</strong>，<strong>g</strong>，<strong>h</strong>。其中<strong>f</strong>和<strong>h</strong>可能失败，可能成功，而<strong>g</strong>一定成功。<strong>f</strong>和<strong>h</strong>有返回值，<strong>g</strong>没有返回值。我们可能得写这样的代码：</p>

<pre><code>if (f()!=SUCCESS) {
  //abort
} else {
  g();
  if (h()!=SUCCESS) {
  }
}
</code></pre>

<p>由于<strong>g</strong>没有返回值，因此这么写似乎是天经地义的。能不能优雅点？</p>

<!--more-->

<p>借助于逗号表达式，我们可以这样：</p>

<pre><code>if (f()!=SUCCESS){
} else if (g(),false) { //逗号表达式
  //we will never be here...
} else if (h()!=SUCCESS) {
}
</code></pre>

<p>形式上更加优美，但是和之前的写法相比可读性较差，并且使用了三次比较，之前只需要两次比较。</p>

<p>在<strong>C++</strong>中，逗号表达式有时候是一种很有用的工具：(<strong>A,B,C</strong>)，则从左到右求值，最后<strong>C</strong>的（返回）值作为整个表达式的值。</p>
]]></content>
  </entry>
  
</feed>
