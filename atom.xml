<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Yebangyu's Blog]]></title>
  <link href="http://www.yebangyu.org/atom.xml" rel="self"/>
  <link href="http://www.yebangyu.org/"/>
  <updated>2015-10-25T22:33:52+08:00</updated>
  <id>http://www.yebangyu.org/</id>
  <author>
    <name><![CDATA[Yebangyu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tools of the Trade]]></title>
    <link href="http://www.yebangyu.org/blog/2015/10/25/tools-of-the-trade/"/>
    <updated>2015-10-25T22:09:08+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/10/25/tools-of-the-trade</id>
    <content type="html"><![CDATA[<p>本篇是对《<strong>Is parallel programming hard</strong>》第四章《<strong>Tools of the trade</strong>》的总结，不是单纯的翻译，算是读书笔记，并且略有补充。</p>

<p>本章介绍了并行编程的工具和途径，具体包括</p>

<blockquote><ul>
<li>Shell Script Languages</li>
<li>POSIX 多进程</li>
<li>POSIX 多线程</li>
<li>原子操作</li>
</ul>
</blockquote>

<h2>Shell Script Language</h2>

<!--more-->


<p>如果不同的执行单元之间没有过多的数据交互，待执行的任务分区性较好，那么我们可以考虑通过<strong>Shell</strong>创建多个进程来完成任务。例如，我们需要计算每连续的<strong>100</strong>个元素的和，需要计算3组，好吧，比如说我们需要计算<strong>1+2+3+&hellip;+100</strong>；<strong>101+102+&hellip;200</strong>；<strong>201+201+&hellip;+300</strong>，那么我们可以编写一个程序，然后通过<strong>Shell</strong>创建<strong>3</strong>个进程，通过命令行传入参数（比如这里的待求和的元素的起点）。</p>

<pre><code>compute 1 &gt; compute_1.out &amp;
compute 101 &gt; compute_2.out &amp;
compute 201 &gt; compute_3.out &amp;
wait
</code></pre>

<p>其中<strong>compute</strong>是可执行程序名，<strong>1</strong>、<strong>101</strong>、<strong>201</strong>是命令行参数，<strong>> x.out</strong>代表将输出结果重定向到文件<strong>x.out</strong>中，<strong>&amp;</strong>表示程序后台运行。<strong>wait</strong>表示等待运行程序结束。</p>

<p>那么多进程的并行设计有什么缺点呢？</p>

<p>1，创建进程的时间略长。在<strong>Intel Core Duo Laptop</strong>上创建一个最小<strong>C</strong>程序需要大概<strong>480ms</strong>。当你的任务执行时间和进程启动时间相比反而不值一提时，这时候创建进程所需的时间就显得很尴尬。多线程<strong>VS</strong>多进程也是<strong>Spark</strong>和<strong>Hadoop</strong>相比的一个不同。</p>

<p>2，进程间不共享内存，不利于通信和数据交互。</p>

<p>3，多进程间的同步相对费事复杂。</p>

<h2>POSIX 多进程</h2>

<p>可以通过<strong>fork</strong>、<strong>kill</strong>、<strong>wait</strong>等原语来创建、管理进程。书里简单介绍了这几个原语的使用，小结一下就是：</p>

<p>1，<strong>fork</strong>会有两次返回，一次对<strong>child process</strong>，一次对<strong>parent process</strong>。<strong>fork</strong>的返回值为<strong>0</strong>代表在<strong>child process</strong>的上下文中，负数代表错误，正数代表<strong>parent process</strong>上下文中，并且返回值就是<strong>child process</strong>的<strong>pid</strong>。</p>

<p>2，<strong>parent process</strong>和<strong>child process</strong>并不<strong>share memory</strong>。</p>

<h2>POSIX 多线程</h2>

<p>可以通过<strong>pthread_mutex_lock</strong>以及<strong>pthread_mutex_unlock</strong>等原语，以加锁和释放锁的方式，使用多线程来并行设计。</p>

<p>锁有多种，除了互斥锁，读写锁也是常见的一种。读写锁的特点是：</p>

<p>1，同一个时刻，允许多个读线程。当然，此时不能有写线程。</p>

<p>2，同一个时刻，最多只能有一个写线程进行更新操作。</p>

<p>也就是说写写互斥，写读互斥，读读不互斥。换句话说，要么多个读线程，要么一个写线程。</p>

<p>那么读写锁的<strong>scalability</strong>如何呢？作者写了一个程序来分析，程序运行在<strong>64</strong>个<strong>cores</strong>，一共<strong>n</strong>个读线程，每个读线程的流程大概是：</p>

<pre><code>while(not terminated)
{
  acquire the lock;
  do something;//t1
  release the lock;
  wait some time;//t2
  ++count of acquisitions;
}
</code></pre>

<p>把其中<strong>t2</strong>的时间设置为<strong>0</strong>，<strong>t1</strong>的控制则是通过更改调整执行循环次数（图上所谓的<strong>100K</strong>、<strong>100M</strong>神马的）。图上的横坐标为线程数目，纵坐标代表单个线程<strong>acquire</strong>次数乘以<strong>n</strong>然后除以所有线程的<strong>acquire</strong>总数），也就是\frac{cn}{C} 理想情况下，这个值应该是<strong>1.0</strong>。</p>

<p><img src="http://7xnljs.com1.z0.glb.clouddn.com/figure4.10.jpg" alt="expriments for rwl" /></p>

<p>实验表明，当读线程的数目增多，每次<strong>acquire lock</strong>时，花在修改数据结构（锁也是一种数据结构实现，当一个读线程<strong>acquire</strong>或者<strong>release</strong>成功显然需要对数据结构进行修改，加加减减神马的）的时间将显著影响<strong>scalability</strong>。极端情况下，当<strong>n</strong>个读线程同时<strong>acquire</strong>时，第<strong>n</strong>个线程需要等前面的<strong>n-1</strong>个线程都修改完毕，它才能修改。</p>

<p>同时，注意到线程有<strong>n</strong>个，而<strong>CPU</strong> <strong>cores</strong>只有<strong>64</strong>个，因此当<strong>n&lt;=64</strong>时，每个<strong>thread</strong>可以独享一个<strong>core</strong>，当<strong>n>64</strong>后，根据鸽巢原理，至少有一个<strong>core</strong>上有多个<strong>thread</strong>在运行，这也会带来性能下降。</p>

<p>因此，读写锁比较适合临界区比较大的情形（有文件<strong>IO</strong>或者网络访问等）。</p>

<p>如果临界区比较短呢？比如我仅仅是加加一个变量呢？哦，那么原子操作可能是一个很好的选择。</p>

<h2>原子操作</h2>

<p><strong>gcc</strong>内置提供了一系列的原子操作。很多操作有两个版本，比如说：</p>

<p><code>__sync_fetch_and_sub()</code>与 <code>__sync_sub_and_fetch()</code>，如名字所说，一个是先减，然后获得减之后的新值；一个是减，返回的是减之前的<strong>old value</strong>。</p>

<p>此外，非常有名的<strong>CAS</strong>操作：</p>

<p><code>__sync_bool_compare_and_swap()</code>和<code>__sync_val_compare_and_swap()</code>，前者返回是否操作成功（待修改变量被替换为新值），而后者返回的是老值。</p>

<p>由于原子操作是让多个步骤看起来是一次的行为，因此往往包含<strong>memory barrier</strong>以保证语句的执行顺序。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++中逗号表达式的一个应用]]></title>
    <link href="http://www.yebangyu.org/blog/2015/10/22/atrickofcomma/"/>
    <updated>2015-10-22T23:55:35+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/10/22/atrickofcomma</id>
    <content type="html"><![CDATA[<p>假设我们的程序需要调用三个函数<strong>f</strong>，<strong>g</strong>，<strong>h</strong>。其中<strong>f</strong>和<strong>h</strong>可能失败，可能成功，而<strong>g</strong>一定成功。<strong>f</strong>和<strong>h</strong>有返回值，<strong>g</strong>没有返回值。我们可能得写这样的代码：</p>

<pre><code>if (f()!=SUCCESS) {
  //abort
} else {
  g();
  if (h()!=SUCCESS) {
  }
}
</code></pre>

<p>由于<strong>g</strong>没有返回值，因此这么写似乎是天经地义的。能不能优雅点？</p>

<!--more-->


<p>借助于逗号表达式，我们可以这样：</p>

<pre><code>if (f()!=SUCCESS){
} else if (g(),false) { //逗号表达式
  //we will never be here...
} else if (g()!=SUCCESS) {
}
</code></pre>

<p>形式上更加优美，但是和之前的写法相比可读性较差，并且使用了三次比较，之前只需要两次比较。</p>

<p>在<strong>C++</strong>中，逗号表达式有时候是一种很有用的工具：(<strong>A,B,C</strong>)，则从左到右求值，最后<strong>C</strong>的（返回）值作为整个表达式的值。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Review简历心得和建议]]></title>
    <link href="http://www.yebangyu.org/blog/2015/10/22/tipsforwritingcv/"/>
    <updated>2015-10-22T22:39:33+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/10/22/tipsforwritingcv</id>
    <content type="html"><![CDATA[<p>最近帮很多朋友<strong>review</strong>他们的简历，总结起来存在以下问题：</p>

<blockquote><ul>
<li>简历太多页</li>
</ul>
</blockquote>

<p>请尽量不超过两页。一般地，每个<strong>hr</strong>阅读简历的时间大概在<strong>20</strong>s甚至更少，写那么多页不仅毫无必要，而且有害。 而且我怀疑一般的应届毕业生不大可能说写三页的履历。有些人说，你写不了三页是你水平不行，经历不丰富。按我说，写三四页不是履历丰富，而是根本不会写作。</p>

<blockquote><ul>
<li>大量无用信息</li>
</ul>
</blockquote>

<!--more-->


<p>这些无用信息具体包括：</p>

<p>民族，身高，是否团员，具体家庭住址、星座</p>

<p>自己的兴趣爱好。喜欢打篮球和写代码有联系吗？</p>

<p>自我评价最多一句话，不要一坨一坨。建议不要写自我评价，太水太扯了。</p>

<p>学校的<strong>logo</strong>。坦白说，大家只对你是哪个学校的有兴趣，对你学校的<strong>logo</strong>不感冒。</p>

<p>照片。招程序员不是招礼仪公关小姐啊大哥。颜值不是特别高就算了吧。</p>

<blockquote><ul>
<li>过于口语化</li>
</ul>
</blockquote>

<p>“做了”、"搞了"、“弄了”可以用“完成”、“设计”、“实现”、“部署”之类的词代替。</p>

<blockquote><ul>
<li>内容组织混乱</li>
</ul>
</blockquote>

<p>一段一段，一坨一坨，没有一定的分类和板式。建议分成个人信息、项目经验、实习经历、获奖证书等分门别类。</p>

<p>建议不要用这种形式（时间和学期混合）：</p>

<p>大一上   完成了<strong>xxxx</strong>系统</p>

<p>大二下   完成了<strong>xxxx</strong>系统</p>

<p><strong>2013</strong>-<strong>2014</strong> 完成了<strong>xxxx</strong>系统</p>

<p>大三下  完成了<strong>xxxx</strong>系统</p>

<p>建议用统一的时间轴表示，比如。</p>

<p><strong>2013.9</strong>-<strong>2014.7</strong>   完成了<strong>xxxx</strong>系统</p>

<p><strong>2014.7</strong>-<strong>2015.6</strong>   完成了<strong>xxxx</strong>系统</p>

<p><strong>2016.1</strong>-<strong>2018.3</strong>   完成了<strong>xxxx</strong>系统</p>

<blockquote><ul>
<li>漏写期望职位</li>
</ul>
</blockquote>

<p>是想应聘<strong>Java</strong>研发工程师还是<strong>C++</strong>研发工程师还是<strong>Python</strong>研发工程师还是算法工程师还是产品经理？</p>

<blockquote><ul>
<li>使用词汇不讲究</li>
</ul>
</blockquote>

<p>慎用”精通“的同时，也不要全部都是“了解”吧？</p>

<blockquote><ul>
<li>漏写性别</li>
</ul>
</blockquote>

<p>程序员和程序媛差别还是很大的。不过这可能会涉及敏感的政治/性别歧视问题。有争议。不过如果是程序媛，据我说知，不是歧视，而反而是优先录取。哈哈。赞。</p>

<blockquote><ul>
<li>用<strong>QQ</strong>邮箱</li>
</ul>
</blockquote>

<p>包括联系邮箱里写<strong>QQ</strong>邮箱和用<strong>QQ</strong>邮箱发简历。很多公司已经把<strong>QQ</strong>邮箱拉入黑名单。平常用<strong>QQ</strong>聊天就算了，发邮件你还用<strong>QQ</strong>邮箱？</p>

<blockquote><ul>
<li>文件格式用<strong>doc</strong></li>
</ul>
</blockquote>

<p>建议只发<strong>pdf</strong>格式，<strong>doc</strong>格式容易出现各种显示问题。</p>

<blockquote><ul>
<li>文件名太随意</li>
</ul>
</blockquote>

<p>文件名建议“李三-<strong>C++</strong>研发工程师-硕士-<strong>XX</strong>大学<strong>.pdf</strong>”这样。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hardware and Its Habit]]></title>
    <link href="http://www.yebangyu.org/blog/2015/10/18/hardwareanditshabit/"/>
    <updated>2015-10-18T12:29:44+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/10/18/hardwareanditshabit</id>
    <content type="html"><![CDATA[<p>最近在阅读《<strong>Is parallel programming hard</strong>》这本书，本篇就是整理其中第三章《<strong>Hardware and its habit</strong>》，不是单纯的翻译，只是一个总结，略有补充。</p>

<p>这章介绍了影响<strong>CPU</strong>执行效率的几个因素。具体包括：</p>

<blockquote><ul>
<li>流水线被打断</li>
<li>内存访问</li>
<li>原子操作</li>
<li>Memory Barrier</li>
<li>Cache Misses</li>
<li>IO 操作</li>
</ul>
</blockquote>

<!--more-->


<p>这其中，前面两个，流水线被打断以及内存访问主要针对串行程序，而后面四个主要针对并行程序，因为在并行程序中显得更为突出。</p>

<h3>流水线被打断</h3>

<p>现代<strong>CPU</strong>执行指令采用流水线设计和指令预取机制，而影响流水的两种重要情况是停机等待和分支判断失败。前者是<strong>CPU</strong>没有足够的信息来判断取哪些指令（例如，涉及到<strong>C++</strong>中的虚函数时）。而分支判断失败，则是取了指令但是没取对。例如</p>

<pre><code>int a = get();
if (a == 1)
{
  //A
}
else
{
  //B
}
</code></pre>

<p>假设<strong>CPU</strong>预取指令<strong>A</strong>。当预测失败时（<strong>a</strong>不等于<strong>1</strong>），流水线中<strong>A</strong>指令需要被冲刷（<strong>flush</strong>），继而载入<strong>B</strong>指令。冲刷流水线和载入<strong>B</strong>指令都是非常昂贵的操作，因此这深深地影响了效率。</p>

<p>因此，在实际编程时，应该将最有可能执行的代码放到最前面。在<strong>gcc</strong>中内置提供了<strong>likely</strong>和<strong>unlikely</strong>宏，来优化程序分支判断。</p>

<pre><code>#define  likely(x)        __builtin_expect(!!(x), 1) 
#define  unlikely(x)      __builtin_expect(!!(x), 0) 
</code></pre>

<p>因此，上面的程序可以改写为：</p>

<pre><code>int a = get();
if (unlikely(a == 1)) //根据实际情况选择unlikely或者likely
{
  //A
}
else
{
  //B
}
</code></pre>

<h3>内存访问</h3>

<p>这个不用说了，内存访问是昂贵操作，相对于寄存器、<strong>cache</strong>而言。</p>

<p>在上世纪的系统中，从内存中读一个值的速度要比<strong>CPU</strong>执行一条指令快速。后来，由于<strong>CPU</strong>的快速发展以及内存容量的增大，这种局面发生了改变。你能想象只有<strong>4KB</strong>内存的机器吗？现在，光是<strong>cache</strong>都不止<strong>4KB</strong>了。</p>

<p>数组通常有比较好的内存访问模式，也就是说访问了<strong>a[0]</strong>，就可以将<strong>a[1]</strong>,<strong>a[2]</strong>,<strong>a[3]</strong>等存进<strong>cache</strong>，等访问到<strong>a[1]</strong>时不需要去访问内存了。但是一般用指针实现的链表的访问模式则比较差。恩，所谓的空间局部性。</p>

<h3>原子操作</h3>

<p><strong>gcc</strong>内置提供了一系列的原子操作，包括著名的用于<strong>CAS</strong>(<strong>compare</strong> <strong>and</strong> <strong>swap</strong>)的<strong>__sync_bool_compare_and_swap</strong>等。当多个线程对一个内存变量进行原子操作时，往往依赖于硬件支持。在<strong>x86</strong>下，原子操作时，锁住总线，防止其他<strong>cpu</strong> <strong>core</strong>访问该内存单元。</p>

<h3>Memory Barrier</h3>

<p><strong>CPU</strong>对指令可能采取乱序执行，以达到优化的目的。但是，并发访问的锁破坏了这种机制。</p>

<pre><code>c = 3;
lock.lock();
a = 1;
b = 2;
lock.unlock();
d = 4;
</code></pre>

<p><code>d=4</code>绝对不会在<code>a=1</code>之前执行，<code>c=3</code>绝对不会在<code>a=1</code>之后执行。</p>

<p><strong>lock</strong>和<strong>unlock</strong>中包含了<strong>memory</strong> <strong>barrier</strong>。由于<strong>memory</strong> <strong>barrier</strong>和乱序执行是对着干的，用来防止乱序执行的；而乱序执行一般是优化的手段和方法，因此<strong>memory</strong> <strong>barrier</strong>往往带来性能下降。</p>

<h3>Cache Misses</h3>

<p>先贴一张现代<strong>CPU</strong>和<strong>cache</strong>架构粗略图。</p>

<p><img src="http://7xnljs.com1.z0.glb.clouddn.com/cpuand%20cache.png" alt="cmd-markdown-logo" /></p>

<p>多个<strong>CPU</strong> <strong>core</strong>，一个内存。<strong>cacheline</strong>是<strong>cache</strong>块单位，一般在<strong>32</strong>到<strong>256</strong>字节左右。<strong>cacheline</strong>是这张图中不同模块的数据交互元素。</p>

<p>每两个<strong>cpu</strong> <strong>core</strong>和<strong>Interconnect</strong>组成一个<strong>die</strong>，同一个<strong>die</strong>中的<strong>cpu</strong> <strong>core</strong>通过<strong>Interconnect</strong>来沟通。不同<strong>die</strong>里的<strong>cpu</strong> <strong>core</strong>通过<strong>System</strong> <strong>Interconnect</strong>来沟通。</p>

<p>某个<strong>core</strong>需要对内存变量进行修改时，该变量的<strong>cacheline</strong>如果位于别的<strong>core</strong>的<strong>cache</strong>里，这种情况下的<strong>cache miss</strong>代价很大。</p>

<p>书中举了一个相对简单的例子：<strong>cpu 0</strong>需要对一个变量进行<strong>cas</strong>操作，检查自己的<strong>cache</strong>，发现没有。这时候：</p>

<p>1，<strong>cpu 0</strong>发送请求给<strong>Interconnect</strong>(<strong>cpu 0 &amp; cpu 1</strong>)，后者检查<strong>cpu 1</strong>的<strong>cache</strong>，发现木有。</p>

<p>2，<strong>Interconnect</strong>(<strong>cpu 0 &amp; cpu 1</strong>)将请求发给<strong>System</strong> <strong>Interconnect</strong>，后者检查其他的<strong>3</strong>个<strong>die</strong>，得知<strong>cacheline</strong>位于由<strong>cpu 6</strong>和<strong>cpu 7</strong> 组成的那个<strong>die</strong>里。</p>

<p>3，请求被发给由<strong>cpu 6</strong> 和<strong>cpu 7</strong>组成的那个<strong>die</strong>里的<strong>Interconnect</strong>(<strong>cpu 6</strong> <strong>&amp;</strong> <strong>cpu 7</strong>)，它同时检查<strong>cpu 6</strong>和<strong>cpu 7</strong>的<strong>cache</strong>，得知<strong>cacheline</strong>位于<strong>cpu 7</strong>的<strong>cache</strong>里。</p>

<p>4，<strong>cpu 7</strong> 把<strong>cacheline</strong>发送给<strong>Interconnect</strong>(<strong>cpu 6 &amp; cpu 7</strong>), <strong>and flushes the cacheline from its cache</strong>，以保证<strong>cache</strong>一致性</p>

<p>5，<strong>Interconnect</strong>(<strong>cpu 6 &amp; cpu 7</strong>)将<strong>cacheline</strong>发送给<strong>System</strong> <strong>Interconnect</strong>。</p>

<p>6，<strong>System</strong> <strong>Interconnect</strong>将<strong>cacheline</strong>发送给<strong>Interconnect</strong>(<strong>cpu 0 &amp; cpu 1</strong>)</p>

<p>7，<strong>Interconnect</strong>（<strong>cpu 0 &amp; cpu 1</strong>）将<strong>cacheline</strong>存入<strong>cpu 0</strong>的<strong>cache</strong>里。</p>

<p>是啊，这已经是简单的情况了。想想看，什么情况下更复杂？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读研如何提高技术之我见]]></title>
    <link href="http://www.yebangyu.org/blog/2015/10/17/whattodoinmaster/"/>
    <updated>2015-10-17T14:34:04+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/10/17/whattodoinmaster</id>
    <content type="html"><![CDATA[<p>你想进什么公司，和你读什么计算机方向，关系不是很大。只要是理工科的学生，面对技术岗位，其实机会是差不多的。</p>

<p>至于你想什么职位，那显然和你的专业/方向关系较大，比如说很多大数据职位，就明确表示要求你<strong>DM</strong>/<strong>ML</strong>/<strong>NLP</strong>/<strong>IR</strong>背景，但是这也只是说这些
学生可能更有优势些，事实上，数学和统计学出身的，很多搞这个非常牛逼的。</p>

<p>所以，不要问选什么导师，选什么方向；也不要问我的实验室很水老板很菜我还能找到好工作吗？你要问的是：我想毕业去互联
网公司，我读研的这几年是应该打酱油呢，还是打地沟油？</p>

<p>想找一个好的互联网技术类、研发类工作，无非就是以下4点，你任选一点，做好了，都是有利的，哪4点？</p>

<blockquote><ul>
<li>语言层面</li>
<li>算法层面</li>
<li>项目层面</li>
<li>专业层面</li>
</ul>
</blockquote>

<!--more-->


<p>具体分析如下：</p>

<hr />

<h3>语言层面</h3>

<p>你是想搞<strong>C++</strong>还是<strong>Java</strong>？选定一门语言后，多看一些这方面的书。</p>

<p><strong>C++</strong>，不用说了，<strong>《Effective C++》</strong>，<strong>《More Effective C++》</strong>，<strong>《Inside The C++ Object Model》</strong>等等。</p>

<p><strong>Java</strong>，最好能看点虚拟机相关的。尤其是<strong>Java</strong>虚拟机的内存管理。以及多线程、线程池、设计模式等。</p>

<p>问题来了：学<strong>C++</strong>好还是学<strong>Java</strong>好呢？语言争论每天都在发生，真的好无聊。建议按照方向和兴趣来选择，不靠谱的说：</p>

<p>如果是想做大型游戏开发、底层研发、系统研发、驱动研发等等，就选用<strong>C</strong>/<strong>C++</strong>。</p>

<p>如果是想做网站开发、网络研发、上层开发、<strong>Android</strong>开发等等，就选用<strong>Java</strong>。</p>

<p>顺便说一下，有空可以学学<strong>Python</strong>。</p>

<hr />

<h3>算法层面</h3>

<p>学好算法。这个有两条路，最好是并行，那就是看书和做题。</p>

<p>看书的话，主要有《算法导论》、《算法》（<strong>Robert Sedgewick</strong>著）、《算法竞赛入门经典》、《挑战程序设计竞赛》</p>

<p>找一本认真看，认真思考。证明过程可以不看，但是算法思想最好能懂，以及实现，最好能在纸张上写出来。复杂度总要知道吧？</p>

<p>研一的时候，我就把算法导论上的很多算法，都自己亲自coding了下。</p>

<p>特别复杂的数据结构，比如红黑树、<strong>B</strong>树，没空就别搞了。互联网面试一般都不要求的。</p>

<p>主要是排序、查找、简单<strong>DP</strong>、贪心、图算法和搜索。 根据身边同学的面试经验，二分搜索和快速排序，是面试常备了。看书的时候，如果有
时间，可以思考几个问题：</p>

<ul>
<li><p>这个算法的时间空间复杂度，各是多少？如何分析？</p></li>
<li><p>工程实现里，都有哪些<strong>trick</strong>？如何加速？</p></li>
<li><p>这个算法可能用在哪些方面？有哪些应用？你比如说吧，求交集的算法，就广泛用在倒排索引、新浪微博共同关注、计算<strong>Jaccard</strong>系数等
等上。</p></li>
</ul>


<p>除了看书，还有就是很重要的：刷题啦。主要有<strong>poj</strong>，<strong>zoj</strong>等。找一个网站，认真刷一些题目，踏踏实实的，别浮躁。</p>

<hr />

<h3>项目层面</h3>

<p>如果实验室比较牛，基本上忙项目就足够累死累活了；不过做了相对给力的项目，对于找工作，还是有很大帮助的。基本上不用怎么愁了。
如果老板这儿没项目呢？</p>

<p>如果实验室比较水，那就尽量去实习。大公司的实习经验很能给简历加分。如果老板不让你出去实习。ok，既然实验室很水，说明自由时间
比较多，那还是可以干很多事。比如说，<strong>github</strong>上就有很多开源项目，你可以选择一两个著名的，阅读源码，然后尝试自己也参与进去。</p>

<p>说几个我比较感兴趣的开源项目吧：<strong>redis</strong>，<strong>spark</strong>。</p>

<hr />

<h3>专业层面</h3>

<p>你对数据挖掘很精通，你对推荐系统很熟悉。你在<strong>NIPS</strong>，<strong>SIGIR</strong>上发表论文无数；你是百度推荐大赛，阿里巴巴大数据比赛冠军常客。</p>

<p>也就是说，除了尝试发顶会论文，还可以参加各种比赛。本专业本领域里都有什么比赛可以参加呢？搜一下微博或者知乎，或者问下师兄师姐，不就知道了？</p>

<p>专业层面，可以做的东西非常多。比如，你对数据挖掘很感兴趣，那么数据挖掘中的常见模型，我们了解多少？机器学习，我们掌握到什么
程度了？举个例子：</p>

<ul>
<li><p><strong>SVM</strong>和<strong>logistic regression</strong>这两种<strong>model</strong>，有什么特点？各自的适用场合？</p></li>
<li><p><strong>feature selection</strong>的常用方法有哪些？为什么<strong>lasso</strong>可以作为<strong>feature selection</strong>？</p></li>
<li><p><strong>Adaboosting</strong>为什么不容易<strong>over-fitting</strong>？你能不能从<strong>statistical view</strong>来解释解释？</p></li>
<li><p>哦，你和我说，你不是搞学术研究，你反感<strong>Learning Theory</strong>，你说你是一个工程师，那你写了多少代码？</p></li>
</ul>


<p><strong>scikit-learn</strong>，<strong>weka</strong>，以及<strong>spark</strong>，你会用哪个工具？（熟悉一种工具）</p>

<p>你有自己下载一些数据集跑跑实验吗？你有参加一些大数据相关的竞赛吗？（动手实验/参加比赛）</p>

<p>专业层面，能做的，要做的，还有很多。</p>

<p>哦，最好熟悉下<strong>linux</strong>的基本使用。</p>

<hr />

<h3>最后的话</h3>

<p>如果能在读研期间做到这里的一点或者几点，到时候甚至不需要翻《编程之美》或者<strong>leetcode</strong>就毫无压力啦。 最后说几点个人感受。</p>

<ul>
<li>算法牛，项目牛，长得又帅，又精通很多语言，这种人，是不多见的。</li>
</ul>


<p>也就是说，你想拿一个好<strong>offer</strong>，一般只要有一两点突出，就可以了。</p>

<ul>
<li>互联网面试，除了个别公司个别面试官，一般都是要考查（考查？考察？这两个词有什么区别？考察是调研、研究、分析的意思）算法的
。你研一的时候准备，看书做题，总比研三的时候抱佛脚来的好吧？</li>
</ul>


<p>况且，算法的学习，也不仅仅是为了面试吧？可能是受益终身的。或者，吹牛皮装逼作为谈资，也是可以的。</p>

<ul>
<li>别轻易说我就要去某某公司。到时候，你会发现，选择比你想象的多。</li>
</ul>


<p>也有可能比你想象的还少，为什么？</p>

<p>就看你有没有做到我上面说的这些了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Windows下OctoPress环境搭建]]></title>
    <link href="http://www.yebangyu.org/blog/2015/10/17/howtoinstalloctopress/"/>
    <updated>2015-10-17T11:28:19+08:00</updated>
    <id>http://www.yebangyu.org/blog/2015/10/17/howtoinstalloctopress</id>
    <content type="html"><![CDATA[<hr />

<p>近期学习了如何搭建个人博客的方法，这里备忘一下，如果能帮助到别人，那就更好了。</p>

<p>使用的工具主要用<strong>OctoPress</strong>,<strong>github</strong>,<strong>ruby</strong>,<strong>python</strong>等，在配置的过程中，主要参考了这篇文章： <a href="http://www.cnblogs.com/oec2003/archive/2013/05/27/3100896.html">http://www.cnblogs.com/oec2003/archive/2013/05/27/3100896.html</a> 在此表示衷心的感谢</p>

<h3>Github</h3>

<p>首先，得有一个<strong>github</strong>的账号，便于托管。在申请了<strong>github</strong>账号之后，建立一个个人仓库，仓库的命名必须是<code>yourusername.github.io</code>这样的形式。如果您有购买个人域名，还可以通过CNAME来完成绑定。这一步可以google一下</p>

<h3>Ruby</h3>

<p>安装Ruby的时候需要特别注意勾选“<strong>Add Ruby executables to your PATH</strong>”</p>

<!--more-->


<h3>DevKit</h3>

<p>下载解压到某个目录（例如<strong>DevKit</strong>），打开<strong>cmd</strong>，执行如下口令</p>

<pre><code>cd DevKit
ruby dk.rb init 
ruby dk.rb install
</code></pre>

<h3>Python</h3>

<p>安装<strong>python</strong>，安装<strong>easy_install</strong>，然后在<strong>cmd</strong>中执行如下命令安装<strong>pygments</strong></p>

<pre><code>easy_install pygments
</code></pre>

<h3>OctoPress</h3>

<p>首先，通过<strong>git</strong>命令将<strong>OctoPress</strong>下载到本地</p>

<pre><code>git clone git://github.com/imathis/octopress.git octopress
</code></pre>

<p>切换到目录，然后执行</p>

<pre><code>gem sources -a https://ruby.taobao.org/
gem sources -r http://rubygems.org/
gem sources -l
</code></pre>

<p>请特别注意，第一行里，是<strong>https</strong>，而不是<strong>http</strong>。</p>

<p>修改Gemfile下的文件，把将第一行的<a href="http://rubygems.org/">http://rubygems.org/</a> 改为<a href="https://ruby.taobao.org/">https://ruby.taobao.org/</a></p>

<p>然后，依次执行如下命令</p>

<pre><code>gem install bundler
bundle install
</code></pre>

<p>并安装<strong>Octopress</strong>的默认主题</p>

<pre><code>rake install
</code></pre>

<p>环境基本上就配置好了，运行<code>rake preview</code>，然后打开<a href="http://127.0.0.1:4000/">http://127.0.0.1:4000/</a> 看看效果吧，恩，本地的效果。接下去就要写文章，继而发布到<strong>github</strong>上了。</p>

<h3>编写文章</h3>

<p>运行<code>rake new_post['helloworld']</code></p>

<p>这样就可以在<strong>octopress/source/_posts</strong> 下生成一个<strong>markdown</strong>文件，然后就可以开始通过编辑该文件来写文章了。我一般使用<strong>Cmd Markdown</strong> 编辑阅读器来写文章，很适合我这样的新手</p>

<p>写完文章，就可以生成了，命令是<code>rake generate</code> ，然后再通过前面的<code>rake preview</code>来预览下</p>

<h3>发布</h3>

<p>运行命令，<code>rake setup_github_pages</code> 来设置您的<strong>github</strong>账号。注意，这一步得在<strong>git bash</strong>下完成，而不是<strong>Windows</strong>命令提示符下。</p>

<p>运行命令，<code>rake deploy</code> ，将文章发布到<strong>github</strong>上。</p>

<p>这样一篇文章就发布出去了。以后写新文章或者更改文章后，只需要<code>rake generate</code> 然后 <code>rake deploy</code> 就可以啦</p>
]]></content>
  </entry>
  
</feed>
